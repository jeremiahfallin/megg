
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/index';
declare const prisma: unique symbol
export type PrismaPromise<A> = Promise<A> & {[prisma]: true}
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model Activity
 * 
 */
export type Activity = {
  id: string
  profileId: string | null
  month: number | null
  year: number | null
  day: number | null
  gamesPlayed: number | null
}

/**
 * Model ChampionWinrate
 * 
 */
export type ChampionWinrate = {
  id: string
  profileId: string | null
  champion: string
  wins: number | null
  games: number | null
  spell1Casts: number | null
  spell2Casts: number | null
  spell3Casts: number | null
  spell4Casts: number | null
}

/**
 * Model Duo
 * 
 */
export type Duo = {
  id: string
  profileId: string | null
  name: string
  wins: number | null
  losses: number | null
  winrate: string
}

/**
 * Model Constant
 * 
 */
export type Constant = {
  id: string
  startTime: string
  currentSeason: string
  seeding: boolean
}

/**
 * Model Event
 * 
 */
export type Event = {
  id: string
  timestamp: number | null
}

/**
 * Model Game
 * 
 */
export type Game = {
  id: string
  matchId: string
  gameId: string
  gameCreation: string
  gameStartTimestamp: string
  gameEndTimestamp: string
  duration: number | null
  start: string
  gameVersion: string
  blueTeamId: string | null
  redTeamId: string | null
  tournament: string
  gameInSeries: number | null
  vod: string
  platformId: string
}

/**
 * Model Objective
 * 
 */
export type Objective = {
  id: string
  teamId: string | null
  first: boolean
  kills: number | null
  type: string
}

/**
 * Model PickBan
 * 
 */
export type PickBan = {
  id: string
  teamId: string | null
  championId: number | null
  pickTurn: number | null
}

/**
 * Model Player
 * 
 */
export type Player = {
  id: string
  puuid: string
  accountId: string
  platformId: string
  summonerId: string
  summonerName: string
  summonerLevel: number | null
  profileIconId: number | null
  revisionDate: string
  profileId: string | null
}

/**
 * Model PlayerEndOfGameStat
 * 
 */
export type PlayerEndOfGameStat = {
  id: string
  playerId: string | null
  gameId: string | null
  perksId: string | null
  itemsId: string | null
  assists: number | null
  baronKills: number | null
  bountyLevel: number | null
  championExperience: number | null
  championLevel: number | null
  championId: number | null
  championName: string
  championTransform: number | null
  consumablesPurchased: number | null
  damageDealtToBuildings: number | null
  damageDealtToObjectives: number | null
  damageDealtToTurrets: number | null
  damageSelfMitigated: number | null
  deaths: number | null
  detectorWardsPlaced: number | null
  doubleKills: number | null
  dragonKills: number | null
  firstBlood: boolean
  firstBloodAssist: boolean
  firstTowerKill: boolean
  firstTowerAssist: boolean
  gameEndedInEarlySurrender: boolean
  gameEndedInSurrender: boolean
  goldEarned: number | null
  goldSpent: number | null
  individualPosition: string
  inhibitorKills: number | null
  inhibitorTakedowns: number | null
  inhibitorsLost: number | null
  item0: number | null
  item1: number | null
  item2: number | null
  item3: number | null
  item4: number | null
  item5: number | null
  item6: number | null
  itemsPurchased: number | null
  killingSprees: number | null
  kills: number | null
  lane: string
  largestCriticalStrike: number | null
  largestKillingSpree: number | null
  largestMultiKill: number | null
  longestTimeSpentLiving: number | null
  magicDamageDealt: number | null
  magicDamageDealtToChampions: number | null
  magicDamageTaken: number | null
  neutralMinionsKilled: number | null
  nexusKills: number | null
  nexusLost: number | null
  nexusTakedowns: number | null
  objectivesStolen: number | null
  objectivesStolenAssists: number | null
  participantId: number | null
  pentaKills: number | null
  physicalDamageDealt: number | null
  physicalDamageDealtToChampions: number | null
  physicalDamageTaken: number | null
  quadraKills: number | null
  riotIdName: string
  riotIdTagline: string
  role: string
  sightWardsBoughtInGame: number | null
  spell1Casts: number | null
  spell2Casts: number | null
  spell3Casts: number | null
  spell4Casts: number | null
  summoner1Casts: number | null
  summoner1Id: number | null
  summoner2Casts: number | null
  summoner2Id: number | null
  summonerLevel: number | null
  summonerName: string
  teamEarlySurrendered: boolean
  teamId: number | null
  teamPosition: string
  timeCCingOthers: number | null
  timePlayed: number | null
  totalDamageDealt: number | null
  totalDamageDealtToChampions: number | null
  totalDamageShieldedOnTeammates: number | null
  totalDamageTaken: number | null
  totalHeal: number | null
  totalHealsOnTeammates: number | null
  totalMinionsKilled: number | null
  totalTimeCCDealt: number | null
  totalTimeSpentDead: number | null
  totalUnitsHealed: number | null
  tripleKills: number | null
  trueDamageDealt: number | null
  trueDamageDealtToChampions: number | null
  trueDamageTaken: number | null
  turretsKilled: number | null
  turretTakedowns: number | null
  turretsLost: number | null
  unrealKills: number | null
  visionScore: number | null
  visionWardsBoughtInGame: number | null
  wardsKilled: number | null
  wardsPlaced: number | null
  win: boolean
}

/**
 * Model PlayerItem
 * 
 */
export type PlayerItem = {
  id: string
  slot: number | null
  itemId: number | null
  name: string
}

/**
 * Model PlayerItemEvent
 * 
 */
export type PlayerItemEvent = {
  id: string
  type: string
  itemId: number | null
  name: string
  undoId: number | null
}

/**
 * Model PlayerKill
 * 
 */
export type PlayerKill = {
  id: string
}

/**
 * Model PlayerRune
 * 
 */
export type PlayerRune = {
  id: string
  defense: number | null
  flex: number | null
  offense: number | null
}

/**
 * Model PlayerSkillLevelUpEvent
 * 
 */
export type PlayerSkillLevelUpEvent = {
  id: string
  type: string
  slot: number | null
}

/**
 * Model PlayerSnapshot
 * 
 */
export type PlayerSnapshot = {
  id: string
  timestamp: number | null
  currentGold: number | null
  totalGold: number | null
  totalGoldDiff: number | null
  xp: number | null
  xpDiff: number | null
  level: number | null
  cs: number | null
  csDiff: number | null
  monstersKilled: number | null
  monstersKilledDiff: number | null
}

/**
 * Model PlayerWardEvent
 * 
 */
export type PlayerWardEvent = {
  id: string
  type: string
  wardType: PlayerWardEventWardTypeType | null
}

/**
 * Model Position
 * 
 */
export type Position = {
  id: string
  x: number | null
  y: number | null
}

/**
 * Model Profile
 * 
 */
export type Profile = {
  id: string
  update: boolean
  lastUpdate: Date
  kills: number | null
  deaths: number | null
  assists: number | null
  kda: string
  winRate: string
  csPerMinute: string
  damagePerMinute: string
  killsPerMinute: string
  goldPerMinute: string
  averageGameTime: string
  averageTimeSpentDead: string
  totalGameTime: string
}

/**
 * Model SeedIdentifier
 * 
 */
export type SeedIdentifier = {
  id: string
  identifier: string
  type: string
  timestamp: Date
  priority: boolean
  retrieved: boolean
}

/**
 * Model Source
 * 
 */
export type Source = {
  id: string
  api: string
}

/**
 * Model Team
 * 
 */
export type Team = {
  id: string
  gameId: string | null
  teamId: number | null
  teamMatchId: string
  win: boolean
}

/**
 * Model TeamBuildingKill
 * 
 */
export type TeamBuildingKill = {
  id: string
  type: string
  lane: string
  side: string
  towerLocation: string
}

/**
 * Model TeamMonsterKill
 * 
 */
export type TeamMonsterKill = {
  id: string
  type: string
  subType: string
}

/**
 * Model RuneSelection
 * 
 */
export type RuneSelection = {
  id: string
  runeStyleId: string | null
  perk: number | null
  var1: number | null
  var2: number | null
  var3: number | null
}

/**
 * Model RuneStyle
 * 
 */
export type RuneStyle = {
  id: string
  playerRunesId: string | null
  description: string
  style: number | null
}


/**
 * Enums
 */

// Based on
// https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

export const PlayerWardEventWardTypeType: {
  YELLOW_TRINKET: 'YELLOW_TRINKET',
  CONTROL_WARD: 'CONTROL_WARD',
  SIGHT_WARD: 'SIGHT_WARD',
  YELLOW_TRINKET_UPGRADE: 'YELLOW_TRINKET_UPGRADE',
  BLUE_TRINKET: 'BLUE_TRINKET',
  TEEMO_MUSHROOM: 'TEEMO_MUSHROOM',
  VISION_WARD: 'VISION_WARD',
  UNDEFINED: 'UNDEFINED'
};

export type PlayerWardEventWardTypeType = (typeof PlayerWardEventWardTypeType)[keyof typeof PlayerWardEventWardTypeType]


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Activities
 * const activities = await prisma.activity.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
      /**
       * @private
       */
      private fetcher;
      /**
       * @private
       */
      private readonly dmmf;
      /**
       * @private
       */
      private connectionPromise?;
      /**
       * @private
       */
      private disconnectionPromise?;
      /**
       * @private
       */
      private readonly engineConfig;
      /**
       * @private
       */
      private readonly measurePerformance;

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Activities
   * const activities = await prisma.activity.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends PrismaPromise<any>[]>(arg: [...P]): Promise<UnwrapTuple<P>>;

      /**
   * `prisma.activity`: Exposes CRUD operations for the **Activity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Activities
    * const activities = await prisma.activity.findMany()
    * ```
    */
  get activity(): Prisma.ActivityDelegate<GlobalReject>;

  /**
   * `prisma.championWinrate`: Exposes CRUD operations for the **ChampionWinrate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChampionWinrates
    * const championWinrates = await prisma.championWinrate.findMany()
    * ```
    */
  get championWinrate(): Prisma.ChampionWinrateDelegate<GlobalReject>;

  /**
   * `prisma.duo`: Exposes CRUD operations for the **Duo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Duos
    * const duos = await prisma.duo.findMany()
    * ```
    */
  get duo(): Prisma.DuoDelegate<GlobalReject>;

  /**
   * `prisma.constant`: Exposes CRUD operations for the **Constant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Constants
    * const constants = await prisma.constant.findMany()
    * ```
    */
  get constant(): Prisma.ConstantDelegate<GlobalReject>;

  /**
   * `prisma.event`: Exposes CRUD operations for the **Event** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Events
    * const events = await prisma.event.findMany()
    * ```
    */
  get event(): Prisma.EventDelegate<GlobalReject>;

  /**
   * `prisma.game`: Exposes CRUD operations for the **Game** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Games
    * const games = await prisma.game.findMany()
    * ```
    */
  get game(): Prisma.GameDelegate<GlobalReject>;

  /**
   * `prisma.objective`: Exposes CRUD operations for the **Objective** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Objectives
    * const objectives = await prisma.objective.findMany()
    * ```
    */
  get objective(): Prisma.ObjectiveDelegate<GlobalReject>;

  /**
   * `prisma.pickBan`: Exposes CRUD operations for the **PickBan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PickBans
    * const pickBans = await prisma.pickBan.findMany()
    * ```
    */
  get pickBan(): Prisma.PickBanDelegate<GlobalReject>;

  /**
   * `prisma.player`: Exposes CRUD operations for the **Player** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Players
    * const players = await prisma.player.findMany()
    * ```
    */
  get player(): Prisma.PlayerDelegate<GlobalReject>;

  /**
   * `prisma.playerEndOfGameStat`: Exposes CRUD operations for the **PlayerEndOfGameStat** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlayerEndOfGameStats
    * const playerEndOfGameStats = await prisma.playerEndOfGameStat.findMany()
    * ```
    */
  get playerEndOfGameStat(): Prisma.PlayerEndOfGameStatDelegate<GlobalReject>;

  /**
   * `prisma.playerItem`: Exposes CRUD operations for the **PlayerItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlayerItems
    * const playerItems = await prisma.playerItem.findMany()
    * ```
    */
  get playerItem(): Prisma.PlayerItemDelegate<GlobalReject>;

  /**
   * `prisma.playerItemEvent`: Exposes CRUD operations for the **PlayerItemEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlayerItemEvents
    * const playerItemEvents = await prisma.playerItemEvent.findMany()
    * ```
    */
  get playerItemEvent(): Prisma.PlayerItemEventDelegate<GlobalReject>;

  /**
   * `prisma.playerKill`: Exposes CRUD operations for the **PlayerKill** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlayerKills
    * const playerKills = await prisma.playerKill.findMany()
    * ```
    */
  get playerKill(): Prisma.PlayerKillDelegate<GlobalReject>;

  /**
   * `prisma.playerRune`: Exposes CRUD operations for the **PlayerRune** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlayerRunes
    * const playerRunes = await prisma.playerRune.findMany()
    * ```
    */
  get playerRune(): Prisma.PlayerRuneDelegate<GlobalReject>;

  /**
   * `prisma.playerSkillLevelUpEvent`: Exposes CRUD operations for the **PlayerSkillLevelUpEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlayerSkillLevelUpEvents
    * const playerSkillLevelUpEvents = await prisma.playerSkillLevelUpEvent.findMany()
    * ```
    */
  get playerSkillLevelUpEvent(): Prisma.PlayerSkillLevelUpEventDelegate<GlobalReject>;

  /**
   * `prisma.playerSnapshot`: Exposes CRUD operations for the **PlayerSnapshot** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlayerSnapshots
    * const playerSnapshots = await prisma.playerSnapshot.findMany()
    * ```
    */
  get playerSnapshot(): Prisma.PlayerSnapshotDelegate<GlobalReject>;

  /**
   * `prisma.playerWardEvent`: Exposes CRUD operations for the **PlayerWardEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlayerWardEvents
    * const playerWardEvents = await prisma.playerWardEvent.findMany()
    * ```
    */
  get playerWardEvent(): Prisma.PlayerWardEventDelegate<GlobalReject>;

  /**
   * `prisma.position`: Exposes CRUD operations for the **Position** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Positions
    * const positions = await prisma.position.findMany()
    * ```
    */
  get position(): Prisma.PositionDelegate<GlobalReject>;

  /**
   * `prisma.profile`: Exposes CRUD operations for the **Profile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Profiles
    * const profiles = await prisma.profile.findMany()
    * ```
    */
  get profile(): Prisma.ProfileDelegate<GlobalReject>;

  /**
   * `prisma.seedIdentifier`: Exposes CRUD operations for the **SeedIdentifier** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SeedIdentifiers
    * const seedIdentifiers = await prisma.seedIdentifier.findMany()
    * ```
    */
  get seedIdentifier(): Prisma.SeedIdentifierDelegate<GlobalReject>;

  /**
   * `prisma.source`: Exposes CRUD operations for the **Source** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sources
    * const sources = await prisma.source.findMany()
    * ```
    */
  get source(): Prisma.SourceDelegate<GlobalReject>;

  /**
   * `prisma.team`: Exposes CRUD operations for the **Team** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Teams
    * const teams = await prisma.team.findMany()
    * ```
    */
  get team(): Prisma.TeamDelegate<GlobalReject>;

  /**
   * `prisma.teamBuildingKill`: Exposes CRUD operations for the **TeamBuildingKill** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TeamBuildingKills
    * const teamBuildingKills = await prisma.teamBuildingKill.findMany()
    * ```
    */
  get teamBuildingKill(): Prisma.TeamBuildingKillDelegate<GlobalReject>;

  /**
   * `prisma.teamMonsterKill`: Exposes CRUD operations for the **TeamMonsterKill** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TeamMonsterKills
    * const teamMonsterKills = await prisma.teamMonsterKill.findMany()
    * ```
    */
  get teamMonsterKill(): Prisma.TeamMonsterKillDelegate<GlobalReject>;

  /**
   * `prisma.runeSelection`: Exposes CRUD operations for the **RuneSelection** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RuneSelections
    * const runeSelections = await prisma.runeSelection.findMany()
    * ```
    */
  get runeSelection(): Prisma.RuneSelectionDelegate<GlobalReject>;

  /**
   * `prisma.runeStyle`: Exposes CRUD operations for the **RuneStyle** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RuneStyles
    * const runeStyles = await prisma.runeStyle.findMany()
    * ```
    */
  get runeStyle(): Prisma.RuneStyleDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  /**
   * Prisma Client JS version: 3.11.1
   * Query Engine version: efdf9b1183dddfd4258cd181a72125755215ab7b
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: 'DbNull'

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: 'JsonNull'

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: 'AnyNull'

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = {
    [key in keyof T]: T[key] extends false | undefined | null ? never : key
  }[keyof T]

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Buffer
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Exact<A, W = unknown> = 
  W extends unknown ? A extends Narrowable ? Cast<A, W> : Cast<
  {[K in keyof A]: K extends keyof W ? Exact<A[K], W[K]> : never},
  {[K in keyof W]: K extends keyof A ? Exact<A[K], W[K]> : W[K]}>
  : never;

  type Narrowable = string | number | boolean | bigint;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: Exact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
  }

  export const ModelName: {
    Activity: 'Activity',
    ChampionWinrate: 'ChampionWinrate',
    Duo: 'Duo',
    Constant: 'Constant',
    Event: 'Event',
    Game: 'Game',
    Objective: 'Objective',
    PickBan: 'PickBan',
    Player: 'Player',
    PlayerEndOfGameStat: 'PlayerEndOfGameStat',
    PlayerItem: 'PlayerItem',
    PlayerItemEvent: 'PlayerItemEvent',
    PlayerKill: 'PlayerKill',
    PlayerRune: 'PlayerRune',
    PlayerSkillLevelUpEvent: 'PlayerSkillLevelUpEvent',
    PlayerSnapshot: 'PlayerSnapshot',
    PlayerWardEvent: 'PlayerWardEvent',
    Position: 'Position',
    Profile: 'Profile',
    SeedIdentifier: 'SeedIdentifier',
    Source: 'Source',
    Team: 'Team',
    TeamBuildingKill: 'TeamBuildingKill',
    TeamMonsterKill: 'TeamMonsterKill',
    RuneSelection: 'RuneSelection',
    RuneStyle: 'RuneStyle'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    postgresql?: Datasource
  }

  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     *  * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your prisma.schema file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  export type Hooks = {
    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'

  /**
   * These options are being passed in to the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined; 
  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type EventCountOutputType
   */


  export type EventCountOutputType = {
    position: number
  }

  export type EventCountOutputTypeSelect = {
    position?: boolean
  }

  export type EventCountOutputTypeGetPayload<
    S extends boolean | null | undefined | EventCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? EventCountOutputType
    : S extends undefined
    ? never
    : S extends EventCountOutputTypeArgs
    ?'include' extends U
    ? EventCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof EventCountOutputType ? EventCountOutputType[P] : never
  } 
    : EventCountOutputType
  : EventCountOutputType




  // Custom InputTypes

  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the EventCountOutputType
     * 
    **/
    select?: EventCountOutputTypeSelect | null
  }



  /**
   * Count Type GameCountOutputType
   */


  export type GameCountOutputType = {
    source: number
    from_PlayerEndOfGameStat_game: number
    from_Team_game: number
  }

  export type GameCountOutputTypeSelect = {
    source?: boolean
    from_PlayerEndOfGameStat_game?: boolean
    from_Team_game?: boolean
  }

  export type GameCountOutputTypeGetPayload<
    S extends boolean | null | undefined | GameCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? GameCountOutputType
    : S extends undefined
    ? never
    : S extends GameCountOutputTypeArgs
    ?'include' extends U
    ? GameCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof GameCountOutputType ? GameCountOutputType[P] : never
  } 
    : GameCountOutputType
  : GameCountOutputType




  // Custom InputTypes

  /**
   * GameCountOutputType without action
   */
  export type GameCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the GameCountOutputType
     * 
    **/
    select?: GameCountOutputTypeSelect | null
  }



  /**
   * Count Type PlayerCountOutputType
   */


  export type PlayerCountOutputType = {
    kills: number
    deaths: number
    teams: number
    monsterKills: number
    buildingKills: number
    itemEvent: number
    endOfGameStats: number
    snapshots: number
    wardEvents: number
    skillLevelUpEvents: number
  }

  export type PlayerCountOutputTypeSelect = {
    kills?: boolean
    deaths?: boolean
    teams?: boolean
    monsterKills?: boolean
    buildingKills?: boolean
    itemEvent?: boolean
    endOfGameStats?: boolean
    snapshots?: boolean
    wardEvents?: boolean
    skillLevelUpEvents?: boolean
  }

  export type PlayerCountOutputTypeGetPayload<
    S extends boolean | null | undefined | PlayerCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? PlayerCountOutputType
    : S extends undefined
    ? never
    : S extends PlayerCountOutputTypeArgs
    ?'include' extends U
    ? PlayerCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof PlayerCountOutputType ? PlayerCountOutputType[P] : never
  } 
    : PlayerCountOutputType
  : PlayerCountOutputType




  // Custom InputTypes

  /**
   * PlayerCountOutputType without action
   */
  export type PlayerCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the PlayerCountOutputType
     * 
    **/
    select?: PlayerCountOutputTypeSelect | null
  }



  /**
   * Count Type PlayerItemCountOutputType
   */


  export type PlayerItemCountOutputType = {
    playerEndOfGameStat: number
  }

  export type PlayerItemCountOutputTypeSelect = {
    playerEndOfGameStat?: boolean
  }

  export type PlayerItemCountOutputTypeGetPayload<
    S extends boolean | null | undefined | PlayerItemCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? PlayerItemCountOutputType
    : S extends undefined
    ? never
    : S extends PlayerItemCountOutputTypeArgs
    ?'include' extends U
    ? PlayerItemCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof PlayerItemCountOutputType ? PlayerItemCountOutputType[P] : never
  } 
    : PlayerItemCountOutputType
  : PlayerItemCountOutputType




  // Custom InputTypes

  /**
   * PlayerItemCountOutputType without action
   */
  export type PlayerItemCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the PlayerItemCountOutputType
     * 
    **/
    select?: PlayerItemCountOutputTypeSelect | null
  }



  /**
   * Count Type PlayerItemEventCountOutputType
   */


  export type PlayerItemEventCountOutputType = {
    player: number
  }

  export type PlayerItemEventCountOutputTypeSelect = {
    player?: boolean
  }

  export type PlayerItemEventCountOutputTypeGetPayload<
    S extends boolean | null | undefined | PlayerItemEventCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? PlayerItemEventCountOutputType
    : S extends undefined
    ? never
    : S extends PlayerItemEventCountOutputTypeArgs
    ?'include' extends U
    ? PlayerItemEventCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof PlayerItemEventCountOutputType ? PlayerItemEventCountOutputType[P] : never
  } 
    : PlayerItemEventCountOutputType
  : PlayerItemEventCountOutputType




  // Custom InputTypes

  /**
   * PlayerItemEventCountOutputType without action
   */
  export type PlayerItemEventCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the PlayerItemEventCountOutputType
     * 
    **/
    select?: PlayerItemEventCountOutputTypeSelect | null
  }



  /**
   * Count Type PlayerKillCountOutputType
   */


  export type PlayerKillCountOutputType = {
    killer: number
    victim: number
  }

  export type PlayerKillCountOutputTypeSelect = {
    killer?: boolean
    victim?: boolean
  }

  export type PlayerKillCountOutputTypeGetPayload<
    S extends boolean | null | undefined | PlayerKillCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? PlayerKillCountOutputType
    : S extends undefined
    ? never
    : S extends PlayerKillCountOutputTypeArgs
    ?'include' extends U
    ? PlayerKillCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof PlayerKillCountOutputType ? PlayerKillCountOutputType[P] : never
  } 
    : PlayerKillCountOutputType
  : PlayerKillCountOutputType




  // Custom InputTypes

  /**
   * PlayerKillCountOutputType without action
   */
  export type PlayerKillCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the PlayerKillCountOutputType
     * 
    **/
    select?: PlayerKillCountOutputTypeSelect | null
  }



  /**
   * Count Type PlayerRuneCountOutputType
   */


  export type PlayerRuneCountOutputType = {
    runeStyle: number
  }

  export type PlayerRuneCountOutputTypeSelect = {
    runeStyle?: boolean
  }

  export type PlayerRuneCountOutputTypeGetPayload<
    S extends boolean | null | undefined | PlayerRuneCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? PlayerRuneCountOutputType
    : S extends undefined
    ? never
    : S extends PlayerRuneCountOutputTypeArgs
    ?'include' extends U
    ? PlayerRuneCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof PlayerRuneCountOutputType ? PlayerRuneCountOutputType[P] : never
  } 
    : PlayerRuneCountOutputType
  : PlayerRuneCountOutputType




  // Custom InputTypes

  /**
   * PlayerRuneCountOutputType without action
   */
  export type PlayerRuneCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the PlayerRuneCountOutputType
     * 
    **/
    select?: PlayerRuneCountOutputTypeSelect | null
  }



  /**
   * Count Type PlayerSkillLevelUpEventCountOutputType
   */


  export type PlayerSkillLevelUpEventCountOutputType = {
    player: number
  }

  export type PlayerSkillLevelUpEventCountOutputTypeSelect = {
    player?: boolean
  }

  export type PlayerSkillLevelUpEventCountOutputTypeGetPayload<
    S extends boolean | null | undefined | PlayerSkillLevelUpEventCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? PlayerSkillLevelUpEventCountOutputType
    : S extends undefined
    ? never
    : S extends PlayerSkillLevelUpEventCountOutputTypeArgs
    ?'include' extends U
    ? PlayerSkillLevelUpEventCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof PlayerSkillLevelUpEventCountOutputType ? PlayerSkillLevelUpEventCountOutputType[P] : never
  } 
    : PlayerSkillLevelUpEventCountOutputType
  : PlayerSkillLevelUpEventCountOutputType




  // Custom InputTypes

  /**
   * PlayerSkillLevelUpEventCountOutputType without action
   */
  export type PlayerSkillLevelUpEventCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the PlayerSkillLevelUpEventCountOutputType
     * 
    **/
    select?: PlayerSkillLevelUpEventCountOutputTypeSelect | null
  }



  /**
   * Count Type PlayerSnapshotCountOutputType
   */


  export type PlayerSnapshotCountOutputType = {
    position: number
    player: number
  }

  export type PlayerSnapshotCountOutputTypeSelect = {
    position?: boolean
    player?: boolean
  }

  export type PlayerSnapshotCountOutputTypeGetPayload<
    S extends boolean | null | undefined | PlayerSnapshotCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? PlayerSnapshotCountOutputType
    : S extends undefined
    ? never
    : S extends PlayerSnapshotCountOutputTypeArgs
    ?'include' extends U
    ? PlayerSnapshotCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof PlayerSnapshotCountOutputType ? PlayerSnapshotCountOutputType[P] : never
  } 
    : PlayerSnapshotCountOutputType
  : PlayerSnapshotCountOutputType




  // Custom InputTypes

  /**
   * PlayerSnapshotCountOutputType without action
   */
  export type PlayerSnapshotCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the PlayerSnapshotCountOutputType
     * 
    **/
    select?: PlayerSnapshotCountOutputTypeSelect | null
  }



  /**
   * Count Type PlayerWardEventCountOutputType
   */


  export type PlayerWardEventCountOutputType = {
    player: number
  }

  export type PlayerWardEventCountOutputTypeSelect = {
    player?: boolean
  }

  export type PlayerWardEventCountOutputTypeGetPayload<
    S extends boolean | null | undefined | PlayerWardEventCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? PlayerWardEventCountOutputType
    : S extends undefined
    ? never
    : S extends PlayerWardEventCountOutputTypeArgs
    ?'include' extends U
    ? PlayerWardEventCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof PlayerWardEventCountOutputType ? PlayerWardEventCountOutputType[P] : never
  } 
    : PlayerWardEventCountOutputType
  : PlayerWardEventCountOutputType




  // Custom InputTypes

  /**
   * PlayerWardEventCountOutputType without action
   */
  export type PlayerWardEventCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the PlayerWardEventCountOutputType
     * 
    **/
    select?: PlayerWardEventCountOutputTypeSelect | null
  }



  /**
   * Count Type PositionCountOutputType
   */


  export type PositionCountOutputType = {
    event: number
    playerSnapshot: number
  }

  export type PositionCountOutputTypeSelect = {
    event?: boolean
    playerSnapshot?: boolean
  }

  export type PositionCountOutputTypeGetPayload<
    S extends boolean | null | undefined | PositionCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? PositionCountOutputType
    : S extends undefined
    ? never
    : S extends PositionCountOutputTypeArgs
    ?'include' extends U
    ? PositionCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof PositionCountOutputType ? PositionCountOutputType[P] : never
  } 
    : PositionCountOutputType
  : PositionCountOutputType




  // Custom InputTypes

  /**
   * PositionCountOutputType without action
   */
  export type PositionCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the PositionCountOutputType
     * 
    **/
    select?: PositionCountOutputTypeSelect | null
  }



  /**
   * Count Type ProfileCountOutputType
   */


  export type ProfileCountOutputType = {
    activity: number
    championWinrate: number
    duos: number
  }

  export type ProfileCountOutputTypeSelect = {
    activity?: boolean
    championWinrate?: boolean
    duos?: boolean
  }

  export type ProfileCountOutputTypeGetPayload<
    S extends boolean | null | undefined | ProfileCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? ProfileCountOutputType
    : S extends undefined
    ? never
    : S extends ProfileCountOutputTypeArgs
    ?'include' extends U
    ? ProfileCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof ProfileCountOutputType ? ProfileCountOutputType[P] : never
  } 
    : ProfileCountOutputType
  : ProfileCountOutputType




  // Custom InputTypes

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ProfileCountOutputType
     * 
    **/
    select?: ProfileCountOutputTypeSelect | null
  }



  /**
   * Count Type SourceCountOutputType
   */


  export type SourceCountOutputType = {
    game: number
  }

  export type SourceCountOutputTypeSelect = {
    game?: boolean
  }

  export type SourceCountOutputTypeGetPayload<
    S extends boolean | null | undefined | SourceCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? SourceCountOutputType
    : S extends undefined
    ? never
    : S extends SourceCountOutputTypeArgs
    ?'include' extends U
    ? SourceCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof SourceCountOutputType ? SourceCountOutputType[P] : never
  } 
    : SourceCountOutputType
  : SourceCountOutputType




  // Custom InputTypes

  /**
   * SourceCountOutputType without action
   */
  export type SourceCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the SourceCountOutputType
     * 
    **/
    select?: SourceCountOutputTypeSelect | null
  }



  /**
   * Count Type TeamCountOutputType
   */


  export type TeamCountOutputType = {
    pickBan: number
    players: number
    objectives: number
    from_Game_blueTeam: number
    from_Game_redTeam: number
  }

  export type TeamCountOutputTypeSelect = {
    pickBan?: boolean
    players?: boolean
    objectives?: boolean
    from_Game_blueTeam?: boolean
    from_Game_redTeam?: boolean
  }

  export type TeamCountOutputTypeGetPayload<
    S extends boolean | null | undefined | TeamCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? TeamCountOutputType
    : S extends undefined
    ? never
    : S extends TeamCountOutputTypeArgs
    ?'include' extends U
    ? TeamCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof TeamCountOutputType ? TeamCountOutputType[P] : never
  } 
    : TeamCountOutputType
  : TeamCountOutputType




  // Custom InputTypes

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the TeamCountOutputType
     * 
    **/
    select?: TeamCountOutputTypeSelect | null
  }



  /**
   * Count Type TeamBuildingKillCountOutputType
   */


  export type TeamBuildingKillCountOutputType = {
    killer: number
  }

  export type TeamBuildingKillCountOutputTypeSelect = {
    killer?: boolean
  }

  export type TeamBuildingKillCountOutputTypeGetPayload<
    S extends boolean | null | undefined | TeamBuildingKillCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? TeamBuildingKillCountOutputType
    : S extends undefined
    ? never
    : S extends TeamBuildingKillCountOutputTypeArgs
    ?'include' extends U
    ? TeamBuildingKillCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof TeamBuildingKillCountOutputType ? TeamBuildingKillCountOutputType[P] : never
  } 
    : TeamBuildingKillCountOutputType
  : TeamBuildingKillCountOutputType




  // Custom InputTypes

  /**
   * TeamBuildingKillCountOutputType without action
   */
  export type TeamBuildingKillCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the TeamBuildingKillCountOutputType
     * 
    **/
    select?: TeamBuildingKillCountOutputTypeSelect | null
  }



  /**
   * Count Type TeamMonsterKillCountOutputType
   */


  export type TeamMonsterKillCountOutputType = {
    killer: number
  }

  export type TeamMonsterKillCountOutputTypeSelect = {
    killer?: boolean
  }

  export type TeamMonsterKillCountOutputTypeGetPayload<
    S extends boolean | null | undefined | TeamMonsterKillCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? TeamMonsterKillCountOutputType
    : S extends undefined
    ? never
    : S extends TeamMonsterKillCountOutputTypeArgs
    ?'include' extends U
    ? TeamMonsterKillCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof TeamMonsterKillCountOutputType ? TeamMonsterKillCountOutputType[P] : never
  } 
    : TeamMonsterKillCountOutputType
  : TeamMonsterKillCountOutputType




  // Custom InputTypes

  /**
   * TeamMonsterKillCountOutputType without action
   */
  export type TeamMonsterKillCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the TeamMonsterKillCountOutputType
     * 
    **/
    select?: TeamMonsterKillCountOutputTypeSelect | null
  }



  /**
   * Count Type RuneStyleCountOutputType
   */


  export type RuneStyleCountOutputType = {
    selection: number
  }

  export type RuneStyleCountOutputTypeSelect = {
    selection?: boolean
  }

  export type RuneStyleCountOutputTypeGetPayload<
    S extends boolean | null | undefined | RuneStyleCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? RuneStyleCountOutputType
    : S extends undefined
    ? never
    : S extends RuneStyleCountOutputTypeArgs
    ?'include' extends U
    ? RuneStyleCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof RuneStyleCountOutputType ? RuneStyleCountOutputType[P] : never
  } 
    : RuneStyleCountOutputType
  : RuneStyleCountOutputType




  // Custom InputTypes

  /**
   * RuneStyleCountOutputType without action
   */
  export type RuneStyleCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the RuneStyleCountOutputType
     * 
    **/
    select?: RuneStyleCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model Activity
   */


  export type AggregateActivity = {
    _count: ActivityCountAggregateOutputType | null
    _avg: ActivityAvgAggregateOutputType | null
    _sum: ActivitySumAggregateOutputType | null
    _min: ActivityMinAggregateOutputType | null
    _max: ActivityMaxAggregateOutputType | null
  }

  export type ActivityAvgAggregateOutputType = {
    month: number | null
    year: number | null
    day: number | null
    gamesPlayed: number | null
  }

  export type ActivitySumAggregateOutputType = {
    month: number | null
    year: number | null
    day: number | null
    gamesPlayed: number | null
  }

  export type ActivityMinAggregateOutputType = {
    id: string | null
    profileId: string | null
    month: number | null
    year: number | null
    day: number | null
    gamesPlayed: number | null
  }

  export type ActivityMaxAggregateOutputType = {
    id: string | null
    profileId: string | null
    month: number | null
    year: number | null
    day: number | null
    gamesPlayed: number | null
  }

  export type ActivityCountAggregateOutputType = {
    id: number
    profileId: number
    month: number
    year: number
    day: number
    gamesPlayed: number
    _all: number
  }


  export type ActivityAvgAggregateInputType = {
    month?: true
    year?: true
    day?: true
    gamesPlayed?: true
  }

  export type ActivitySumAggregateInputType = {
    month?: true
    year?: true
    day?: true
    gamesPlayed?: true
  }

  export type ActivityMinAggregateInputType = {
    id?: true
    profileId?: true
    month?: true
    year?: true
    day?: true
    gamesPlayed?: true
  }

  export type ActivityMaxAggregateInputType = {
    id?: true
    profileId?: true
    month?: true
    year?: true
    day?: true
    gamesPlayed?: true
  }

  export type ActivityCountAggregateInputType = {
    id?: true
    profileId?: true
    month?: true
    year?: true
    day?: true
    gamesPlayed?: true
    _all?: true
  }

  export type ActivityAggregateArgs = {
    /**
     * Filter which Activity to aggregate.
     * 
    **/
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     * 
    **/
    orderBy?: Enumerable<ActivityOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Activities
    **/
    _count?: true | ActivityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ActivityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ActivitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActivityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActivityMaxAggregateInputType
  }

  export type GetActivityAggregateType<T extends ActivityAggregateArgs> = {
        [P in keyof T & keyof AggregateActivity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActivity[P]>
      : GetScalarType<T[P], AggregateActivity[P]>
  }




  export type ActivityGroupByArgs = {
    where?: ActivityWhereInput
    orderBy?: Enumerable<ActivityOrderByWithAggregationInput>
    by: Array<ActivityScalarFieldEnum>
    having?: ActivityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActivityCountAggregateInputType | true
    _avg?: ActivityAvgAggregateInputType
    _sum?: ActivitySumAggregateInputType
    _min?: ActivityMinAggregateInputType
    _max?: ActivityMaxAggregateInputType
  }


  export type ActivityGroupByOutputType = {
    id: string
    profileId: string | null
    month: number | null
    year: number | null
    day: number | null
    gamesPlayed: number | null
    _count: ActivityCountAggregateOutputType | null
    _avg: ActivityAvgAggregateOutputType | null
    _sum: ActivitySumAggregateOutputType | null
    _min: ActivityMinAggregateOutputType | null
    _max: ActivityMaxAggregateOutputType | null
  }

  type GetActivityGroupByPayload<T extends ActivityGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ActivityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActivityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActivityGroupByOutputType[P]>
            : GetScalarType<T[P], ActivityGroupByOutputType[P]>
        }
      >
    >


  export type ActivitySelect = {
    id?: boolean
    profile?: boolean | ProfileArgs
    profileId?: boolean
    month?: boolean
    year?: boolean
    day?: boolean
    gamesPlayed?: boolean
  }

  export type ActivityInclude = {
    profile?: boolean | ProfileArgs
  }

  export type ActivityGetPayload<
    S extends boolean | null | undefined | ActivityArgs,
    U = keyof S
      > = S extends true
        ? Activity
    : S extends undefined
    ? never
    : S extends ActivityArgs | ActivityFindManyArgs
    ?'include' extends U
    ? Activity  & {
    [P in TrueKeys<S['include']>]:
        P extends 'profile' ? ProfileGetPayload<S['include'][P]> | null :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'profile' ? ProfileGetPayload<S['select'][P]> | null :  P extends keyof Activity ? Activity[P] : never
  } 
    : Activity
  : Activity


  type ActivityCountArgs = Merge<
    Omit<ActivityFindManyArgs, 'select' | 'include'> & {
      select?: ActivityCountAggregateInputType | true
    }
  >

  export interface ActivityDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Activity that matches the filter.
     * @param {ActivityFindUniqueArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ActivityFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ActivityFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Activity'> extends True ? CheckSelect<T, Prisma__ActivityClient<Activity>, Prisma__ActivityClient<ActivityGetPayload<T>>> : CheckSelect<T, Prisma__ActivityClient<Activity | null >, Prisma__ActivityClient<ActivityGetPayload<T> | null >>

    /**
     * Find the first Activity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityFindFirstArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ActivityFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ActivityFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Activity'> extends True ? CheckSelect<T, Prisma__ActivityClient<Activity>, Prisma__ActivityClient<ActivityGetPayload<T>>> : CheckSelect<T, Prisma__ActivityClient<Activity | null >, Prisma__ActivityClient<ActivityGetPayload<T> | null >>

    /**
     * Find zero or more Activities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Activities
     * const activities = await prisma.activity.findMany()
     * 
     * // Get first 10 Activities
     * const activities = await prisma.activity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const activityWithIdOnly = await prisma.activity.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ActivityFindManyArgs>(
      args?: SelectSubset<T, ActivityFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Activity>>, PrismaPromise<Array<ActivityGetPayload<T>>>>

    /**
     * Create a Activity.
     * @param {ActivityCreateArgs} args - Arguments to create a Activity.
     * @example
     * // Create one Activity
     * const Activity = await prisma.activity.create({
     *   data: {
     *     // ... data to create a Activity
     *   }
     * })
     * 
    **/
    create<T extends ActivityCreateArgs>(
      args: SelectSubset<T, ActivityCreateArgs>
    ): CheckSelect<T, Prisma__ActivityClient<Activity>, Prisma__ActivityClient<ActivityGetPayload<T>>>

    /**
     * Create many Activities.
     *     @param {ActivityCreateManyArgs} args - Arguments to create many Activities.
     *     @example
     *     // Create many Activities
     *     const activity = await prisma.activity.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ActivityCreateManyArgs>(
      args?: SelectSubset<T, ActivityCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Activity.
     * @param {ActivityDeleteArgs} args - Arguments to delete one Activity.
     * @example
     * // Delete one Activity
     * const Activity = await prisma.activity.delete({
     *   where: {
     *     // ... filter to delete one Activity
     *   }
     * })
     * 
    **/
    delete<T extends ActivityDeleteArgs>(
      args: SelectSubset<T, ActivityDeleteArgs>
    ): CheckSelect<T, Prisma__ActivityClient<Activity>, Prisma__ActivityClient<ActivityGetPayload<T>>>

    /**
     * Update one Activity.
     * @param {ActivityUpdateArgs} args - Arguments to update one Activity.
     * @example
     * // Update one Activity
     * const activity = await prisma.activity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ActivityUpdateArgs>(
      args: SelectSubset<T, ActivityUpdateArgs>
    ): CheckSelect<T, Prisma__ActivityClient<Activity>, Prisma__ActivityClient<ActivityGetPayload<T>>>

    /**
     * Delete zero or more Activities.
     * @param {ActivityDeleteManyArgs} args - Arguments to filter Activities to delete.
     * @example
     * // Delete a few Activities
     * const { count } = await prisma.activity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ActivityDeleteManyArgs>(
      args?: SelectSubset<T, ActivityDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Activities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Activities
     * const activity = await prisma.activity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ActivityUpdateManyArgs>(
      args: SelectSubset<T, ActivityUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Activity.
     * @param {ActivityUpsertArgs} args - Arguments to update or create a Activity.
     * @example
     * // Update or create a Activity
     * const activity = await prisma.activity.upsert({
     *   create: {
     *     // ... data to create a Activity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Activity we want to update
     *   }
     * })
    **/
    upsert<T extends ActivityUpsertArgs>(
      args: SelectSubset<T, ActivityUpsertArgs>
    ): CheckSelect<T, Prisma__ActivityClient<Activity>, Prisma__ActivityClient<ActivityGetPayload<T>>>

    /**
     * Count the number of Activities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityCountArgs} args - Arguments to filter Activities to count.
     * @example
     * // Count the number of Activities
     * const count = await prisma.activity.count({
     *   where: {
     *     // ... the filter for the Activities we want to count
     *   }
     * })
    **/
    count<T extends ActivityCountArgs>(
      args?: Subset<T, ActivityCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActivityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Activity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActivityAggregateArgs>(args: Subset<T, ActivityAggregateArgs>): PrismaPromise<GetActivityAggregateType<T>>

    /**
     * Group by Activity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActivityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActivityGroupByArgs['orderBy'] }
        : { orderBy?: ActivityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActivityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActivityGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Activity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ActivityClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    profile<T extends ProfileArgs = {}>(args?: Subset<T, ProfileArgs>): CheckSelect<T, Prisma__ProfileClient<Profile | null >, Prisma__ProfileClient<ProfileGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Activity findUnique
   */
  export type ActivityFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Activity
     * 
    **/
    select?: ActivitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ActivityInclude | null
    /**
     * Throw an Error if a Activity can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Activity to fetch.
     * 
    **/
    where: ActivityWhereUniqueInput
  }


  /**
   * Activity findFirst
   */
  export type ActivityFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Activity
     * 
    **/
    select?: ActivitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ActivityInclude | null
    /**
     * Throw an Error if a Activity can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Activity to fetch.
     * 
    **/
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     * 
    **/
    orderBy?: Enumerable<ActivityOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Activities.
     * 
    **/
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Activities.
     * 
    **/
    distinct?: Enumerable<ActivityScalarFieldEnum>
  }


  /**
   * Activity findMany
   */
  export type ActivityFindManyArgs = {
    /**
     * Select specific fields to fetch from the Activity
     * 
    **/
    select?: ActivitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ActivityInclude | null
    /**
     * Filter, which Activities to fetch.
     * 
    **/
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     * 
    **/
    orderBy?: Enumerable<ActivityOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Activities.
     * 
    **/
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ActivityScalarFieldEnum>
  }


  /**
   * Activity create
   */
  export type ActivityCreateArgs = {
    /**
     * Select specific fields to fetch from the Activity
     * 
    **/
    select?: ActivitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ActivityInclude | null
    /**
     * The data needed to create a Activity.
     * 
    **/
    data: XOR<ActivityCreateInput, ActivityUncheckedCreateInput>
  }


  /**
   * Activity createMany
   */
  export type ActivityCreateManyArgs = {
    /**
     * The data used to create many Activities.
     * 
    **/
    data: Enumerable<ActivityCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Activity update
   */
  export type ActivityUpdateArgs = {
    /**
     * Select specific fields to fetch from the Activity
     * 
    **/
    select?: ActivitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ActivityInclude | null
    /**
     * The data needed to update a Activity.
     * 
    **/
    data: XOR<ActivityUpdateInput, ActivityUncheckedUpdateInput>
    /**
     * Choose, which Activity to update.
     * 
    **/
    where: ActivityWhereUniqueInput
  }


  /**
   * Activity updateMany
   */
  export type ActivityUpdateManyArgs = {
    /**
     * The data used to update Activities.
     * 
    **/
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyInput>
    /**
     * Filter which Activities to update
     * 
    **/
    where?: ActivityWhereInput
  }


  /**
   * Activity upsert
   */
  export type ActivityUpsertArgs = {
    /**
     * Select specific fields to fetch from the Activity
     * 
    **/
    select?: ActivitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ActivityInclude | null
    /**
     * The filter to search for the Activity to update in case it exists.
     * 
    **/
    where: ActivityWhereUniqueInput
    /**
     * In case the Activity found by the `where` argument doesn't exist, create a new Activity with this data.
     * 
    **/
    create: XOR<ActivityCreateInput, ActivityUncheckedCreateInput>
    /**
     * In case the Activity was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ActivityUpdateInput, ActivityUncheckedUpdateInput>
  }


  /**
   * Activity delete
   */
  export type ActivityDeleteArgs = {
    /**
     * Select specific fields to fetch from the Activity
     * 
    **/
    select?: ActivitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ActivityInclude | null
    /**
     * Filter which Activity to delete.
     * 
    **/
    where: ActivityWhereUniqueInput
  }


  /**
   * Activity deleteMany
   */
  export type ActivityDeleteManyArgs = {
    /**
     * Filter which Activities to delete
     * 
    **/
    where?: ActivityWhereInput
  }


  /**
   * Activity without action
   */
  export type ActivityArgs = {
    /**
     * Select specific fields to fetch from the Activity
     * 
    **/
    select?: ActivitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ActivityInclude | null
  }



  /**
   * Model ChampionWinrate
   */


  export type AggregateChampionWinrate = {
    _count: ChampionWinrateCountAggregateOutputType | null
    _avg: ChampionWinrateAvgAggregateOutputType | null
    _sum: ChampionWinrateSumAggregateOutputType | null
    _min: ChampionWinrateMinAggregateOutputType | null
    _max: ChampionWinrateMaxAggregateOutputType | null
  }

  export type ChampionWinrateAvgAggregateOutputType = {
    wins: number | null
    games: number | null
    spell1Casts: number | null
    spell2Casts: number | null
    spell3Casts: number | null
    spell4Casts: number | null
  }

  export type ChampionWinrateSumAggregateOutputType = {
    wins: number | null
    games: number | null
    spell1Casts: number | null
    spell2Casts: number | null
    spell3Casts: number | null
    spell4Casts: number | null
  }

  export type ChampionWinrateMinAggregateOutputType = {
    id: string | null
    profileId: string | null
    champion: string | null
    wins: number | null
    games: number | null
    spell1Casts: number | null
    spell2Casts: number | null
    spell3Casts: number | null
    spell4Casts: number | null
  }

  export type ChampionWinrateMaxAggregateOutputType = {
    id: string | null
    profileId: string | null
    champion: string | null
    wins: number | null
    games: number | null
    spell1Casts: number | null
    spell2Casts: number | null
    spell3Casts: number | null
    spell4Casts: number | null
  }

  export type ChampionWinrateCountAggregateOutputType = {
    id: number
    profileId: number
    champion: number
    wins: number
    games: number
    spell1Casts: number
    spell2Casts: number
    spell3Casts: number
    spell4Casts: number
    _all: number
  }


  export type ChampionWinrateAvgAggregateInputType = {
    wins?: true
    games?: true
    spell1Casts?: true
    spell2Casts?: true
    spell3Casts?: true
    spell4Casts?: true
  }

  export type ChampionWinrateSumAggregateInputType = {
    wins?: true
    games?: true
    spell1Casts?: true
    spell2Casts?: true
    spell3Casts?: true
    spell4Casts?: true
  }

  export type ChampionWinrateMinAggregateInputType = {
    id?: true
    profileId?: true
    champion?: true
    wins?: true
    games?: true
    spell1Casts?: true
    spell2Casts?: true
    spell3Casts?: true
    spell4Casts?: true
  }

  export type ChampionWinrateMaxAggregateInputType = {
    id?: true
    profileId?: true
    champion?: true
    wins?: true
    games?: true
    spell1Casts?: true
    spell2Casts?: true
    spell3Casts?: true
    spell4Casts?: true
  }

  export type ChampionWinrateCountAggregateInputType = {
    id?: true
    profileId?: true
    champion?: true
    wins?: true
    games?: true
    spell1Casts?: true
    spell2Casts?: true
    spell3Casts?: true
    spell4Casts?: true
    _all?: true
  }

  export type ChampionWinrateAggregateArgs = {
    /**
     * Filter which ChampionWinrate to aggregate.
     * 
    **/
    where?: ChampionWinrateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChampionWinrates to fetch.
     * 
    **/
    orderBy?: Enumerable<ChampionWinrateOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ChampionWinrateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChampionWinrates from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChampionWinrates.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChampionWinrates
    **/
    _count?: true | ChampionWinrateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChampionWinrateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChampionWinrateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChampionWinrateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChampionWinrateMaxAggregateInputType
  }

  export type GetChampionWinrateAggregateType<T extends ChampionWinrateAggregateArgs> = {
        [P in keyof T & keyof AggregateChampionWinrate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChampionWinrate[P]>
      : GetScalarType<T[P], AggregateChampionWinrate[P]>
  }




  export type ChampionWinrateGroupByArgs = {
    where?: ChampionWinrateWhereInput
    orderBy?: Enumerable<ChampionWinrateOrderByWithAggregationInput>
    by: Array<ChampionWinrateScalarFieldEnum>
    having?: ChampionWinrateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChampionWinrateCountAggregateInputType | true
    _avg?: ChampionWinrateAvgAggregateInputType
    _sum?: ChampionWinrateSumAggregateInputType
    _min?: ChampionWinrateMinAggregateInputType
    _max?: ChampionWinrateMaxAggregateInputType
  }


  export type ChampionWinrateGroupByOutputType = {
    id: string
    profileId: string | null
    champion: string
    wins: number | null
    games: number | null
    spell1Casts: number | null
    spell2Casts: number | null
    spell3Casts: number | null
    spell4Casts: number | null
    _count: ChampionWinrateCountAggregateOutputType | null
    _avg: ChampionWinrateAvgAggregateOutputType | null
    _sum: ChampionWinrateSumAggregateOutputType | null
    _min: ChampionWinrateMinAggregateOutputType | null
    _max: ChampionWinrateMaxAggregateOutputType | null
  }

  type GetChampionWinrateGroupByPayload<T extends ChampionWinrateGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ChampionWinrateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChampionWinrateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChampionWinrateGroupByOutputType[P]>
            : GetScalarType<T[P], ChampionWinrateGroupByOutputType[P]>
        }
      >
    >


  export type ChampionWinrateSelect = {
    id?: boolean
    profile?: boolean | ProfileArgs
    profileId?: boolean
    champion?: boolean
    wins?: boolean
    games?: boolean
    spell1Casts?: boolean
    spell2Casts?: boolean
    spell3Casts?: boolean
    spell4Casts?: boolean
  }

  export type ChampionWinrateInclude = {
    profile?: boolean | ProfileArgs
  }

  export type ChampionWinrateGetPayload<
    S extends boolean | null | undefined | ChampionWinrateArgs,
    U = keyof S
      > = S extends true
        ? ChampionWinrate
    : S extends undefined
    ? never
    : S extends ChampionWinrateArgs | ChampionWinrateFindManyArgs
    ?'include' extends U
    ? ChampionWinrate  & {
    [P in TrueKeys<S['include']>]:
        P extends 'profile' ? ProfileGetPayload<S['include'][P]> | null :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'profile' ? ProfileGetPayload<S['select'][P]> | null :  P extends keyof ChampionWinrate ? ChampionWinrate[P] : never
  } 
    : ChampionWinrate
  : ChampionWinrate


  type ChampionWinrateCountArgs = Merge<
    Omit<ChampionWinrateFindManyArgs, 'select' | 'include'> & {
      select?: ChampionWinrateCountAggregateInputType | true
    }
  >

  export interface ChampionWinrateDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one ChampionWinrate that matches the filter.
     * @param {ChampionWinrateFindUniqueArgs} args - Arguments to find a ChampionWinrate
     * @example
     * // Get one ChampionWinrate
     * const championWinrate = await prisma.championWinrate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ChampionWinrateFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ChampionWinrateFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ChampionWinrate'> extends True ? CheckSelect<T, Prisma__ChampionWinrateClient<ChampionWinrate>, Prisma__ChampionWinrateClient<ChampionWinrateGetPayload<T>>> : CheckSelect<T, Prisma__ChampionWinrateClient<ChampionWinrate | null >, Prisma__ChampionWinrateClient<ChampionWinrateGetPayload<T> | null >>

    /**
     * Find the first ChampionWinrate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChampionWinrateFindFirstArgs} args - Arguments to find a ChampionWinrate
     * @example
     * // Get one ChampionWinrate
     * const championWinrate = await prisma.championWinrate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ChampionWinrateFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ChampionWinrateFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ChampionWinrate'> extends True ? CheckSelect<T, Prisma__ChampionWinrateClient<ChampionWinrate>, Prisma__ChampionWinrateClient<ChampionWinrateGetPayload<T>>> : CheckSelect<T, Prisma__ChampionWinrateClient<ChampionWinrate | null >, Prisma__ChampionWinrateClient<ChampionWinrateGetPayload<T> | null >>

    /**
     * Find zero or more ChampionWinrates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChampionWinrateFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChampionWinrates
     * const championWinrates = await prisma.championWinrate.findMany()
     * 
     * // Get first 10 ChampionWinrates
     * const championWinrates = await prisma.championWinrate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const championWinrateWithIdOnly = await prisma.championWinrate.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ChampionWinrateFindManyArgs>(
      args?: SelectSubset<T, ChampionWinrateFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<ChampionWinrate>>, PrismaPromise<Array<ChampionWinrateGetPayload<T>>>>

    /**
     * Create a ChampionWinrate.
     * @param {ChampionWinrateCreateArgs} args - Arguments to create a ChampionWinrate.
     * @example
     * // Create one ChampionWinrate
     * const ChampionWinrate = await prisma.championWinrate.create({
     *   data: {
     *     // ... data to create a ChampionWinrate
     *   }
     * })
     * 
    **/
    create<T extends ChampionWinrateCreateArgs>(
      args: SelectSubset<T, ChampionWinrateCreateArgs>
    ): CheckSelect<T, Prisma__ChampionWinrateClient<ChampionWinrate>, Prisma__ChampionWinrateClient<ChampionWinrateGetPayload<T>>>

    /**
     * Create many ChampionWinrates.
     *     @param {ChampionWinrateCreateManyArgs} args - Arguments to create many ChampionWinrates.
     *     @example
     *     // Create many ChampionWinrates
     *     const championWinrate = await prisma.championWinrate.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ChampionWinrateCreateManyArgs>(
      args?: SelectSubset<T, ChampionWinrateCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a ChampionWinrate.
     * @param {ChampionWinrateDeleteArgs} args - Arguments to delete one ChampionWinrate.
     * @example
     * // Delete one ChampionWinrate
     * const ChampionWinrate = await prisma.championWinrate.delete({
     *   where: {
     *     // ... filter to delete one ChampionWinrate
     *   }
     * })
     * 
    **/
    delete<T extends ChampionWinrateDeleteArgs>(
      args: SelectSubset<T, ChampionWinrateDeleteArgs>
    ): CheckSelect<T, Prisma__ChampionWinrateClient<ChampionWinrate>, Prisma__ChampionWinrateClient<ChampionWinrateGetPayload<T>>>

    /**
     * Update one ChampionWinrate.
     * @param {ChampionWinrateUpdateArgs} args - Arguments to update one ChampionWinrate.
     * @example
     * // Update one ChampionWinrate
     * const championWinrate = await prisma.championWinrate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ChampionWinrateUpdateArgs>(
      args: SelectSubset<T, ChampionWinrateUpdateArgs>
    ): CheckSelect<T, Prisma__ChampionWinrateClient<ChampionWinrate>, Prisma__ChampionWinrateClient<ChampionWinrateGetPayload<T>>>

    /**
     * Delete zero or more ChampionWinrates.
     * @param {ChampionWinrateDeleteManyArgs} args - Arguments to filter ChampionWinrates to delete.
     * @example
     * // Delete a few ChampionWinrates
     * const { count } = await prisma.championWinrate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ChampionWinrateDeleteManyArgs>(
      args?: SelectSubset<T, ChampionWinrateDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChampionWinrates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChampionWinrateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChampionWinrates
     * const championWinrate = await prisma.championWinrate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ChampionWinrateUpdateManyArgs>(
      args: SelectSubset<T, ChampionWinrateUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ChampionWinrate.
     * @param {ChampionWinrateUpsertArgs} args - Arguments to update or create a ChampionWinrate.
     * @example
     * // Update or create a ChampionWinrate
     * const championWinrate = await prisma.championWinrate.upsert({
     *   create: {
     *     // ... data to create a ChampionWinrate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChampionWinrate we want to update
     *   }
     * })
    **/
    upsert<T extends ChampionWinrateUpsertArgs>(
      args: SelectSubset<T, ChampionWinrateUpsertArgs>
    ): CheckSelect<T, Prisma__ChampionWinrateClient<ChampionWinrate>, Prisma__ChampionWinrateClient<ChampionWinrateGetPayload<T>>>

    /**
     * Count the number of ChampionWinrates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChampionWinrateCountArgs} args - Arguments to filter ChampionWinrates to count.
     * @example
     * // Count the number of ChampionWinrates
     * const count = await prisma.championWinrate.count({
     *   where: {
     *     // ... the filter for the ChampionWinrates we want to count
     *   }
     * })
    **/
    count<T extends ChampionWinrateCountArgs>(
      args?: Subset<T, ChampionWinrateCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChampionWinrateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChampionWinrate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChampionWinrateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChampionWinrateAggregateArgs>(args: Subset<T, ChampionWinrateAggregateArgs>): PrismaPromise<GetChampionWinrateAggregateType<T>>

    /**
     * Group by ChampionWinrate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChampionWinrateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChampionWinrateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChampionWinrateGroupByArgs['orderBy'] }
        : { orderBy?: ChampionWinrateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChampionWinrateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChampionWinrateGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChampionWinrate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ChampionWinrateClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    profile<T extends ProfileArgs = {}>(args?: Subset<T, ProfileArgs>): CheckSelect<T, Prisma__ProfileClient<Profile | null >, Prisma__ProfileClient<ProfileGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * ChampionWinrate findUnique
   */
  export type ChampionWinrateFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the ChampionWinrate
     * 
    **/
    select?: ChampionWinrateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ChampionWinrateInclude | null
    /**
     * Throw an Error if a ChampionWinrate can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ChampionWinrate to fetch.
     * 
    **/
    where: ChampionWinrateWhereUniqueInput
  }


  /**
   * ChampionWinrate findFirst
   */
  export type ChampionWinrateFindFirstArgs = {
    /**
     * Select specific fields to fetch from the ChampionWinrate
     * 
    **/
    select?: ChampionWinrateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ChampionWinrateInclude | null
    /**
     * Throw an Error if a ChampionWinrate can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ChampionWinrate to fetch.
     * 
    **/
    where?: ChampionWinrateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChampionWinrates to fetch.
     * 
    **/
    orderBy?: Enumerable<ChampionWinrateOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChampionWinrates.
     * 
    **/
    cursor?: ChampionWinrateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChampionWinrates from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChampionWinrates.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChampionWinrates.
     * 
    **/
    distinct?: Enumerable<ChampionWinrateScalarFieldEnum>
  }


  /**
   * ChampionWinrate findMany
   */
  export type ChampionWinrateFindManyArgs = {
    /**
     * Select specific fields to fetch from the ChampionWinrate
     * 
    **/
    select?: ChampionWinrateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ChampionWinrateInclude | null
    /**
     * Filter, which ChampionWinrates to fetch.
     * 
    **/
    where?: ChampionWinrateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChampionWinrates to fetch.
     * 
    **/
    orderBy?: Enumerable<ChampionWinrateOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChampionWinrates.
     * 
    **/
    cursor?: ChampionWinrateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChampionWinrates from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChampionWinrates.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ChampionWinrateScalarFieldEnum>
  }


  /**
   * ChampionWinrate create
   */
  export type ChampionWinrateCreateArgs = {
    /**
     * Select specific fields to fetch from the ChampionWinrate
     * 
    **/
    select?: ChampionWinrateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ChampionWinrateInclude | null
    /**
     * The data needed to create a ChampionWinrate.
     * 
    **/
    data: XOR<ChampionWinrateCreateInput, ChampionWinrateUncheckedCreateInput>
  }


  /**
   * ChampionWinrate createMany
   */
  export type ChampionWinrateCreateManyArgs = {
    /**
     * The data used to create many ChampionWinrates.
     * 
    **/
    data: Enumerable<ChampionWinrateCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ChampionWinrate update
   */
  export type ChampionWinrateUpdateArgs = {
    /**
     * Select specific fields to fetch from the ChampionWinrate
     * 
    **/
    select?: ChampionWinrateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ChampionWinrateInclude | null
    /**
     * The data needed to update a ChampionWinrate.
     * 
    **/
    data: XOR<ChampionWinrateUpdateInput, ChampionWinrateUncheckedUpdateInput>
    /**
     * Choose, which ChampionWinrate to update.
     * 
    **/
    where: ChampionWinrateWhereUniqueInput
  }


  /**
   * ChampionWinrate updateMany
   */
  export type ChampionWinrateUpdateManyArgs = {
    /**
     * The data used to update ChampionWinrates.
     * 
    **/
    data: XOR<ChampionWinrateUpdateManyMutationInput, ChampionWinrateUncheckedUpdateManyInput>
    /**
     * Filter which ChampionWinrates to update
     * 
    **/
    where?: ChampionWinrateWhereInput
  }


  /**
   * ChampionWinrate upsert
   */
  export type ChampionWinrateUpsertArgs = {
    /**
     * Select specific fields to fetch from the ChampionWinrate
     * 
    **/
    select?: ChampionWinrateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ChampionWinrateInclude | null
    /**
     * The filter to search for the ChampionWinrate to update in case it exists.
     * 
    **/
    where: ChampionWinrateWhereUniqueInput
    /**
     * In case the ChampionWinrate found by the `where` argument doesn't exist, create a new ChampionWinrate with this data.
     * 
    **/
    create: XOR<ChampionWinrateCreateInput, ChampionWinrateUncheckedCreateInput>
    /**
     * In case the ChampionWinrate was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ChampionWinrateUpdateInput, ChampionWinrateUncheckedUpdateInput>
  }


  /**
   * ChampionWinrate delete
   */
  export type ChampionWinrateDeleteArgs = {
    /**
     * Select specific fields to fetch from the ChampionWinrate
     * 
    **/
    select?: ChampionWinrateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ChampionWinrateInclude | null
    /**
     * Filter which ChampionWinrate to delete.
     * 
    **/
    where: ChampionWinrateWhereUniqueInput
  }


  /**
   * ChampionWinrate deleteMany
   */
  export type ChampionWinrateDeleteManyArgs = {
    /**
     * Filter which ChampionWinrates to delete
     * 
    **/
    where?: ChampionWinrateWhereInput
  }


  /**
   * ChampionWinrate without action
   */
  export type ChampionWinrateArgs = {
    /**
     * Select specific fields to fetch from the ChampionWinrate
     * 
    **/
    select?: ChampionWinrateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ChampionWinrateInclude | null
  }



  /**
   * Model Duo
   */


  export type AggregateDuo = {
    _count: DuoCountAggregateOutputType | null
    _avg: DuoAvgAggregateOutputType | null
    _sum: DuoSumAggregateOutputType | null
    _min: DuoMinAggregateOutputType | null
    _max: DuoMaxAggregateOutputType | null
  }

  export type DuoAvgAggregateOutputType = {
    wins: number | null
    losses: number | null
  }

  export type DuoSumAggregateOutputType = {
    wins: number | null
    losses: number | null
  }

  export type DuoMinAggregateOutputType = {
    id: string | null
    profileId: string | null
    name: string | null
    wins: number | null
    losses: number | null
    winrate: string | null
  }

  export type DuoMaxAggregateOutputType = {
    id: string | null
    profileId: string | null
    name: string | null
    wins: number | null
    losses: number | null
    winrate: string | null
  }

  export type DuoCountAggregateOutputType = {
    id: number
    profileId: number
    name: number
    wins: number
    losses: number
    winrate: number
    _all: number
  }


  export type DuoAvgAggregateInputType = {
    wins?: true
    losses?: true
  }

  export type DuoSumAggregateInputType = {
    wins?: true
    losses?: true
  }

  export type DuoMinAggregateInputType = {
    id?: true
    profileId?: true
    name?: true
    wins?: true
    losses?: true
    winrate?: true
  }

  export type DuoMaxAggregateInputType = {
    id?: true
    profileId?: true
    name?: true
    wins?: true
    losses?: true
    winrate?: true
  }

  export type DuoCountAggregateInputType = {
    id?: true
    profileId?: true
    name?: true
    wins?: true
    losses?: true
    winrate?: true
    _all?: true
  }

  export type DuoAggregateArgs = {
    /**
     * Filter which Duo to aggregate.
     * 
    **/
    where?: DuoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Duos to fetch.
     * 
    **/
    orderBy?: Enumerable<DuoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: DuoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Duos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Duos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Duos
    **/
    _count?: true | DuoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DuoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DuoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DuoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DuoMaxAggregateInputType
  }

  export type GetDuoAggregateType<T extends DuoAggregateArgs> = {
        [P in keyof T & keyof AggregateDuo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDuo[P]>
      : GetScalarType<T[P], AggregateDuo[P]>
  }




  export type DuoGroupByArgs = {
    where?: DuoWhereInput
    orderBy?: Enumerable<DuoOrderByWithAggregationInput>
    by: Array<DuoScalarFieldEnum>
    having?: DuoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DuoCountAggregateInputType | true
    _avg?: DuoAvgAggregateInputType
    _sum?: DuoSumAggregateInputType
    _min?: DuoMinAggregateInputType
    _max?: DuoMaxAggregateInputType
  }


  export type DuoGroupByOutputType = {
    id: string
    profileId: string | null
    name: string
    wins: number | null
    losses: number | null
    winrate: string
    _count: DuoCountAggregateOutputType | null
    _avg: DuoAvgAggregateOutputType | null
    _sum: DuoSumAggregateOutputType | null
    _min: DuoMinAggregateOutputType | null
    _max: DuoMaxAggregateOutputType | null
  }

  type GetDuoGroupByPayload<T extends DuoGroupByArgs> = PrismaPromise<
    Array<
      PickArray<DuoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DuoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DuoGroupByOutputType[P]>
            : GetScalarType<T[P], DuoGroupByOutputType[P]>
        }
      >
    >


  export type DuoSelect = {
    id?: boolean
    profile?: boolean | ProfileArgs
    profileId?: boolean
    name?: boolean
    wins?: boolean
    losses?: boolean
    winrate?: boolean
  }

  export type DuoInclude = {
    profile?: boolean | ProfileArgs
  }

  export type DuoGetPayload<
    S extends boolean | null | undefined | DuoArgs,
    U = keyof S
      > = S extends true
        ? Duo
    : S extends undefined
    ? never
    : S extends DuoArgs | DuoFindManyArgs
    ?'include' extends U
    ? Duo  & {
    [P in TrueKeys<S['include']>]:
        P extends 'profile' ? ProfileGetPayload<S['include'][P]> | null :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'profile' ? ProfileGetPayload<S['select'][P]> | null :  P extends keyof Duo ? Duo[P] : never
  } 
    : Duo
  : Duo


  type DuoCountArgs = Merge<
    Omit<DuoFindManyArgs, 'select' | 'include'> & {
      select?: DuoCountAggregateInputType | true
    }
  >

  export interface DuoDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Duo that matches the filter.
     * @param {DuoFindUniqueArgs} args - Arguments to find a Duo
     * @example
     * // Get one Duo
     * const duo = await prisma.duo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DuoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DuoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Duo'> extends True ? CheckSelect<T, Prisma__DuoClient<Duo>, Prisma__DuoClient<DuoGetPayload<T>>> : CheckSelect<T, Prisma__DuoClient<Duo | null >, Prisma__DuoClient<DuoGetPayload<T> | null >>

    /**
     * Find the first Duo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DuoFindFirstArgs} args - Arguments to find a Duo
     * @example
     * // Get one Duo
     * const duo = await prisma.duo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DuoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DuoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Duo'> extends True ? CheckSelect<T, Prisma__DuoClient<Duo>, Prisma__DuoClient<DuoGetPayload<T>>> : CheckSelect<T, Prisma__DuoClient<Duo | null >, Prisma__DuoClient<DuoGetPayload<T> | null >>

    /**
     * Find zero or more Duos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DuoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Duos
     * const duos = await prisma.duo.findMany()
     * 
     * // Get first 10 Duos
     * const duos = await prisma.duo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const duoWithIdOnly = await prisma.duo.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DuoFindManyArgs>(
      args?: SelectSubset<T, DuoFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Duo>>, PrismaPromise<Array<DuoGetPayload<T>>>>

    /**
     * Create a Duo.
     * @param {DuoCreateArgs} args - Arguments to create a Duo.
     * @example
     * // Create one Duo
     * const Duo = await prisma.duo.create({
     *   data: {
     *     // ... data to create a Duo
     *   }
     * })
     * 
    **/
    create<T extends DuoCreateArgs>(
      args: SelectSubset<T, DuoCreateArgs>
    ): CheckSelect<T, Prisma__DuoClient<Duo>, Prisma__DuoClient<DuoGetPayload<T>>>

    /**
     * Create many Duos.
     *     @param {DuoCreateManyArgs} args - Arguments to create many Duos.
     *     @example
     *     // Create many Duos
     *     const duo = await prisma.duo.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DuoCreateManyArgs>(
      args?: SelectSubset<T, DuoCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Duo.
     * @param {DuoDeleteArgs} args - Arguments to delete one Duo.
     * @example
     * // Delete one Duo
     * const Duo = await prisma.duo.delete({
     *   where: {
     *     // ... filter to delete one Duo
     *   }
     * })
     * 
    **/
    delete<T extends DuoDeleteArgs>(
      args: SelectSubset<T, DuoDeleteArgs>
    ): CheckSelect<T, Prisma__DuoClient<Duo>, Prisma__DuoClient<DuoGetPayload<T>>>

    /**
     * Update one Duo.
     * @param {DuoUpdateArgs} args - Arguments to update one Duo.
     * @example
     * // Update one Duo
     * const duo = await prisma.duo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DuoUpdateArgs>(
      args: SelectSubset<T, DuoUpdateArgs>
    ): CheckSelect<T, Prisma__DuoClient<Duo>, Prisma__DuoClient<DuoGetPayload<T>>>

    /**
     * Delete zero or more Duos.
     * @param {DuoDeleteManyArgs} args - Arguments to filter Duos to delete.
     * @example
     * // Delete a few Duos
     * const { count } = await prisma.duo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DuoDeleteManyArgs>(
      args?: SelectSubset<T, DuoDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Duos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DuoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Duos
     * const duo = await prisma.duo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DuoUpdateManyArgs>(
      args: SelectSubset<T, DuoUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Duo.
     * @param {DuoUpsertArgs} args - Arguments to update or create a Duo.
     * @example
     * // Update or create a Duo
     * const duo = await prisma.duo.upsert({
     *   create: {
     *     // ... data to create a Duo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Duo we want to update
     *   }
     * })
    **/
    upsert<T extends DuoUpsertArgs>(
      args: SelectSubset<T, DuoUpsertArgs>
    ): CheckSelect<T, Prisma__DuoClient<Duo>, Prisma__DuoClient<DuoGetPayload<T>>>

    /**
     * Count the number of Duos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DuoCountArgs} args - Arguments to filter Duos to count.
     * @example
     * // Count the number of Duos
     * const count = await prisma.duo.count({
     *   where: {
     *     // ... the filter for the Duos we want to count
     *   }
     * })
    **/
    count<T extends DuoCountArgs>(
      args?: Subset<T, DuoCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DuoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Duo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DuoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DuoAggregateArgs>(args: Subset<T, DuoAggregateArgs>): PrismaPromise<GetDuoAggregateType<T>>

    /**
     * Group by Duo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DuoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DuoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DuoGroupByArgs['orderBy'] }
        : { orderBy?: DuoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DuoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDuoGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Duo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DuoClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    profile<T extends ProfileArgs = {}>(args?: Subset<T, ProfileArgs>): CheckSelect<T, Prisma__ProfileClient<Profile | null >, Prisma__ProfileClient<ProfileGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Duo findUnique
   */
  export type DuoFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Duo
     * 
    **/
    select?: DuoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DuoInclude | null
    /**
     * Throw an Error if a Duo can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Duo to fetch.
     * 
    **/
    where: DuoWhereUniqueInput
  }


  /**
   * Duo findFirst
   */
  export type DuoFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Duo
     * 
    **/
    select?: DuoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DuoInclude | null
    /**
     * Throw an Error if a Duo can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Duo to fetch.
     * 
    **/
    where?: DuoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Duos to fetch.
     * 
    **/
    orderBy?: Enumerable<DuoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Duos.
     * 
    **/
    cursor?: DuoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Duos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Duos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Duos.
     * 
    **/
    distinct?: Enumerable<DuoScalarFieldEnum>
  }


  /**
   * Duo findMany
   */
  export type DuoFindManyArgs = {
    /**
     * Select specific fields to fetch from the Duo
     * 
    **/
    select?: DuoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DuoInclude | null
    /**
     * Filter, which Duos to fetch.
     * 
    **/
    where?: DuoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Duos to fetch.
     * 
    **/
    orderBy?: Enumerable<DuoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Duos.
     * 
    **/
    cursor?: DuoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Duos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Duos.
     * 
    **/
    skip?: number
    distinct?: Enumerable<DuoScalarFieldEnum>
  }


  /**
   * Duo create
   */
  export type DuoCreateArgs = {
    /**
     * Select specific fields to fetch from the Duo
     * 
    **/
    select?: DuoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DuoInclude | null
    /**
     * The data needed to create a Duo.
     * 
    **/
    data: XOR<DuoCreateInput, DuoUncheckedCreateInput>
  }


  /**
   * Duo createMany
   */
  export type DuoCreateManyArgs = {
    /**
     * The data used to create many Duos.
     * 
    **/
    data: Enumerable<DuoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Duo update
   */
  export type DuoUpdateArgs = {
    /**
     * Select specific fields to fetch from the Duo
     * 
    **/
    select?: DuoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DuoInclude | null
    /**
     * The data needed to update a Duo.
     * 
    **/
    data: XOR<DuoUpdateInput, DuoUncheckedUpdateInput>
    /**
     * Choose, which Duo to update.
     * 
    **/
    where: DuoWhereUniqueInput
  }


  /**
   * Duo updateMany
   */
  export type DuoUpdateManyArgs = {
    /**
     * The data used to update Duos.
     * 
    **/
    data: XOR<DuoUpdateManyMutationInput, DuoUncheckedUpdateManyInput>
    /**
     * Filter which Duos to update
     * 
    **/
    where?: DuoWhereInput
  }


  /**
   * Duo upsert
   */
  export type DuoUpsertArgs = {
    /**
     * Select specific fields to fetch from the Duo
     * 
    **/
    select?: DuoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DuoInclude | null
    /**
     * The filter to search for the Duo to update in case it exists.
     * 
    **/
    where: DuoWhereUniqueInput
    /**
     * In case the Duo found by the `where` argument doesn't exist, create a new Duo with this data.
     * 
    **/
    create: XOR<DuoCreateInput, DuoUncheckedCreateInput>
    /**
     * In case the Duo was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<DuoUpdateInput, DuoUncheckedUpdateInput>
  }


  /**
   * Duo delete
   */
  export type DuoDeleteArgs = {
    /**
     * Select specific fields to fetch from the Duo
     * 
    **/
    select?: DuoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DuoInclude | null
    /**
     * Filter which Duo to delete.
     * 
    **/
    where: DuoWhereUniqueInput
  }


  /**
   * Duo deleteMany
   */
  export type DuoDeleteManyArgs = {
    /**
     * Filter which Duos to delete
     * 
    **/
    where?: DuoWhereInput
  }


  /**
   * Duo without action
   */
  export type DuoArgs = {
    /**
     * Select specific fields to fetch from the Duo
     * 
    **/
    select?: DuoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DuoInclude | null
  }



  /**
   * Model Constant
   */


  export type AggregateConstant = {
    _count: ConstantCountAggregateOutputType | null
    _min: ConstantMinAggregateOutputType | null
    _max: ConstantMaxAggregateOutputType | null
  }

  export type ConstantMinAggregateOutputType = {
    id: string | null
    startTime: string | null
    currentSeason: string | null
    seeding: boolean | null
  }

  export type ConstantMaxAggregateOutputType = {
    id: string | null
    startTime: string | null
    currentSeason: string | null
    seeding: boolean | null
  }

  export type ConstantCountAggregateOutputType = {
    id: number
    startTime: number
    currentSeason: number
    seeding: number
    _all: number
  }


  export type ConstantMinAggregateInputType = {
    id?: true
    startTime?: true
    currentSeason?: true
    seeding?: true
  }

  export type ConstantMaxAggregateInputType = {
    id?: true
    startTime?: true
    currentSeason?: true
    seeding?: true
  }

  export type ConstantCountAggregateInputType = {
    id?: true
    startTime?: true
    currentSeason?: true
    seeding?: true
    _all?: true
  }

  export type ConstantAggregateArgs = {
    /**
     * Filter which Constant to aggregate.
     * 
    **/
    where?: ConstantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Constants to fetch.
     * 
    **/
    orderBy?: Enumerable<ConstantOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ConstantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Constants from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Constants.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Constants
    **/
    _count?: true | ConstantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConstantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConstantMaxAggregateInputType
  }

  export type GetConstantAggregateType<T extends ConstantAggregateArgs> = {
        [P in keyof T & keyof AggregateConstant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConstant[P]>
      : GetScalarType<T[P], AggregateConstant[P]>
  }




  export type ConstantGroupByArgs = {
    where?: ConstantWhereInput
    orderBy?: Enumerable<ConstantOrderByWithAggregationInput>
    by: Array<ConstantScalarFieldEnum>
    having?: ConstantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConstantCountAggregateInputType | true
    _min?: ConstantMinAggregateInputType
    _max?: ConstantMaxAggregateInputType
  }


  export type ConstantGroupByOutputType = {
    id: string
    startTime: string
    currentSeason: string
    seeding: boolean
    _count: ConstantCountAggregateOutputType | null
    _min: ConstantMinAggregateOutputType | null
    _max: ConstantMaxAggregateOutputType | null
  }

  type GetConstantGroupByPayload<T extends ConstantGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ConstantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConstantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConstantGroupByOutputType[P]>
            : GetScalarType<T[P], ConstantGroupByOutputType[P]>
        }
      >
    >


  export type ConstantSelect = {
    id?: boolean
    startTime?: boolean
    currentSeason?: boolean
    seeding?: boolean
  }

  export type ConstantGetPayload<
    S extends boolean | null | undefined | ConstantArgs,
    U = keyof S
      > = S extends true
        ? Constant
    : S extends undefined
    ? never
    : S extends ConstantArgs | ConstantFindManyArgs
    ?'include' extends U
    ? Constant 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof Constant ? Constant[P] : never
  } 
    : Constant
  : Constant


  type ConstantCountArgs = Merge<
    Omit<ConstantFindManyArgs, 'select' | 'include'> & {
      select?: ConstantCountAggregateInputType | true
    }
  >

  export interface ConstantDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Constant that matches the filter.
     * @param {ConstantFindUniqueArgs} args - Arguments to find a Constant
     * @example
     * // Get one Constant
     * const constant = await prisma.constant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ConstantFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ConstantFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Constant'> extends True ? CheckSelect<T, Prisma__ConstantClient<Constant>, Prisma__ConstantClient<ConstantGetPayload<T>>> : CheckSelect<T, Prisma__ConstantClient<Constant | null >, Prisma__ConstantClient<ConstantGetPayload<T> | null >>

    /**
     * Find the first Constant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConstantFindFirstArgs} args - Arguments to find a Constant
     * @example
     * // Get one Constant
     * const constant = await prisma.constant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ConstantFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ConstantFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Constant'> extends True ? CheckSelect<T, Prisma__ConstantClient<Constant>, Prisma__ConstantClient<ConstantGetPayload<T>>> : CheckSelect<T, Prisma__ConstantClient<Constant | null >, Prisma__ConstantClient<ConstantGetPayload<T> | null >>

    /**
     * Find zero or more Constants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConstantFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Constants
     * const constants = await prisma.constant.findMany()
     * 
     * // Get first 10 Constants
     * const constants = await prisma.constant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const constantWithIdOnly = await prisma.constant.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ConstantFindManyArgs>(
      args?: SelectSubset<T, ConstantFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Constant>>, PrismaPromise<Array<ConstantGetPayload<T>>>>

    /**
     * Create a Constant.
     * @param {ConstantCreateArgs} args - Arguments to create a Constant.
     * @example
     * // Create one Constant
     * const Constant = await prisma.constant.create({
     *   data: {
     *     // ... data to create a Constant
     *   }
     * })
     * 
    **/
    create<T extends ConstantCreateArgs>(
      args: SelectSubset<T, ConstantCreateArgs>
    ): CheckSelect<T, Prisma__ConstantClient<Constant>, Prisma__ConstantClient<ConstantGetPayload<T>>>

    /**
     * Create many Constants.
     *     @param {ConstantCreateManyArgs} args - Arguments to create many Constants.
     *     @example
     *     // Create many Constants
     *     const constant = await prisma.constant.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ConstantCreateManyArgs>(
      args?: SelectSubset<T, ConstantCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Constant.
     * @param {ConstantDeleteArgs} args - Arguments to delete one Constant.
     * @example
     * // Delete one Constant
     * const Constant = await prisma.constant.delete({
     *   where: {
     *     // ... filter to delete one Constant
     *   }
     * })
     * 
    **/
    delete<T extends ConstantDeleteArgs>(
      args: SelectSubset<T, ConstantDeleteArgs>
    ): CheckSelect<T, Prisma__ConstantClient<Constant>, Prisma__ConstantClient<ConstantGetPayload<T>>>

    /**
     * Update one Constant.
     * @param {ConstantUpdateArgs} args - Arguments to update one Constant.
     * @example
     * // Update one Constant
     * const constant = await prisma.constant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ConstantUpdateArgs>(
      args: SelectSubset<T, ConstantUpdateArgs>
    ): CheckSelect<T, Prisma__ConstantClient<Constant>, Prisma__ConstantClient<ConstantGetPayload<T>>>

    /**
     * Delete zero or more Constants.
     * @param {ConstantDeleteManyArgs} args - Arguments to filter Constants to delete.
     * @example
     * // Delete a few Constants
     * const { count } = await prisma.constant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ConstantDeleteManyArgs>(
      args?: SelectSubset<T, ConstantDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Constants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConstantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Constants
     * const constant = await prisma.constant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ConstantUpdateManyArgs>(
      args: SelectSubset<T, ConstantUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Constant.
     * @param {ConstantUpsertArgs} args - Arguments to update or create a Constant.
     * @example
     * // Update or create a Constant
     * const constant = await prisma.constant.upsert({
     *   create: {
     *     // ... data to create a Constant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Constant we want to update
     *   }
     * })
    **/
    upsert<T extends ConstantUpsertArgs>(
      args: SelectSubset<T, ConstantUpsertArgs>
    ): CheckSelect<T, Prisma__ConstantClient<Constant>, Prisma__ConstantClient<ConstantGetPayload<T>>>

    /**
     * Count the number of Constants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConstantCountArgs} args - Arguments to filter Constants to count.
     * @example
     * // Count the number of Constants
     * const count = await prisma.constant.count({
     *   where: {
     *     // ... the filter for the Constants we want to count
     *   }
     * })
    **/
    count<T extends ConstantCountArgs>(
      args?: Subset<T, ConstantCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConstantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Constant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConstantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConstantAggregateArgs>(args: Subset<T, ConstantAggregateArgs>): PrismaPromise<GetConstantAggregateType<T>>

    /**
     * Group by Constant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConstantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConstantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConstantGroupByArgs['orderBy'] }
        : { orderBy?: ConstantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConstantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConstantGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Constant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ConstantClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Constant findUnique
   */
  export type ConstantFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Constant
     * 
    **/
    select?: ConstantSelect | null
    /**
     * Throw an Error if a Constant can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Constant to fetch.
     * 
    **/
    where: ConstantWhereUniqueInput
  }


  /**
   * Constant findFirst
   */
  export type ConstantFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Constant
     * 
    **/
    select?: ConstantSelect | null
    /**
     * Throw an Error if a Constant can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Constant to fetch.
     * 
    **/
    where?: ConstantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Constants to fetch.
     * 
    **/
    orderBy?: Enumerable<ConstantOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Constants.
     * 
    **/
    cursor?: ConstantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Constants from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Constants.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Constants.
     * 
    **/
    distinct?: Enumerable<ConstantScalarFieldEnum>
  }


  /**
   * Constant findMany
   */
  export type ConstantFindManyArgs = {
    /**
     * Select specific fields to fetch from the Constant
     * 
    **/
    select?: ConstantSelect | null
    /**
     * Filter, which Constants to fetch.
     * 
    **/
    where?: ConstantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Constants to fetch.
     * 
    **/
    orderBy?: Enumerable<ConstantOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Constants.
     * 
    **/
    cursor?: ConstantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Constants from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Constants.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ConstantScalarFieldEnum>
  }


  /**
   * Constant create
   */
  export type ConstantCreateArgs = {
    /**
     * Select specific fields to fetch from the Constant
     * 
    **/
    select?: ConstantSelect | null
    /**
     * The data needed to create a Constant.
     * 
    **/
    data: XOR<ConstantCreateInput, ConstantUncheckedCreateInput>
  }


  /**
   * Constant createMany
   */
  export type ConstantCreateManyArgs = {
    /**
     * The data used to create many Constants.
     * 
    **/
    data: Enumerable<ConstantCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Constant update
   */
  export type ConstantUpdateArgs = {
    /**
     * Select specific fields to fetch from the Constant
     * 
    **/
    select?: ConstantSelect | null
    /**
     * The data needed to update a Constant.
     * 
    **/
    data: XOR<ConstantUpdateInput, ConstantUncheckedUpdateInput>
    /**
     * Choose, which Constant to update.
     * 
    **/
    where: ConstantWhereUniqueInput
  }


  /**
   * Constant updateMany
   */
  export type ConstantUpdateManyArgs = {
    /**
     * The data used to update Constants.
     * 
    **/
    data: XOR<ConstantUpdateManyMutationInput, ConstantUncheckedUpdateManyInput>
    /**
     * Filter which Constants to update
     * 
    **/
    where?: ConstantWhereInput
  }


  /**
   * Constant upsert
   */
  export type ConstantUpsertArgs = {
    /**
     * Select specific fields to fetch from the Constant
     * 
    **/
    select?: ConstantSelect | null
    /**
     * The filter to search for the Constant to update in case it exists.
     * 
    **/
    where: ConstantWhereUniqueInput
    /**
     * In case the Constant found by the `where` argument doesn't exist, create a new Constant with this data.
     * 
    **/
    create: XOR<ConstantCreateInput, ConstantUncheckedCreateInput>
    /**
     * In case the Constant was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ConstantUpdateInput, ConstantUncheckedUpdateInput>
  }


  /**
   * Constant delete
   */
  export type ConstantDeleteArgs = {
    /**
     * Select specific fields to fetch from the Constant
     * 
    **/
    select?: ConstantSelect | null
    /**
     * Filter which Constant to delete.
     * 
    **/
    where: ConstantWhereUniqueInput
  }


  /**
   * Constant deleteMany
   */
  export type ConstantDeleteManyArgs = {
    /**
     * Filter which Constants to delete
     * 
    **/
    where?: ConstantWhereInput
  }


  /**
   * Constant without action
   */
  export type ConstantArgs = {
    /**
     * Select specific fields to fetch from the Constant
     * 
    **/
    select?: ConstantSelect | null
  }



  /**
   * Model Event
   */


  export type AggregateEvent = {
    _count: EventCountAggregateOutputType | null
    _avg: EventAvgAggregateOutputType | null
    _sum: EventSumAggregateOutputType | null
    _min: EventMinAggregateOutputType | null
    _max: EventMaxAggregateOutputType | null
  }

  export type EventAvgAggregateOutputType = {
    timestamp: number | null
  }

  export type EventSumAggregateOutputType = {
    timestamp: number | null
  }

  export type EventMinAggregateOutputType = {
    id: string | null
    timestamp: number | null
  }

  export type EventMaxAggregateOutputType = {
    id: string | null
    timestamp: number | null
  }

  export type EventCountAggregateOutputType = {
    id: number
    timestamp: number
    _all: number
  }


  export type EventAvgAggregateInputType = {
    timestamp?: true
  }

  export type EventSumAggregateInputType = {
    timestamp?: true
  }

  export type EventMinAggregateInputType = {
    id?: true
    timestamp?: true
  }

  export type EventMaxAggregateInputType = {
    id?: true
    timestamp?: true
  }

  export type EventCountAggregateInputType = {
    id?: true
    timestamp?: true
    _all?: true
  }

  export type EventAggregateArgs = {
    /**
     * Filter which Event to aggregate.
     * 
    **/
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     * 
    **/
    orderBy?: Enumerable<EventOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Events
    **/
    _count?: true | EventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EventAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EventSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventMaxAggregateInputType
  }

  export type GetEventAggregateType<T extends EventAggregateArgs> = {
        [P in keyof T & keyof AggregateEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvent[P]>
      : GetScalarType<T[P], AggregateEvent[P]>
  }




  export type EventGroupByArgs = {
    where?: EventWhereInput
    orderBy?: Enumerable<EventOrderByWithAggregationInput>
    by: Array<EventScalarFieldEnum>
    having?: EventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventCountAggregateInputType | true
    _avg?: EventAvgAggregateInputType
    _sum?: EventSumAggregateInputType
    _min?: EventMinAggregateInputType
    _max?: EventMaxAggregateInputType
  }


  export type EventGroupByOutputType = {
    id: string
    timestamp: number | null
    _count: EventCountAggregateOutputType | null
    _avg: EventAvgAggregateOutputType | null
    _sum: EventSumAggregateOutputType | null
    _min: EventMinAggregateOutputType | null
    _max: EventMaxAggregateOutputType | null
  }

  type GetEventGroupByPayload<T extends EventGroupByArgs> = PrismaPromise<
    Array<
      PickArray<EventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventGroupByOutputType[P]>
            : GetScalarType<T[P], EventGroupByOutputType[P]>
        }
      >
    >


  export type EventSelect = {
    id?: boolean
    timestamp?: boolean
    position?: boolean | PositionFindManyArgs
    _count?: boolean | EventCountOutputTypeArgs
  }

  export type EventInclude = {
    position?: boolean | PositionFindManyArgs
    _count?: boolean | EventCountOutputTypeArgs
  }

  export type EventGetPayload<
    S extends boolean | null | undefined | EventArgs,
    U = keyof S
      > = S extends true
        ? Event
    : S extends undefined
    ? never
    : S extends EventArgs | EventFindManyArgs
    ?'include' extends U
    ? Event  & {
    [P in TrueKeys<S['include']>]:
        P extends 'position' ? Array < PositionGetPayload<S['include'][P]>>  :
        P extends '_count' ? EventCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'position' ? Array < PositionGetPayload<S['select'][P]>>  :
        P extends '_count' ? EventCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Event ? Event[P] : never
  } 
    : Event
  : Event


  type EventCountArgs = Merge<
    Omit<EventFindManyArgs, 'select' | 'include'> & {
      select?: EventCountAggregateInputType | true
    }
  >

  export interface EventDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Event that matches the filter.
     * @param {EventFindUniqueArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EventFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, EventFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Event'> extends True ? CheckSelect<T, Prisma__EventClient<Event>, Prisma__EventClient<EventGetPayload<T>>> : CheckSelect<T, Prisma__EventClient<Event | null >, Prisma__EventClient<EventGetPayload<T> | null >>

    /**
     * Find the first Event that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindFirstArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EventFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, EventFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Event'> extends True ? CheckSelect<T, Prisma__EventClient<Event>, Prisma__EventClient<EventGetPayload<T>>> : CheckSelect<T, Prisma__EventClient<Event | null >, Prisma__EventClient<EventGetPayload<T> | null >>

    /**
     * Find zero or more Events that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Events
     * const events = await prisma.event.findMany()
     * 
     * // Get first 10 Events
     * const events = await prisma.event.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eventWithIdOnly = await prisma.event.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EventFindManyArgs>(
      args?: SelectSubset<T, EventFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Event>>, PrismaPromise<Array<EventGetPayload<T>>>>

    /**
     * Create a Event.
     * @param {EventCreateArgs} args - Arguments to create a Event.
     * @example
     * // Create one Event
     * const Event = await prisma.event.create({
     *   data: {
     *     // ... data to create a Event
     *   }
     * })
     * 
    **/
    create<T extends EventCreateArgs>(
      args: SelectSubset<T, EventCreateArgs>
    ): CheckSelect<T, Prisma__EventClient<Event>, Prisma__EventClient<EventGetPayload<T>>>

    /**
     * Create many Events.
     *     @param {EventCreateManyArgs} args - Arguments to create many Events.
     *     @example
     *     // Create many Events
     *     const event = await prisma.event.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EventCreateManyArgs>(
      args?: SelectSubset<T, EventCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Event.
     * @param {EventDeleteArgs} args - Arguments to delete one Event.
     * @example
     * // Delete one Event
     * const Event = await prisma.event.delete({
     *   where: {
     *     // ... filter to delete one Event
     *   }
     * })
     * 
    **/
    delete<T extends EventDeleteArgs>(
      args: SelectSubset<T, EventDeleteArgs>
    ): CheckSelect<T, Prisma__EventClient<Event>, Prisma__EventClient<EventGetPayload<T>>>

    /**
     * Update one Event.
     * @param {EventUpdateArgs} args - Arguments to update one Event.
     * @example
     * // Update one Event
     * const event = await prisma.event.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EventUpdateArgs>(
      args: SelectSubset<T, EventUpdateArgs>
    ): CheckSelect<T, Prisma__EventClient<Event>, Prisma__EventClient<EventGetPayload<T>>>

    /**
     * Delete zero or more Events.
     * @param {EventDeleteManyArgs} args - Arguments to filter Events to delete.
     * @example
     * // Delete a few Events
     * const { count } = await prisma.event.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EventDeleteManyArgs>(
      args?: SelectSubset<T, EventDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Events
     * const event = await prisma.event.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EventUpdateManyArgs>(
      args: SelectSubset<T, EventUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Event.
     * @param {EventUpsertArgs} args - Arguments to update or create a Event.
     * @example
     * // Update or create a Event
     * const event = await prisma.event.upsert({
     *   create: {
     *     // ... data to create a Event
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Event we want to update
     *   }
     * })
    **/
    upsert<T extends EventUpsertArgs>(
      args: SelectSubset<T, EventUpsertArgs>
    ): CheckSelect<T, Prisma__EventClient<Event>, Prisma__EventClient<EventGetPayload<T>>>

    /**
     * Count the number of Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventCountArgs} args - Arguments to filter Events to count.
     * @example
     * // Count the number of Events
     * const count = await prisma.event.count({
     *   where: {
     *     // ... the filter for the Events we want to count
     *   }
     * })
    **/
    count<T extends EventCountArgs>(
      args?: Subset<T, EventCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventAggregateArgs>(args: Subset<T, EventAggregateArgs>): PrismaPromise<GetEventAggregateType<T>>

    /**
     * Group by Event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventGroupByArgs['orderBy'] }
        : { orderBy?: EventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Event.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__EventClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    position<T extends PositionFindManyArgs = {}>(args?: Subset<T, PositionFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Position>>, PrismaPromise<Array<PositionGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Event findUnique
   */
  export type EventFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Event
     * 
    **/
    select?: EventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EventInclude | null
    /**
     * Throw an Error if a Event can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Event to fetch.
     * 
    **/
    where: EventWhereUniqueInput
  }


  /**
   * Event findFirst
   */
  export type EventFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Event
     * 
    **/
    select?: EventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EventInclude | null
    /**
     * Throw an Error if a Event can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Event to fetch.
     * 
    **/
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     * 
    **/
    orderBy?: Enumerable<EventOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Events.
     * 
    **/
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Events.
     * 
    **/
    distinct?: Enumerable<EventScalarFieldEnum>
  }


  /**
   * Event findMany
   */
  export type EventFindManyArgs = {
    /**
     * Select specific fields to fetch from the Event
     * 
    **/
    select?: EventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EventInclude | null
    /**
     * Filter, which Events to fetch.
     * 
    **/
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     * 
    **/
    orderBy?: Enumerable<EventOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Events.
     * 
    **/
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     * 
    **/
    skip?: number
    distinct?: Enumerable<EventScalarFieldEnum>
  }


  /**
   * Event create
   */
  export type EventCreateArgs = {
    /**
     * Select specific fields to fetch from the Event
     * 
    **/
    select?: EventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EventInclude | null
    /**
     * The data needed to create a Event.
     * 
    **/
    data: XOR<EventCreateInput, EventUncheckedCreateInput>
  }


  /**
   * Event createMany
   */
  export type EventCreateManyArgs = {
    /**
     * The data used to create many Events.
     * 
    **/
    data: Enumerable<EventCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Event update
   */
  export type EventUpdateArgs = {
    /**
     * Select specific fields to fetch from the Event
     * 
    **/
    select?: EventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EventInclude | null
    /**
     * The data needed to update a Event.
     * 
    **/
    data: XOR<EventUpdateInput, EventUncheckedUpdateInput>
    /**
     * Choose, which Event to update.
     * 
    **/
    where: EventWhereUniqueInput
  }


  /**
   * Event updateMany
   */
  export type EventUpdateManyArgs = {
    /**
     * The data used to update Events.
     * 
    **/
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyInput>
    /**
     * Filter which Events to update
     * 
    **/
    where?: EventWhereInput
  }


  /**
   * Event upsert
   */
  export type EventUpsertArgs = {
    /**
     * Select specific fields to fetch from the Event
     * 
    **/
    select?: EventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EventInclude | null
    /**
     * The filter to search for the Event to update in case it exists.
     * 
    **/
    where: EventWhereUniqueInput
    /**
     * In case the Event found by the `where` argument doesn't exist, create a new Event with this data.
     * 
    **/
    create: XOR<EventCreateInput, EventUncheckedCreateInput>
    /**
     * In case the Event was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<EventUpdateInput, EventUncheckedUpdateInput>
  }


  /**
   * Event delete
   */
  export type EventDeleteArgs = {
    /**
     * Select specific fields to fetch from the Event
     * 
    **/
    select?: EventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EventInclude | null
    /**
     * Filter which Event to delete.
     * 
    **/
    where: EventWhereUniqueInput
  }


  /**
   * Event deleteMany
   */
  export type EventDeleteManyArgs = {
    /**
     * Filter which Events to delete
     * 
    **/
    where?: EventWhereInput
  }


  /**
   * Event without action
   */
  export type EventArgs = {
    /**
     * Select specific fields to fetch from the Event
     * 
    **/
    select?: EventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EventInclude | null
  }



  /**
   * Model Game
   */


  export type AggregateGame = {
    _count: GameCountAggregateOutputType | null
    _avg: GameAvgAggregateOutputType | null
    _sum: GameSumAggregateOutputType | null
    _min: GameMinAggregateOutputType | null
    _max: GameMaxAggregateOutputType | null
  }

  export type GameAvgAggregateOutputType = {
    duration: number | null
    gameInSeries: number | null
  }

  export type GameSumAggregateOutputType = {
    duration: number | null
    gameInSeries: number | null
  }

  export type GameMinAggregateOutputType = {
    id: string | null
    matchId: string | null
    gameId: string | null
    gameCreation: string | null
    gameStartTimestamp: string | null
    gameEndTimestamp: string | null
    duration: number | null
    start: string | null
    gameVersion: string | null
    blueTeamId: string | null
    redTeamId: string | null
    tournament: string | null
    gameInSeries: number | null
    vod: string | null
    platformId: string | null
  }

  export type GameMaxAggregateOutputType = {
    id: string | null
    matchId: string | null
    gameId: string | null
    gameCreation: string | null
    gameStartTimestamp: string | null
    gameEndTimestamp: string | null
    duration: number | null
    start: string | null
    gameVersion: string | null
    blueTeamId: string | null
    redTeamId: string | null
    tournament: string | null
    gameInSeries: number | null
    vod: string | null
    platformId: string | null
  }

  export type GameCountAggregateOutputType = {
    id: number
    matchId: number
    gameId: number
    gameCreation: number
    gameStartTimestamp: number
    gameEndTimestamp: number
    duration: number
    start: number
    gameVersion: number
    blueTeamId: number
    redTeamId: number
    tournament: number
    gameInSeries: number
    vod: number
    platformId: number
    _all: number
  }


  export type GameAvgAggregateInputType = {
    duration?: true
    gameInSeries?: true
  }

  export type GameSumAggregateInputType = {
    duration?: true
    gameInSeries?: true
  }

  export type GameMinAggregateInputType = {
    id?: true
    matchId?: true
    gameId?: true
    gameCreation?: true
    gameStartTimestamp?: true
    gameEndTimestamp?: true
    duration?: true
    start?: true
    gameVersion?: true
    blueTeamId?: true
    redTeamId?: true
    tournament?: true
    gameInSeries?: true
    vod?: true
    platformId?: true
  }

  export type GameMaxAggregateInputType = {
    id?: true
    matchId?: true
    gameId?: true
    gameCreation?: true
    gameStartTimestamp?: true
    gameEndTimestamp?: true
    duration?: true
    start?: true
    gameVersion?: true
    blueTeamId?: true
    redTeamId?: true
    tournament?: true
    gameInSeries?: true
    vod?: true
    platformId?: true
  }

  export type GameCountAggregateInputType = {
    id?: true
    matchId?: true
    gameId?: true
    gameCreation?: true
    gameStartTimestamp?: true
    gameEndTimestamp?: true
    duration?: true
    start?: true
    gameVersion?: true
    blueTeamId?: true
    redTeamId?: true
    tournament?: true
    gameInSeries?: true
    vod?: true
    platformId?: true
    _all?: true
  }

  export type GameAggregateArgs = {
    /**
     * Filter which Game to aggregate.
     * 
    **/
    where?: GameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Games to fetch.
     * 
    **/
    orderBy?: Enumerable<GameOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: GameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Games from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Games.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Games
    **/
    _count?: true | GameCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GameAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GameSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GameMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GameMaxAggregateInputType
  }

  export type GetGameAggregateType<T extends GameAggregateArgs> = {
        [P in keyof T & keyof AggregateGame]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGame[P]>
      : GetScalarType<T[P], AggregateGame[P]>
  }




  export type GameGroupByArgs = {
    where?: GameWhereInput
    orderBy?: Enumerable<GameOrderByWithAggregationInput>
    by: Array<GameScalarFieldEnum>
    having?: GameScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GameCountAggregateInputType | true
    _avg?: GameAvgAggregateInputType
    _sum?: GameSumAggregateInputType
    _min?: GameMinAggregateInputType
    _max?: GameMaxAggregateInputType
  }


  export type GameGroupByOutputType = {
    id: string
    matchId: string
    gameId: string
    gameCreation: string
    gameStartTimestamp: string
    gameEndTimestamp: string
    duration: number | null
    start: string
    gameVersion: string
    blueTeamId: string | null
    redTeamId: string | null
    tournament: string
    gameInSeries: number | null
    vod: string
    platformId: string
    _count: GameCountAggregateOutputType | null
    _avg: GameAvgAggregateOutputType | null
    _sum: GameSumAggregateOutputType | null
    _min: GameMinAggregateOutputType | null
    _max: GameMaxAggregateOutputType | null
  }

  type GetGameGroupByPayload<T extends GameGroupByArgs> = PrismaPromise<
    Array<
      PickArray<GameGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GameGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GameGroupByOutputType[P]>
            : GetScalarType<T[P], GameGroupByOutputType[P]>
        }
      >
    >


  export type GameSelect = {
    id?: boolean
    matchId?: boolean
    gameId?: boolean
    gameCreation?: boolean
    gameStartTimestamp?: boolean
    gameEndTimestamp?: boolean
    duration?: boolean
    start?: boolean
    gameVersion?: boolean
    blueTeam?: boolean | TeamArgs
    blueTeamId?: boolean
    redTeam?: boolean | TeamArgs
    redTeamId?: boolean
    source?: boolean | SourceFindManyArgs
    tournament?: boolean
    gameInSeries?: boolean
    vod?: boolean
    platformId?: boolean
    from_PlayerEndOfGameStat_game?: boolean | PlayerEndOfGameStatFindManyArgs
    from_Team_game?: boolean | TeamFindManyArgs
    _count?: boolean | GameCountOutputTypeArgs
  }

  export type GameInclude = {
    blueTeam?: boolean | TeamArgs
    redTeam?: boolean | TeamArgs
    source?: boolean | SourceFindManyArgs
    from_PlayerEndOfGameStat_game?: boolean | PlayerEndOfGameStatFindManyArgs
    from_Team_game?: boolean | TeamFindManyArgs
    _count?: boolean | GameCountOutputTypeArgs
  }

  export type GameGetPayload<
    S extends boolean | null | undefined | GameArgs,
    U = keyof S
      > = S extends true
        ? Game
    : S extends undefined
    ? never
    : S extends GameArgs | GameFindManyArgs
    ?'include' extends U
    ? Game  & {
    [P in TrueKeys<S['include']>]:
        P extends 'blueTeam' ? TeamGetPayload<S['include'][P]> | null :
        P extends 'redTeam' ? TeamGetPayload<S['include'][P]> | null :
        P extends 'source' ? Array < SourceGetPayload<S['include'][P]>>  :
        P extends 'from_PlayerEndOfGameStat_game' ? Array < PlayerEndOfGameStatGetPayload<S['include'][P]>>  :
        P extends 'from_Team_game' ? Array < TeamGetPayload<S['include'][P]>>  :
        P extends '_count' ? GameCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'blueTeam' ? TeamGetPayload<S['select'][P]> | null :
        P extends 'redTeam' ? TeamGetPayload<S['select'][P]> | null :
        P extends 'source' ? Array < SourceGetPayload<S['select'][P]>>  :
        P extends 'from_PlayerEndOfGameStat_game' ? Array < PlayerEndOfGameStatGetPayload<S['select'][P]>>  :
        P extends 'from_Team_game' ? Array < TeamGetPayload<S['select'][P]>>  :
        P extends '_count' ? GameCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Game ? Game[P] : never
  } 
    : Game
  : Game


  type GameCountArgs = Merge<
    Omit<GameFindManyArgs, 'select' | 'include'> & {
      select?: GameCountAggregateInputType | true
    }
  >

  export interface GameDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Game that matches the filter.
     * @param {GameFindUniqueArgs} args - Arguments to find a Game
     * @example
     * // Get one Game
     * const game = await prisma.game.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends GameFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, GameFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Game'> extends True ? CheckSelect<T, Prisma__GameClient<Game>, Prisma__GameClient<GameGetPayload<T>>> : CheckSelect<T, Prisma__GameClient<Game | null >, Prisma__GameClient<GameGetPayload<T> | null >>

    /**
     * Find the first Game that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameFindFirstArgs} args - Arguments to find a Game
     * @example
     * // Get one Game
     * const game = await prisma.game.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends GameFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, GameFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Game'> extends True ? CheckSelect<T, Prisma__GameClient<Game>, Prisma__GameClient<GameGetPayload<T>>> : CheckSelect<T, Prisma__GameClient<Game | null >, Prisma__GameClient<GameGetPayload<T> | null >>

    /**
     * Find zero or more Games that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Games
     * const games = await prisma.game.findMany()
     * 
     * // Get first 10 Games
     * const games = await prisma.game.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gameWithIdOnly = await prisma.game.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends GameFindManyArgs>(
      args?: SelectSubset<T, GameFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Game>>, PrismaPromise<Array<GameGetPayload<T>>>>

    /**
     * Create a Game.
     * @param {GameCreateArgs} args - Arguments to create a Game.
     * @example
     * // Create one Game
     * const Game = await prisma.game.create({
     *   data: {
     *     // ... data to create a Game
     *   }
     * })
     * 
    **/
    create<T extends GameCreateArgs>(
      args: SelectSubset<T, GameCreateArgs>
    ): CheckSelect<T, Prisma__GameClient<Game>, Prisma__GameClient<GameGetPayload<T>>>

    /**
     * Create many Games.
     *     @param {GameCreateManyArgs} args - Arguments to create many Games.
     *     @example
     *     // Create many Games
     *     const game = await prisma.game.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends GameCreateManyArgs>(
      args?: SelectSubset<T, GameCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Game.
     * @param {GameDeleteArgs} args - Arguments to delete one Game.
     * @example
     * // Delete one Game
     * const Game = await prisma.game.delete({
     *   where: {
     *     // ... filter to delete one Game
     *   }
     * })
     * 
    **/
    delete<T extends GameDeleteArgs>(
      args: SelectSubset<T, GameDeleteArgs>
    ): CheckSelect<T, Prisma__GameClient<Game>, Prisma__GameClient<GameGetPayload<T>>>

    /**
     * Update one Game.
     * @param {GameUpdateArgs} args - Arguments to update one Game.
     * @example
     * // Update one Game
     * const game = await prisma.game.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends GameUpdateArgs>(
      args: SelectSubset<T, GameUpdateArgs>
    ): CheckSelect<T, Prisma__GameClient<Game>, Prisma__GameClient<GameGetPayload<T>>>

    /**
     * Delete zero or more Games.
     * @param {GameDeleteManyArgs} args - Arguments to filter Games to delete.
     * @example
     * // Delete a few Games
     * const { count } = await prisma.game.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends GameDeleteManyArgs>(
      args?: SelectSubset<T, GameDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Games.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Games
     * const game = await prisma.game.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends GameUpdateManyArgs>(
      args: SelectSubset<T, GameUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Game.
     * @param {GameUpsertArgs} args - Arguments to update or create a Game.
     * @example
     * // Update or create a Game
     * const game = await prisma.game.upsert({
     *   create: {
     *     // ... data to create a Game
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Game we want to update
     *   }
     * })
    **/
    upsert<T extends GameUpsertArgs>(
      args: SelectSubset<T, GameUpsertArgs>
    ): CheckSelect<T, Prisma__GameClient<Game>, Prisma__GameClient<GameGetPayload<T>>>

    /**
     * Count the number of Games.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameCountArgs} args - Arguments to filter Games to count.
     * @example
     * // Count the number of Games
     * const count = await prisma.game.count({
     *   where: {
     *     // ... the filter for the Games we want to count
     *   }
     * })
    **/
    count<T extends GameCountArgs>(
      args?: Subset<T, GameCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GameCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Game.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GameAggregateArgs>(args: Subset<T, GameAggregateArgs>): PrismaPromise<GetGameAggregateType<T>>

    /**
     * Group by Game.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GameGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GameGroupByArgs['orderBy'] }
        : { orderBy?: GameGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GameGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGameGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Game.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__GameClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    blueTeam<T extends TeamArgs = {}>(args?: Subset<T, TeamArgs>): CheckSelect<T, Prisma__TeamClient<Team | null >, Prisma__TeamClient<TeamGetPayload<T> | null >>;

    redTeam<T extends TeamArgs = {}>(args?: Subset<T, TeamArgs>): CheckSelect<T, Prisma__TeamClient<Team | null >, Prisma__TeamClient<TeamGetPayload<T> | null >>;

    source<T extends SourceFindManyArgs = {}>(args?: Subset<T, SourceFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Source>>, PrismaPromise<Array<SourceGetPayload<T>>>>;

    from_PlayerEndOfGameStat_game<T extends PlayerEndOfGameStatFindManyArgs = {}>(args?: Subset<T, PlayerEndOfGameStatFindManyArgs>): CheckSelect<T, PrismaPromise<Array<PlayerEndOfGameStat>>, PrismaPromise<Array<PlayerEndOfGameStatGetPayload<T>>>>;

    from_Team_game<T extends TeamFindManyArgs = {}>(args?: Subset<T, TeamFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Team>>, PrismaPromise<Array<TeamGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Game findUnique
   */
  export type GameFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Game
     * 
    **/
    select?: GameSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GameInclude | null
    /**
     * Throw an Error if a Game can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Game to fetch.
     * 
    **/
    where: GameWhereUniqueInput
  }


  /**
   * Game findFirst
   */
  export type GameFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Game
     * 
    **/
    select?: GameSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GameInclude | null
    /**
     * Throw an Error if a Game can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Game to fetch.
     * 
    **/
    where?: GameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Games to fetch.
     * 
    **/
    orderBy?: Enumerable<GameOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Games.
     * 
    **/
    cursor?: GameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Games from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Games.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Games.
     * 
    **/
    distinct?: Enumerable<GameScalarFieldEnum>
  }


  /**
   * Game findMany
   */
  export type GameFindManyArgs = {
    /**
     * Select specific fields to fetch from the Game
     * 
    **/
    select?: GameSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GameInclude | null
    /**
     * Filter, which Games to fetch.
     * 
    **/
    where?: GameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Games to fetch.
     * 
    **/
    orderBy?: Enumerable<GameOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Games.
     * 
    **/
    cursor?: GameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Games from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Games.
     * 
    **/
    skip?: number
    distinct?: Enumerable<GameScalarFieldEnum>
  }


  /**
   * Game create
   */
  export type GameCreateArgs = {
    /**
     * Select specific fields to fetch from the Game
     * 
    **/
    select?: GameSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GameInclude | null
    /**
     * The data needed to create a Game.
     * 
    **/
    data: XOR<GameCreateInput, GameUncheckedCreateInput>
  }


  /**
   * Game createMany
   */
  export type GameCreateManyArgs = {
    /**
     * The data used to create many Games.
     * 
    **/
    data: Enumerable<GameCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Game update
   */
  export type GameUpdateArgs = {
    /**
     * Select specific fields to fetch from the Game
     * 
    **/
    select?: GameSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GameInclude | null
    /**
     * The data needed to update a Game.
     * 
    **/
    data: XOR<GameUpdateInput, GameUncheckedUpdateInput>
    /**
     * Choose, which Game to update.
     * 
    **/
    where: GameWhereUniqueInput
  }


  /**
   * Game updateMany
   */
  export type GameUpdateManyArgs = {
    /**
     * The data used to update Games.
     * 
    **/
    data: XOR<GameUpdateManyMutationInput, GameUncheckedUpdateManyInput>
    /**
     * Filter which Games to update
     * 
    **/
    where?: GameWhereInput
  }


  /**
   * Game upsert
   */
  export type GameUpsertArgs = {
    /**
     * Select specific fields to fetch from the Game
     * 
    **/
    select?: GameSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GameInclude | null
    /**
     * The filter to search for the Game to update in case it exists.
     * 
    **/
    where: GameWhereUniqueInput
    /**
     * In case the Game found by the `where` argument doesn't exist, create a new Game with this data.
     * 
    **/
    create: XOR<GameCreateInput, GameUncheckedCreateInput>
    /**
     * In case the Game was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<GameUpdateInput, GameUncheckedUpdateInput>
  }


  /**
   * Game delete
   */
  export type GameDeleteArgs = {
    /**
     * Select specific fields to fetch from the Game
     * 
    **/
    select?: GameSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GameInclude | null
    /**
     * Filter which Game to delete.
     * 
    **/
    where: GameWhereUniqueInput
  }


  /**
   * Game deleteMany
   */
  export type GameDeleteManyArgs = {
    /**
     * Filter which Games to delete
     * 
    **/
    where?: GameWhereInput
  }


  /**
   * Game without action
   */
  export type GameArgs = {
    /**
     * Select specific fields to fetch from the Game
     * 
    **/
    select?: GameSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GameInclude | null
  }



  /**
   * Model Objective
   */


  export type AggregateObjective = {
    _count: ObjectiveCountAggregateOutputType | null
    _avg: ObjectiveAvgAggregateOutputType | null
    _sum: ObjectiveSumAggregateOutputType | null
    _min: ObjectiveMinAggregateOutputType | null
    _max: ObjectiveMaxAggregateOutputType | null
  }

  export type ObjectiveAvgAggregateOutputType = {
    kills: number | null
  }

  export type ObjectiveSumAggregateOutputType = {
    kills: number | null
  }

  export type ObjectiveMinAggregateOutputType = {
    id: string | null
    teamId: string | null
    first: boolean | null
    kills: number | null
    type: string | null
  }

  export type ObjectiveMaxAggregateOutputType = {
    id: string | null
    teamId: string | null
    first: boolean | null
    kills: number | null
    type: string | null
  }

  export type ObjectiveCountAggregateOutputType = {
    id: number
    teamId: number
    first: number
    kills: number
    type: number
    _all: number
  }


  export type ObjectiveAvgAggregateInputType = {
    kills?: true
  }

  export type ObjectiveSumAggregateInputType = {
    kills?: true
  }

  export type ObjectiveMinAggregateInputType = {
    id?: true
    teamId?: true
    first?: true
    kills?: true
    type?: true
  }

  export type ObjectiveMaxAggregateInputType = {
    id?: true
    teamId?: true
    first?: true
    kills?: true
    type?: true
  }

  export type ObjectiveCountAggregateInputType = {
    id?: true
    teamId?: true
    first?: true
    kills?: true
    type?: true
    _all?: true
  }

  export type ObjectiveAggregateArgs = {
    /**
     * Filter which Objective to aggregate.
     * 
    **/
    where?: ObjectiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Objectives to fetch.
     * 
    **/
    orderBy?: Enumerable<ObjectiveOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ObjectiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Objectives from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Objectives.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Objectives
    **/
    _count?: true | ObjectiveCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ObjectiveAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ObjectiveSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ObjectiveMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ObjectiveMaxAggregateInputType
  }

  export type GetObjectiveAggregateType<T extends ObjectiveAggregateArgs> = {
        [P in keyof T & keyof AggregateObjective]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateObjective[P]>
      : GetScalarType<T[P], AggregateObjective[P]>
  }




  export type ObjectiveGroupByArgs = {
    where?: ObjectiveWhereInput
    orderBy?: Enumerable<ObjectiveOrderByWithAggregationInput>
    by: Array<ObjectiveScalarFieldEnum>
    having?: ObjectiveScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ObjectiveCountAggregateInputType | true
    _avg?: ObjectiveAvgAggregateInputType
    _sum?: ObjectiveSumAggregateInputType
    _min?: ObjectiveMinAggregateInputType
    _max?: ObjectiveMaxAggregateInputType
  }


  export type ObjectiveGroupByOutputType = {
    id: string
    teamId: string | null
    first: boolean
    kills: number | null
    type: string
    _count: ObjectiveCountAggregateOutputType | null
    _avg: ObjectiveAvgAggregateOutputType | null
    _sum: ObjectiveSumAggregateOutputType | null
    _min: ObjectiveMinAggregateOutputType | null
    _max: ObjectiveMaxAggregateOutputType | null
  }

  type GetObjectiveGroupByPayload<T extends ObjectiveGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ObjectiveGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ObjectiveGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ObjectiveGroupByOutputType[P]>
            : GetScalarType<T[P], ObjectiveGroupByOutputType[P]>
        }
      >
    >


  export type ObjectiveSelect = {
    id?: boolean
    team?: boolean | TeamArgs
    teamId?: boolean
    first?: boolean
    kills?: boolean
    type?: boolean
  }

  export type ObjectiveInclude = {
    team?: boolean | TeamArgs
  }

  export type ObjectiveGetPayload<
    S extends boolean | null | undefined | ObjectiveArgs,
    U = keyof S
      > = S extends true
        ? Objective
    : S extends undefined
    ? never
    : S extends ObjectiveArgs | ObjectiveFindManyArgs
    ?'include' extends U
    ? Objective  & {
    [P in TrueKeys<S['include']>]:
        P extends 'team' ? TeamGetPayload<S['include'][P]> | null :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'team' ? TeamGetPayload<S['select'][P]> | null :  P extends keyof Objective ? Objective[P] : never
  } 
    : Objective
  : Objective


  type ObjectiveCountArgs = Merge<
    Omit<ObjectiveFindManyArgs, 'select' | 'include'> & {
      select?: ObjectiveCountAggregateInputType | true
    }
  >

  export interface ObjectiveDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Objective that matches the filter.
     * @param {ObjectiveFindUniqueArgs} args - Arguments to find a Objective
     * @example
     * // Get one Objective
     * const objective = await prisma.objective.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ObjectiveFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ObjectiveFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Objective'> extends True ? CheckSelect<T, Prisma__ObjectiveClient<Objective>, Prisma__ObjectiveClient<ObjectiveGetPayload<T>>> : CheckSelect<T, Prisma__ObjectiveClient<Objective | null >, Prisma__ObjectiveClient<ObjectiveGetPayload<T> | null >>

    /**
     * Find the first Objective that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjectiveFindFirstArgs} args - Arguments to find a Objective
     * @example
     * // Get one Objective
     * const objective = await prisma.objective.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ObjectiveFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ObjectiveFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Objective'> extends True ? CheckSelect<T, Prisma__ObjectiveClient<Objective>, Prisma__ObjectiveClient<ObjectiveGetPayload<T>>> : CheckSelect<T, Prisma__ObjectiveClient<Objective | null >, Prisma__ObjectiveClient<ObjectiveGetPayload<T> | null >>

    /**
     * Find zero or more Objectives that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjectiveFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Objectives
     * const objectives = await prisma.objective.findMany()
     * 
     * // Get first 10 Objectives
     * const objectives = await prisma.objective.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const objectiveWithIdOnly = await prisma.objective.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ObjectiveFindManyArgs>(
      args?: SelectSubset<T, ObjectiveFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Objective>>, PrismaPromise<Array<ObjectiveGetPayload<T>>>>

    /**
     * Create a Objective.
     * @param {ObjectiveCreateArgs} args - Arguments to create a Objective.
     * @example
     * // Create one Objective
     * const Objective = await prisma.objective.create({
     *   data: {
     *     // ... data to create a Objective
     *   }
     * })
     * 
    **/
    create<T extends ObjectiveCreateArgs>(
      args: SelectSubset<T, ObjectiveCreateArgs>
    ): CheckSelect<T, Prisma__ObjectiveClient<Objective>, Prisma__ObjectiveClient<ObjectiveGetPayload<T>>>

    /**
     * Create many Objectives.
     *     @param {ObjectiveCreateManyArgs} args - Arguments to create many Objectives.
     *     @example
     *     // Create many Objectives
     *     const objective = await prisma.objective.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ObjectiveCreateManyArgs>(
      args?: SelectSubset<T, ObjectiveCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Objective.
     * @param {ObjectiveDeleteArgs} args - Arguments to delete one Objective.
     * @example
     * // Delete one Objective
     * const Objective = await prisma.objective.delete({
     *   where: {
     *     // ... filter to delete one Objective
     *   }
     * })
     * 
    **/
    delete<T extends ObjectiveDeleteArgs>(
      args: SelectSubset<T, ObjectiveDeleteArgs>
    ): CheckSelect<T, Prisma__ObjectiveClient<Objective>, Prisma__ObjectiveClient<ObjectiveGetPayload<T>>>

    /**
     * Update one Objective.
     * @param {ObjectiveUpdateArgs} args - Arguments to update one Objective.
     * @example
     * // Update one Objective
     * const objective = await prisma.objective.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ObjectiveUpdateArgs>(
      args: SelectSubset<T, ObjectiveUpdateArgs>
    ): CheckSelect<T, Prisma__ObjectiveClient<Objective>, Prisma__ObjectiveClient<ObjectiveGetPayload<T>>>

    /**
     * Delete zero or more Objectives.
     * @param {ObjectiveDeleteManyArgs} args - Arguments to filter Objectives to delete.
     * @example
     * // Delete a few Objectives
     * const { count } = await prisma.objective.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ObjectiveDeleteManyArgs>(
      args?: SelectSubset<T, ObjectiveDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Objectives.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjectiveUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Objectives
     * const objective = await prisma.objective.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ObjectiveUpdateManyArgs>(
      args: SelectSubset<T, ObjectiveUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Objective.
     * @param {ObjectiveUpsertArgs} args - Arguments to update or create a Objective.
     * @example
     * // Update or create a Objective
     * const objective = await prisma.objective.upsert({
     *   create: {
     *     // ... data to create a Objective
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Objective we want to update
     *   }
     * })
    **/
    upsert<T extends ObjectiveUpsertArgs>(
      args: SelectSubset<T, ObjectiveUpsertArgs>
    ): CheckSelect<T, Prisma__ObjectiveClient<Objective>, Prisma__ObjectiveClient<ObjectiveGetPayload<T>>>

    /**
     * Count the number of Objectives.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjectiveCountArgs} args - Arguments to filter Objectives to count.
     * @example
     * // Count the number of Objectives
     * const count = await prisma.objective.count({
     *   where: {
     *     // ... the filter for the Objectives we want to count
     *   }
     * })
    **/
    count<T extends ObjectiveCountArgs>(
      args?: Subset<T, ObjectiveCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ObjectiveCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Objective.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjectiveAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ObjectiveAggregateArgs>(args: Subset<T, ObjectiveAggregateArgs>): PrismaPromise<GetObjectiveAggregateType<T>>

    /**
     * Group by Objective.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjectiveGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ObjectiveGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ObjectiveGroupByArgs['orderBy'] }
        : { orderBy?: ObjectiveGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ObjectiveGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetObjectiveGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Objective.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ObjectiveClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    team<T extends TeamArgs = {}>(args?: Subset<T, TeamArgs>): CheckSelect<T, Prisma__TeamClient<Team | null >, Prisma__TeamClient<TeamGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Objective findUnique
   */
  export type ObjectiveFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Objective
     * 
    **/
    select?: ObjectiveSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ObjectiveInclude | null
    /**
     * Throw an Error if a Objective can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Objective to fetch.
     * 
    **/
    where: ObjectiveWhereUniqueInput
  }


  /**
   * Objective findFirst
   */
  export type ObjectiveFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Objective
     * 
    **/
    select?: ObjectiveSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ObjectiveInclude | null
    /**
     * Throw an Error if a Objective can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Objective to fetch.
     * 
    **/
    where?: ObjectiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Objectives to fetch.
     * 
    **/
    orderBy?: Enumerable<ObjectiveOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Objectives.
     * 
    **/
    cursor?: ObjectiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Objectives from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Objectives.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Objectives.
     * 
    **/
    distinct?: Enumerable<ObjectiveScalarFieldEnum>
  }


  /**
   * Objective findMany
   */
  export type ObjectiveFindManyArgs = {
    /**
     * Select specific fields to fetch from the Objective
     * 
    **/
    select?: ObjectiveSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ObjectiveInclude | null
    /**
     * Filter, which Objectives to fetch.
     * 
    **/
    where?: ObjectiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Objectives to fetch.
     * 
    **/
    orderBy?: Enumerable<ObjectiveOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Objectives.
     * 
    **/
    cursor?: ObjectiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Objectives from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Objectives.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ObjectiveScalarFieldEnum>
  }


  /**
   * Objective create
   */
  export type ObjectiveCreateArgs = {
    /**
     * Select specific fields to fetch from the Objective
     * 
    **/
    select?: ObjectiveSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ObjectiveInclude | null
    /**
     * The data needed to create a Objective.
     * 
    **/
    data: XOR<ObjectiveCreateInput, ObjectiveUncheckedCreateInput>
  }


  /**
   * Objective createMany
   */
  export type ObjectiveCreateManyArgs = {
    /**
     * The data used to create many Objectives.
     * 
    **/
    data: Enumerable<ObjectiveCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Objective update
   */
  export type ObjectiveUpdateArgs = {
    /**
     * Select specific fields to fetch from the Objective
     * 
    **/
    select?: ObjectiveSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ObjectiveInclude | null
    /**
     * The data needed to update a Objective.
     * 
    **/
    data: XOR<ObjectiveUpdateInput, ObjectiveUncheckedUpdateInput>
    /**
     * Choose, which Objective to update.
     * 
    **/
    where: ObjectiveWhereUniqueInput
  }


  /**
   * Objective updateMany
   */
  export type ObjectiveUpdateManyArgs = {
    /**
     * The data used to update Objectives.
     * 
    **/
    data: XOR<ObjectiveUpdateManyMutationInput, ObjectiveUncheckedUpdateManyInput>
    /**
     * Filter which Objectives to update
     * 
    **/
    where?: ObjectiveWhereInput
  }


  /**
   * Objective upsert
   */
  export type ObjectiveUpsertArgs = {
    /**
     * Select specific fields to fetch from the Objective
     * 
    **/
    select?: ObjectiveSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ObjectiveInclude | null
    /**
     * The filter to search for the Objective to update in case it exists.
     * 
    **/
    where: ObjectiveWhereUniqueInput
    /**
     * In case the Objective found by the `where` argument doesn't exist, create a new Objective with this data.
     * 
    **/
    create: XOR<ObjectiveCreateInput, ObjectiveUncheckedCreateInput>
    /**
     * In case the Objective was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ObjectiveUpdateInput, ObjectiveUncheckedUpdateInput>
  }


  /**
   * Objective delete
   */
  export type ObjectiveDeleteArgs = {
    /**
     * Select specific fields to fetch from the Objective
     * 
    **/
    select?: ObjectiveSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ObjectiveInclude | null
    /**
     * Filter which Objective to delete.
     * 
    **/
    where: ObjectiveWhereUniqueInput
  }


  /**
   * Objective deleteMany
   */
  export type ObjectiveDeleteManyArgs = {
    /**
     * Filter which Objectives to delete
     * 
    **/
    where?: ObjectiveWhereInput
  }


  /**
   * Objective without action
   */
  export type ObjectiveArgs = {
    /**
     * Select specific fields to fetch from the Objective
     * 
    **/
    select?: ObjectiveSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ObjectiveInclude | null
  }



  /**
   * Model PickBan
   */


  export type AggregatePickBan = {
    _count: PickBanCountAggregateOutputType | null
    _avg: PickBanAvgAggregateOutputType | null
    _sum: PickBanSumAggregateOutputType | null
    _min: PickBanMinAggregateOutputType | null
    _max: PickBanMaxAggregateOutputType | null
  }

  export type PickBanAvgAggregateOutputType = {
    championId: number | null
    pickTurn: number | null
  }

  export type PickBanSumAggregateOutputType = {
    championId: number | null
    pickTurn: number | null
  }

  export type PickBanMinAggregateOutputType = {
    id: string | null
    teamId: string | null
    championId: number | null
    pickTurn: number | null
  }

  export type PickBanMaxAggregateOutputType = {
    id: string | null
    teamId: string | null
    championId: number | null
    pickTurn: number | null
  }

  export type PickBanCountAggregateOutputType = {
    id: number
    teamId: number
    championId: number
    pickTurn: number
    _all: number
  }


  export type PickBanAvgAggregateInputType = {
    championId?: true
    pickTurn?: true
  }

  export type PickBanSumAggregateInputType = {
    championId?: true
    pickTurn?: true
  }

  export type PickBanMinAggregateInputType = {
    id?: true
    teamId?: true
    championId?: true
    pickTurn?: true
  }

  export type PickBanMaxAggregateInputType = {
    id?: true
    teamId?: true
    championId?: true
    pickTurn?: true
  }

  export type PickBanCountAggregateInputType = {
    id?: true
    teamId?: true
    championId?: true
    pickTurn?: true
    _all?: true
  }

  export type PickBanAggregateArgs = {
    /**
     * Filter which PickBan to aggregate.
     * 
    **/
    where?: PickBanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PickBans to fetch.
     * 
    **/
    orderBy?: Enumerable<PickBanOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: PickBanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PickBans from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PickBans.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PickBans
    **/
    _count?: true | PickBanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PickBanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PickBanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PickBanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PickBanMaxAggregateInputType
  }

  export type GetPickBanAggregateType<T extends PickBanAggregateArgs> = {
        [P in keyof T & keyof AggregatePickBan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePickBan[P]>
      : GetScalarType<T[P], AggregatePickBan[P]>
  }




  export type PickBanGroupByArgs = {
    where?: PickBanWhereInput
    orderBy?: Enumerable<PickBanOrderByWithAggregationInput>
    by: Array<PickBanScalarFieldEnum>
    having?: PickBanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PickBanCountAggregateInputType | true
    _avg?: PickBanAvgAggregateInputType
    _sum?: PickBanSumAggregateInputType
    _min?: PickBanMinAggregateInputType
    _max?: PickBanMaxAggregateInputType
  }


  export type PickBanGroupByOutputType = {
    id: string
    teamId: string | null
    championId: number | null
    pickTurn: number | null
    _count: PickBanCountAggregateOutputType | null
    _avg: PickBanAvgAggregateOutputType | null
    _sum: PickBanSumAggregateOutputType | null
    _min: PickBanMinAggregateOutputType | null
    _max: PickBanMaxAggregateOutputType | null
  }

  type GetPickBanGroupByPayload<T extends PickBanGroupByArgs> = PrismaPromise<
    Array<
      PickArray<PickBanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PickBanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PickBanGroupByOutputType[P]>
            : GetScalarType<T[P], PickBanGroupByOutputType[P]>
        }
      >
    >


  export type PickBanSelect = {
    id?: boolean
    team?: boolean | TeamArgs
    teamId?: boolean
    championId?: boolean
    pickTurn?: boolean
  }

  export type PickBanInclude = {
    team?: boolean | TeamArgs
  }

  export type PickBanGetPayload<
    S extends boolean | null | undefined | PickBanArgs,
    U = keyof S
      > = S extends true
        ? PickBan
    : S extends undefined
    ? never
    : S extends PickBanArgs | PickBanFindManyArgs
    ?'include' extends U
    ? PickBan  & {
    [P in TrueKeys<S['include']>]:
        P extends 'team' ? TeamGetPayload<S['include'][P]> | null :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'team' ? TeamGetPayload<S['select'][P]> | null :  P extends keyof PickBan ? PickBan[P] : never
  } 
    : PickBan
  : PickBan


  type PickBanCountArgs = Merge<
    Omit<PickBanFindManyArgs, 'select' | 'include'> & {
      select?: PickBanCountAggregateInputType | true
    }
  >

  export interface PickBanDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one PickBan that matches the filter.
     * @param {PickBanFindUniqueArgs} args - Arguments to find a PickBan
     * @example
     * // Get one PickBan
     * const pickBan = await prisma.pickBan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PickBanFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PickBanFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'PickBan'> extends True ? CheckSelect<T, Prisma__PickBanClient<PickBan>, Prisma__PickBanClient<PickBanGetPayload<T>>> : CheckSelect<T, Prisma__PickBanClient<PickBan | null >, Prisma__PickBanClient<PickBanGetPayload<T> | null >>

    /**
     * Find the first PickBan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PickBanFindFirstArgs} args - Arguments to find a PickBan
     * @example
     * // Get one PickBan
     * const pickBan = await prisma.pickBan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PickBanFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PickBanFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'PickBan'> extends True ? CheckSelect<T, Prisma__PickBanClient<PickBan>, Prisma__PickBanClient<PickBanGetPayload<T>>> : CheckSelect<T, Prisma__PickBanClient<PickBan | null >, Prisma__PickBanClient<PickBanGetPayload<T> | null >>

    /**
     * Find zero or more PickBans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PickBanFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PickBans
     * const pickBans = await prisma.pickBan.findMany()
     * 
     * // Get first 10 PickBans
     * const pickBans = await prisma.pickBan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pickBanWithIdOnly = await prisma.pickBan.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PickBanFindManyArgs>(
      args?: SelectSubset<T, PickBanFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<PickBan>>, PrismaPromise<Array<PickBanGetPayload<T>>>>

    /**
     * Create a PickBan.
     * @param {PickBanCreateArgs} args - Arguments to create a PickBan.
     * @example
     * // Create one PickBan
     * const PickBan = await prisma.pickBan.create({
     *   data: {
     *     // ... data to create a PickBan
     *   }
     * })
     * 
    **/
    create<T extends PickBanCreateArgs>(
      args: SelectSubset<T, PickBanCreateArgs>
    ): CheckSelect<T, Prisma__PickBanClient<PickBan>, Prisma__PickBanClient<PickBanGetPayload<T>>>

    /**
     * Create many PickBans.
     *     @param {PickBanCreateManyArgs} args - Arguments to create many PickBans.
     *     @example
     *     // Create many PickBans
     *     const pickBan = await prisma.pickBan.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PickBanCreateManyArgs>(
      args?: SelectSubset<T, PickBanCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a PickBan.
     * @param {PickBanDeleteArgs} args - Arguments to delete one PickBan.
     * @example
     * // Delete one PickBan
     * const PickBan = await prisma.pickBan.delete({
     *   where: {
     *     // ... filter to delete one PickBan
     *   }
     * })
     * 
    **/
    delete<T extends PickBanDeleteArgs>(
      args: SelectSubset<T, PickBanDeleteArgs>
    ): CheckSelect<T, Prisma__PickBanClient<PickBan>, Prisma__PickBanClient<PickBanGetPayload<T>>>

    /**
     * Update one PickBan.
     * @param {PickBanUpdateArgs} args - Arguments to update one PickBan.
     * @example
     * // Update one PickBan
     * const pickBan = await prisma.pickBan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PickBanUpdateArgs>(
      args: SelectSubset<T, PickBanUpdateArgs>
    ): CheckSelect<T, Prisma__PickBanClient<PickBan>, Prisma__PickBanClient<PickBanGetPayload<T>>>

    /**
     * Delete zero or more PickBans.
     * @param {PickBanDeleteManyArgs} args - Arguments to filter PickBans to delete.
     * @example
     * // Delete a few PickBans
     * const { count } = await prisma.pickBan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PickBanDeleteManyArgs>(
      args?: SelectSubset<T, PickBanDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more PickBans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PickBanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PickBans
     * const pickBan = await prisma.pickBan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PickBanUpdateManyArgs>(
      args: SelectSubset<T, PickBanUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one PickBan.
     * @param {PickBanUpsertArgs} args - Arguments to update or create a PickBan.
     * @example
     * // Update or create a PickBan
     * const pickBan = await prisma.pickBan.upsert({
     *   create: {
     *     // ... data to create a PickBan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PickBan we want to update
     *   }
     * })
    **/
    upsert<T extends PickBanUpsertArgs>(
      args: SelectSubset<T, PickBanUpsertArgs>
    ): CheckSelect<T, Prisma__PickBanClient<PickBan>, Prisma__PickBanClient<PickBanGetPayload<T>>>

    /**
     * Count the number of PickBans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PickBanCountArgs} args - Arguments to filter PickBans to count.
     * @example
     * // Count the number of PickBans
     * const count = await prisma.pickBan.count({
     *   where: {
     *     // ... the filter for the PickBans we want to count
     *   }
     * })
    **/
    count<T extends PickBanCountArgs>(
      args?: Subset<T, PickBanCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PickBanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PickBan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PickBanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PickBanAggregateArgs>(args: Subset<T, PickBanAggregateArgs>): PrismaPromise<GetPickBanAggregateType<T>>

    /**
     * Group by PickBan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PickBanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PickBanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PickBanGroupByArgs['orderBy'] }
        : { orderBy?: PickBanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PickBanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPickBanGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for PickBan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PickBanClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    team<T extends TeamArgs = {}>(args?: Subset<T, TeamArgs>): CheckSelect<T, Prisma__TeamClient<Team | null >, Prisma__TeamClient<TeamGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * PickBan findUnique
   */
  export type PickBanFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the PickBan
     * 
    **/
    select?: PickBanSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PickBanInclude | null
    /**
     * Throw an Error if a PickBan can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which PickBan to fetch.
     * 
    **/
    where: PickBanWhereUniqueInput
  }


  /**
   * PickBan findFirst
   */
  export type PickBanFindFirstArgs = {
    /**
     * Select specific fields to fetch from the PickBan
     * 
    **/
    select?: PickBanSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PickBanInclude | null
    /**
     * Throw an Error if a PickBan can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which PickBan to fetch.
     * 
    **/
    where?: PickBanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PickBans to fetch.
     * 
    **/
    orderBy?: Enumerable<PickBanOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PickBans.
     * 
    **/
    cursor?: PickBanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PickBans from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PickBans.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PickBans.
     * 
    **/
    distinct?: Enumerable<PickBanScalarFieldEnum>
  }


  /**
   * PickBan findMany
   */
  export type PickBanFindManyArgs = {
    /**
     * Select specific fields to fetch from the PickBan
     * 
    **/
    select?: PickBanSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PickBanInclude | null
    /**
     * Filter, which PickBans to fetch.
     * 
    **/
    where?: PickBanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PickBans to fetch.
     * 
    **/
    orderBy?: Enumerable<PickBanOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PickBans.
     * 
    **/
    cursor?: PickBanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PickBans from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PickBans.
     * 
    **/
    skip?: number
    distinct?: Enumerable<PickBanScalarFieldEnum>
  }


  /**
   * PickBan create
   */
  export type PickBanCreateArgs = {
    /**
     * Select specific fields to fetch from the PickBan
     * 
    **/
    select?: PickBanSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PickBanInclude | null
    /**
     * The data needed to create a PickBan.
     * 
    **/
    data: XOR<PickBanCreateInput, PickBanUncheckedCreateInput>
  }


  /**
   * PickBan createMany
   */
  export type PickBanCreateManyArgs = {
    /**
     * The data used to create many PickBans.
     * 
    **/
    data: Enumerable<PickBanCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * PickBan update
   */
  export type PickBanUpdateArgs = {
    /**
     * Select specific fields to fetch from the PickBan
     * 
    **/
    select?: PickBanSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PickBanInclude | null
    /**
     * The data needed to update a PickBan.
     * 
    **/
    data: XOR<PickBanUpdateInput, PickBanUncheckedUpdateInput>
    /**
     * Choose, which PickBan to update.
     * 
    **/
    where: PickBanWhereUniqueInput
  }


  /**
   * PickBan updateMany
   */
  export type PickBanUpdateManyArgs = {
    /**
     * The data used to update PickBans.
     * 
    **/
    data: XOR<PickBanUpdateManyMutationInput, PickBanUncheckedUpdateManyInput>
    /**
     * Filter which PickBans to update
     * 
    **/
    where?: PickBanWhereInput
  }


  /**
   * PickBan upsert
   */
  export type PickBanUpsertArgs = {
    /**
     * Select specific fields to fetch from the PickBan
     * 
    **/
    select?: PickBanSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PickBanInclude | null
    /**
     * The filter to search for the PickBan to update in case it exists.
     * 
    **/
    where: PickBanWhereUniqueInput
    /**
     * In case the PickBan found by the `where` argument doesn't exist, create a new PickBan with this data.
     * 
    **/
    create: XOR<PickBanCreateInput, PickBanUncheckedCreateInput>
    /**
     * In case the PickBan was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<PickBanUpdateInput, PickBanUncheckedUpdateInput>
  }


  /**
   * PickBan delete
   */
  export type PickBanDeleteArgs = {
    /**
     * Select specific fields to fetch from the PickBan
     * 
    **/
    select?: PickBanSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PickBanInclude | null
    /**
     * Filter which PickBan to delete.
     * 
    **/
    where: PickBanWhereUniqueInput
  }


  /**
   * PickBan deleteMany
   */
  export type PickBanDeleteManyArgs = {
    /**
     * Filter which PickBans to delete
     * 
    **/
    where?: PickBanWhereInput
  }


  /**
   * PickBan without action
   */
  export type PickBanArgs = {
    /**
     * Select specific fields to fetch from the PickBan
     * 
    **/
    select?: PickBanSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PickBanInclude | null
  }



  /**
   * Model Player
   */


  export type AggregatePlayer = {
    _count: PlayerCountAggregateOutputType | null
    _avg: PlayerAvgAggregateOutputType | null
    _sum: PlayerSumAggregateOutputType | null
    _min: PlayerMinAggregateOutputType | null
    _max: PlayerMaxAggregateOutputType | null
  }

  export type PlayerAvgAggregateOutputType = {
    summonerLevel: number | null
    profileIconId: number | null
  }

  export type PlayerSumAggregateOutputType = {
    summonerLevel: number | null
    profileIconId: number | null
  }

  export type PlayerMinAggregateOutputType = {
    id: string | null
    puuid: string | null
    accountId: string | null
    platformId: string | null
    summonerId: string | null
    summonerName: string | null
    summonerLevel: number | null
    profileIconId: number | null
    revisionDate: string | null
    profileId: string | null
  }

  export type PlayerMaxAggregateOutputType = {
    id: string | null
    puuid: string | null
    accountId: string | null
    platformId: string | null
    summonerId: string | null
    summonerName: string | null
    summonerLevel: number | null
    profileIconId: number | null
    revisionDate: string | null
    profileId: string | null
  }

  export type PlayerCountAggregateOutputType = {
    id: number
    puuid: number
    accountId: number
    platformId: number
    summonerId: number
    summonerName: number
    summonerLevel: number
    profileIconId: number
    revisionDate: number
    profileId: number
    _all: number
  }


  export type PlayerAvgAggregateInputType = {
    summonerLevel?: true
    profileIconId?: true
  }

  export type PlayerSumAggregateInputType = {
    summonerLevel?: true
    profileIconId?: true
  }

  export type PlayerMinAggregateInputType = {
    id?: true
    puuid?: true
    accountId?: true
    platformId?: true
    summonerId?: true
    summonerName?: true
    summonerLevel?: true
    profileIconId?: true
    revisionDate?: true
    profileId?: true
  }

  export type PlayerMaxAggregateInputType = {
    id?: true
    puuid?: true
    accountId?: true
    platformId?: true
    summonerId?: true
    summonerName?: true
    summonerLevel?: true
    profileIconId?: true
    revisionDate?: true
    profileId?: true
  }

  export type PlayerCountAggregateInputType = {
    id?: true
    puuid?: true
    accountId?: true
    platformId?: true
    summonerId?: true
    summonerName?: true
    summonerLevel?: true
    profileIconId?: true
    revisionDate?: true
    profileId?: true
    _all?: true
  }

  export type PlayerAggregateArgs = {
    /**
     * Filter which Player to aggregate.
     * 
    **/
    where?: PlayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Players to fetch.
     * 
    **/
    orderBy?: Enumerable<PlayerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: PlayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Players from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Players.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Players
    **/
    _count?: true | PlayerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlayerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlayerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlayerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlayerMaxAggregateInputType
  }

  export type GetPlayerAggregateType<T extends PlayerAggregateArgs> = {
        [P in keyof T & keyof AggregatePlayer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlayer[P]>
      : GetScalarType<T[P], AggregatePlayer[P]>
  }




  export type PlayerGroupByArgs = {
    where?: PlayerWhereInput
    orderBy?: Enumerable<PlayerOrderByWithAggregationInput>
    by: Array<PlayerScalarFieldEnum>
    having?: PlayerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlayerCountAggregateInputType | true
    _avg?: PlayerAvgAggregateInputType
    _sum?: PlayerSumAggregateInputType
    _min?: PlayerMinAggregateInputType
    _max?: PlayerMaxAggregateInputType
  }


  export type PlayerGroupByOutputType = {
    id: string
    puuid: string
    accountId: string
    platformId: string
    summonerId: string
    summonerName: string
    summonerLevel: number | null
    profileIconId: number | null
    revisionDate: string
    profileId: string | null
    _count: PlayerCountAggregateOutputType | null
    _avg: PlayerAvgAggregateOutputType | null
    _sum: PlayerSumAggregateOutputType | null
    _min: PlayerMinAggregateOutputType | null
    _max: PlayerMaxAggregateOutputType | null
  }

  type GetPlayerGroupByPayload<T extends PlayerGroupByArgs> = PrismaPromise<
    Array<
      PickArray<PlayerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlayerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlayerGroupByOutputType[P]>
            : GetScalarType<T[P], PlayerGroupByOutputType[P]>
        }
      >
    >


  export type PlayerSelect = {
    id?: boolean
    puuid?: boolean
    accountId?: boolean
    platformId?: boolean
    summonerId?: boolean
    summonerName?: boolean
    summonerLevel?: boolean
    profileIconId?: boolean
    revisionDate?: boolean
    kills?: boolean | PlayerKillFindManyArgs
    deaths?: boolean | PlayerKillFindManyArgs
    teams?: boolean | TeamFindManyArgs
    profile?: boolean | ProfileArgs
    profileId?: boolean
    monsterKills?: boolean | TeamMonsterKillFindManyArgs
    buildingKills?: boolean | TeamBuildingKillFindManyArgs
    itemEvent?: boolean | PlayerItemEventFindManyArgs
    endOfGameStats?: boolean | PlayerEndOfGameStatFindManyArgs
    snapshots?: boolean | PlayerSnapshotFindManyArgs
    wardEvents?: boolean | PlayerWardEventFindManyArgs
    skillLevelUpEvents?: boolean | PlayerSkillLevelUpEventFindManyArgs
    _count?: boolean | PlayerCountOutputTypeArgs
  }

  export type PlayerInclude = {
    kills?: boolean | PlayerKillFindManyArgs
    deaths?: boolean | PlayerKillFindManyArgs
    teams?: boolean | TeamFindManyArgs
    profile?: boolean | ProfileArgs
    monsterKills?: boolean | TeamMonsterKillFindManyArgs
    buildingKills?: boolean | TeamBuildingKillFindManyArgs
    itemEvent?: boolean | PlayerItemEventFindManyArgs
    endOfGameStats?: boolean | PlayerEndOfGameStatFindManyArgs
    snapshots?: boolean | PlayerSnapshotFindManyArgs
    wardEvents?: boolean | PlayerWardEventFindManyArgs
    skillLevelUpEvents?: boolean | PlayerSkillLevelUpEventFindManyArgs
    _count?: boolean | PlayerCountOutputTypeArgs
  }

  export type PlayerGetPayload<
    S extends boolean | null | undefined | PlayerArgs,
    U = keyof S
      > = S extends true
        ? Player
    : S extends undefined
    ? never
    : S extends PlayerArgs | PlayerFindManyArgs
    ?'include' extends U
    ? Player  & {
    [P in TrueKeys<S['include']>]:
        P extends 'kills' ? Array < PlayerKillGetPayload<S['include'][P]>>  :
        P extends 'deaths' ? Array < PlayerKillGetPayload<S['include'][P]>>  :
        P extends 'teams' ? Array < TeamGetPayload<S['include'][P]>>  :
        P extends 'profile' ? ProfileGetPayload<S['include'][P]> | null :
        P extends 'monsterKills' ? Array < TeamMonsterKillGetPayload<S['include'][P]>>  :
        P extends 'buildingKills' ? Array < TeamBuildingKillGetPayload<S['include'][P]>>  :
        P extends 'itemEvent' ? Array < PlayerItemEventGetPayload<S['include'][P]>>  :
        P extends 'endOfGameStats' ? Array < PlayerEndOfGameStatGetPayload<S['include'][P]>>  :
        P extends 'snapshots' ? Array < PlayerSnapshotGetPayload<S['include'][P]>>  :
        P extends 'wardEvents' ? Array < PlayerWardEventGetPayload<S['include'][P]>>  :
        P extends 'skillLevelUpEvents' ? Array < PlayerSkillLevelUpEventGetPayload<S['include'][P]>>  :
        P extends '_count' ? PlayerCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'kills' ? Array < PlayerKillGetPayload<S['select'][P]>>  :
        P extends 'deaths' ? Array < PlayerKillGetPayload<S['select'][P]>>  :
        P extends 'teams' ? Array < TeamGetPayload<S['select'][P]>>  :
        P extends 'profile' ? ProfileGetPayload<S['select'][P]> | null :
        P extends 'monsterKills' ? Array < TeamMonsterKillGetPayload<S['select'][P]>>  :
        P extends 'buildingKills' ? Array < TeamBuildingKillGetPayload<S['select'][P]>>  :
        P extends 'itemEvent' ? Array < PlayerItemEventGetPayload<S['select'][P]>>  :
        P extends 'endOfGameStats' ? Array < PlayerEndOfGameStatGetPayload<S['select'][P]>>  :
        P extends 'snapshots' ? Array < PlayerSnapshotGetPayload<S['select'][P]>>  :
        P extends 'wardEvents' ? Array < PlayerWardEventGetPayload<S['select'][P]>>  :
        P extends 'skillLevelUpEvents' ? Array < PlayerSkillLevelUpEventGetPayload<S['select'][P]>>  :
        P extends '_count' ? PlayerCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Player ? Player[P] : never
  } 
    : Player
  : Player


  type PlayerCountArgs = Merge<
    Omit<PlayerFindManyArgs, 'select' | 'include'> & {
      select?: PlayerCountAggregateInputType | true
    }
  >

  export interface PlayerDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Player that matches the filter.
     * @param {PlayerFindUniqueArgs} args - Arguments to find a Player
     * @example
     * // Get one Player
     * const player = await prisma.player.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PlayerFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PlayerFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Player'> extends True ? CheckSelect<T, Prisma__PlayerClient<Player>, Prisma__PlayerClient<PlayerGetPayload<T>>> : CheckSelect<T, Prisma__PlayerClient<Player | null >, Prisma__PlayerClient<PlayerGetPayload<T> | null >>

    /**
     * Find the first Player that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerFindFirstArgs} args - Arguments to find a Player
     * @example
     * // Get one Player
     * const player = await prisma.player.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PlayerFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PlayerFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Player'> extends True ? CheckSelect<T, Prisma__PlayerClient<Player>, Prisma__PlayerClient<PlayerGetPayload<T>>> : CheckSelect<T, Prisma__PlayerClient<Player | null >, Prisma__PlayerClient<PlayerGetPayload<T> | null >>

    /**
     * Find zero or more Players that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Players
     * const players = await prisma.player.findMany()
     * 
     * // Get first 10 Players
     * const players = await prisma.player.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const playerWithIdOnly = await prisma.player.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PlayerFindManyArgs>(
      args?: SelectSubset<T, PlayerFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Player>>, PrismaPromise<Array<PlayerGetPayload<T>>>>

    /**
     * Create a Player.
     * @param {PlayerCreateArgs} args - Arguments to create a Player.
     * @example
     * // Create one Player
     * const Player = await prisma.player.create({
     *   data: {
     *     // ... data to create a Player
     *   }
     * })
     * 
    **/
    create<T extends PlayerCreateArgs>(
      args: SelectSubset<T, PlayerCreateArgs>
    ): CheckSelect<T, Prisma__PlayerClient<Player>, Prisma__PlayerClient<PlayerGetPayload<T>>>

    /**
     * Create many Players.
     *     @param {PlayerCreateManyArgs} args - Arguments to create many Players.
     *     @example
     *     // Create many Players
     *     const player = await prisma.player.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PlayerCreateManyArgs>(
      args?: SelectSubset<T, PlayerCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Player.
     * @param {PlayerDeleteArgs} args - Arguments to delete one Player.
     * @example
     * // Delete one Player
     * const Player = await prisma.player.delete({
     *   where: {
     *     // ... filter to delete one Player
     *   }
     * })
     * 
    **/
    delete<T extends PlayerDeleteArgs>(
      args: SelectSubset<T, PlayerDeleteArgs>
    ): CheckSelect<T, Prisma__PlayerClient<Player>, Prisma__PlayerClient<PlayerGetPayload<T>>>

    /**
     * Update one Player.
     * @param {PlayerUpdateArgs} args - Arguments to update one Player.
     * @example
     * // Update one Player
     * const player = await prisma.player.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PlayerUpdateArgs>(
      args: SelectSubset<T, PlayerUpdateArgs>
    ): CheckSelect<T, Prisma__PlayerClient<Player>, Prisma__PlayerClient<PlayerGetPayload<T>>>

    /**
     * Delete zero or more Players.
     * @param {PlayerDeleteManyArgs} args - Arguments to filter Players to delete.
     * @example
     * // Delete a few Players
     * const { count } = await prisma.player.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PlayerDeleteManyArgs>(
      args?: SelectSubset<T, PlayerDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Players.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Players
     * const player = await prisma.player.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PlayerUpdateManyArgs>(
      args: SelectSubset<T, PlayerUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Player.
     * @param {PlayerUpsertArgs} args - Arguments to update or create a Player.
     * @example
     * // Update or create a Player
     * const player = await prisma.player.upsert({
     *   create: {
     *     // ... data to create a Player
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Player we want to update
     *   }
     * })
    **/
    upsert<T extends PlayerUpsertArgs>(
      args: SelectSubset<T, PlayerUpsertArgs>
    ): CheckSelect<T, Prisma__PlayerClient<Player>, Prisma__PlayerClient<PlayerGetPayload<T>>>

    /**
     * Count the number of Players.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerCountArgs} args - Arguments to filter Players to count.
     * @example
     * // Count the number of Players
     * const count = await prisma.player.count({
     *   where: {
     *     // ... the filter for the Players we want to count
     *   }
     * })
    **/
    count<T extends PlayerCountArgs>(
      args?: Subset<T, PlayerCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlayerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Player.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlayerAggregateArgs>(args: Subset<T, PlayerAggregateArgs>): PrismaPromise<GetPlayerAggregateType<T>>

    /**
     * Group by Player.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlayerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlayerGroupByArgs['orderBy'] }
        : { orderBy?: PlayerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlayerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlayerGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Player.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PlayerClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    kills<T extends PlayerKillFindManyArgs = {}>(args?: Subset<T, PlayerKillFindManyArgs>): CheckSelect<T, PrismaPromise<Array<PlayerKill>>, PrismaPromise<Array<PlayerKillGetPayload<T>>>>;

    deaths<T extends PlayerKillFindManyArgs = {}>(args?: Subset<T, PlayerKillFindManyArgs>): CheckSelect<T, PrismaPromise<Array<PlayerKill>>, PrismaPromise<Array<PlayerKillGetPayload<T>>>>;

    teams<T extends TeamFindManyArgs = {}>(args?: Subset<T, TeamFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Team>>, PrismaPromise<Array<TeamGetPayload<T>>>>;

    profile<T extends ProfileArgs = {}>(args?: Subset<T, ProfileArgs>): CheckSelect<T, Prisma__ProfileClient<Profile | null >, Prisma__ProfileClient<ProfileGetPayload<T> | null >>;

    monsterKills<T extends TeamMonsterKillFindManyArgs = {}>(args?: Subset<T, TeamMonsterKillFindManyArgs>): CheckSelect<T, PrismaPromise<Array<TeamMonsterKill>>, PrismaPromise<Array<TeamMonsterKillGetPayload<T>>>>;

    buildingKills<T extends TeamBuildingKillFindManyArgs = {}>(args?: Subset<T, TeamBuildingKillFindManyArgs>): CheckSelect<T, PrismaPromise<Array<TeamBuildingKill>>, PrismaPromise<Array<TeamBuildingKillGetPayload<T>>>>;

    itemEvent<T extends PlayerItemEventFindManyArgs = {}>(args?: Subset<T, PlayerItemEventFindManyArgs>): CheckSelect<T, PrismaPromise<Array<PlayerItemEvent>>, PrismaPromise<Array<PlayerItemEventGetPayload<T>>>>;

    endOfGameStats<T extends PlayerEndOfGameStatFindManyArgs = {}>(args?: Subset<T, PlayerEndOfGameStatFindManyArgs>): CheckSelect<T, PrismaPromise<Array<PlayerEndOfGameStat>>, PrismaPromise<Array<PlayerEndOfGameStatGetPayload<T>>>>;

    snapshots<T extends PlayerSnapshotFindManyArgs = {}>(args?: Subset<T, PlayerSnapshotFindManyArgs>): CheckSelect<T, PrismaPromise<Array<PlayerSnapshot>>, PrismaPromise<Array<PlayerSnapshotGetPayload<T>>>>;

    wardEvents<T extends PlayerWardEventFindManyArgs = {}>(args?: Subset<T, PlayerWardEventFindManyArgs>): CheckSelect<T, PrismaPromise<Array<PlayerWardEvent>>, PrismaPromise<Array<PlayerWardEventGetPayload<T>>>>;

    skillLevelUpEvents<T extends PlayerSkillLevelUpEventFindManyArgs = {}>(args?: Subset<T, PlayerSkillLevelUpEventFindManyArgs>): CheckSelect<T, PrismaPromise<Array<PlayerSkillLevelUpEvent>>, PrismaPromise<Array<PlayerSkillLevelUpEventGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Player findUnique
   */
  export type PlayerFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Player
     * 
    **/
    select?: PlayerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PlayerInclude | null
    /**
     * Throw an Error if a Player can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Player to fetch.
     * 
    **/
    where: PlayerWhereUniqueInput
  }


  /**
   * Player findFirst
   */
  export type PlayerFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Player
     * 
    **/
    select?: PlayerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PlayerInclude | null
    /**
     * Throw an Error if a Player can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Player to fetch.
     * 
    **/
    where?: PlayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Players to fetch.
     * 
    **/
    orderBy?: Enumerable<PlayerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Players.
     * 
    **/
    cursor?: PlayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Players from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Players.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Players.
     * 
    **/
    distinct?: Enumerable<PlayerScalarFieldEnum>
  }


  /**
   * Player findMany
   */
  export type PlayerFindManyArgs = {
    /**
     * Select specific fields to fetch from the Player
     * 
    **/
    select?: PlayerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PlayerInclude | null
    /**
     * Filter, which Players to fetch.
     * 
    **/
    where?: PlayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Players to fetch.
     * 
    **/
    orderBy?: Enumerable<PlayerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Players.
     * 
    **/
    cursor?: PlayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Players from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Players.
     * 
    **/
    skip?: number
    distinct?: Enumerable<PlayerScalarFieldEnum>
  }


  /**
   * Player create
   */
  export type PlayerCreateArgs = {
    /**
     * Select specific fields to fetch from the Player
     * 
    **/
    select?: PlayerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PlayerInclude | null
    /**
     * The data needed to create a Player.
     * 
    **/
    data: XOR<PlayerCreateInput, PlayerUncheckedCreateInput>
  }


  /**
   * Player createMany
   */
  export type PlayerCreateManyArgs = {
    /**
     * The data used to create many Players.
     * 
    **/
    data: Enumerable<PlayerCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Player update
   */
  export type PlayerUpdateArgs = {
    /**
     * Select specific fields to fetch from the Player
     * 
    **/
    select?: PlayerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PlayerInclude | null
    /**
     * The data needed to update a Player.
     * 
    **/
    data: XOR<PlayerUpdateInput, PlayerUncheckedUpdateInput>
    /**
     * Choose, which Player to update.
     * 
    **/
    where: PlayerWhereUniqueInput
  }


  /**
   * Player updateMany
   */
  export type PlayerUpdateManyArgs = {
    /**
     * The data used to update Players.
     * 
    **/
    data: XOR<PlayerUpdateManyMutationInput, PlayerUncheckedUpdateManyInput>
    /**
     * Filter which Players to update
     * 
    **/
    where?: PlayerWhereInput
  }


  /**
   * Player upsert
   */
  export type PlayerUpsertArgs = {
    /**
     * Select specific fields to fetch from the Player
     * 
    **/
    select?: PlayerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PlayerInclude | null
    /**
     * The filter to search for the Player to update in case it exists.
     * 
    **/
    where: PlayerWhereUniqueInput
    /**
     * In case the Player found by the `where` argument doesn't exist, create a new Player with this data.
     * 
    **/
    create: XOR<PlayerCreateInput, PlayerUncheckedCreateInput>
    /**
     * In case the Player was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<PlayerUpdateInput, PlayerUncheckedUpdateInput>
  }


  /**
   * Player delete
   */
  export type PlayerDeleteArgs = {
    /**
     * Select specific fields to fetch from the Player
     * 
    **/
    select?: PlayerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PlayerInclude | null
    /**
     * Filter which Player to delete.
     * 
    **/
    where: PlayerWhereUniqueInput
  }


  /**
   * Player deleteMany
   */
  export type PlayerDeleteManyArgs = {
    /**
     * Filter which Players to delete
     * 
    **/
    where?: PlayerWhereInput
  }


  /**
   * Player without action
   */
  export type PlayerArgs = {
    /**
     * Select specific fields to fetch from the Player
     * 
    **/
    select?: PlayerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PlayerInclude | null
  }



  /**
   * Model PlayerEndOfGameStat
   */


  export type AggregatePlayerEndOfGameStat = {
    _count: PlayerEndOfGameStatCountAggregateOutputType | null
    _avg: PlayerEndOfGameStatAvgAggregateOutputType | null
    _sum: PlayerEndOfGameStatSumAggregateOutputType | null
    _min: PlayerEndOfGameStatMinAggregateOutputType | null
    _max: PlayerEndOfGameStatMaxAggregateOutputType | null
  }

  export type PlayerEndOfGameStatAvgAggregateOutputType = {
    assists: number | null
    baronKills: number | null
    bountyLevel: number | null
    championExperience: number | null
    championLevel: number | null
    championId: number | null
    championTransform: number | null
    consumablesPurchased: number | null
    damageDealtToBuildings: number | null
    damageDealtToObjectives: number | null
    damageDealtToTurrets: number | null
    damageSelfMitigated: number | null
    deaths: number | null
    detectorWardsPlaced: number | null
    doubleKills: number | null
    dragonKills: number | null
    goldEarned: number | null
    goldSpent: number | null
    inhibitorKills: number | null
    inhibitorTakedowns: number | null
    inhibitorsLost: number | null
    item0: number | null
    item1: number | null
    item2: number | null
    item3: number | null
    item4: number | null
    item5: number | null
    item6: number | null
    itemsPurchased: number | null
    killingSprees: number | null
    kills: number | null
    largestCriticalStrike: number | null
    largestKillingSpree: number | null
    largestMultiKill: number | null
    longestTimeSpentLiving: number | null
    magicDamageDealt: number | null
    magicDamageDealtToChampions: number | null
    magicDamageTaken: number | null
    neutralMinionsKilled: number | null
    nexusKills: number | null
    nexusLost: number | null
    nexusTakedowns: number | null
    objectivesStolen: number | null
    objectivesStolenAssists: number | null
    participantId: number | null
    pentaKills: number | null
    physicalDamageDealt: number | null
    physicalDamageDealtToChampions: number | null
    physicalDamageTaken: number | null
    quadraKills: number | null
    sightWardsBoughtInGame: number | null
    spell1Casts: number | null
    spell2Casts: number | null
    spell3Casts: number | null
    spell4Casts: number | null
    summoner1Casts: number | null
    summoner1Id: number | null
    summoner2Casts: number | null
    summoner2Id: number | null
    summonerLevel: number | null
    teamId: number | null
    timeCCingOthers: number | null
    timePlayed: number | null
    totalDamageDealt: number | null
    totalDamageDealtToChampions: number | null
    totalDamageShieldedOnTeammates: number | null
    totalDamageTaken: number | null
    totalHeal: number | null
    totalHealsOnTeammates: number | null
    totalMinionsKilled: number | null
    totalTimeCCDealt: number | null
    totalTimeSpentDead: number | null
    totalUnitsHealed: number | null
    tripleKills: number | null
    trueDamageDealt: number | null
    trueDamageDealtToChampions: number | null
    trueDamageTaken: number | null
    turretsKilled: number | null
    turretTakedowns: number | null
    turretsLost: number | null
    unrealKills: number | null
    visionScore: number | null
    visionWardsBoughtInGame: number | null
    wardsKilled: number | null
    wardsPlaced: number | null
  }

  export type PlayerEndOfGameStatSumAggregateOutputType = {
    assists: number | null
    baronKills: number | null
    bountyLevel: number | null
    championExperience: number | null
    championLevel: number | null
    championId: number | null
    championTransform: number | null
    consumablesPurchased: number | null
    damageDealtToBuildings: number | null
    damageDealtToObjectives: number | null
    damageDealtToTurrets: number | null
    damageSelfMitigated: number | null
    deaths: number | null
    detectorWardsPlaced: number | null
    doubleKills: number | null
    dragonKills: number | null
    goldEarned: number | null
    goldSpent: number | null
    inhibitorKills: number | null
    inhibitorTakedowns: number | null
    inhibitorsLost: number | null
    item0: number | null
    item1: number | null
    item2: number | null
    item3: number | null
    item4: number | null
    item5: number | null
    item6: number | null
    itemsPurchased: number | null
    killingSprees: number | null
    kills: number | null
    largestCriticalStrike: number | null
    largestKillingSpree: number | null
    largestMultiKill: number | null
    longestTimeSpentLiving: number | null
    magicDamageDealt: number | null
    magicDamageDealtToChampions: number | null
    magicDamageTaken: number | null
    neutralMinionsKilled: number | null
    nexusKills: number | null
    nexusLost: number | null
    nexusTakedowns: number | null
    objectivesStolen: number | null
    objectivesStolenAssists: number | null
    participantId: number | null
    pentaKills: number | null
    physicalDamageDealt: number | null
    physicalDamageDealtToChampions: number | null
    physicalDamageTaken: number | null
    quadraKills: number | null
    sightWardsBoughtInGame: number | null
    spell1Casts: number | null
    spell2Casts: number | null
    spell3Casts: number | null
    spell4Casts: number | null
    summoner1Casts: number | null
    summoner1Id: number | null
    summoner2Casts: number | null
    summoner2Id: number | null
    summonerLevel: number | null
    teamId: number | null
    timeCCingOthers: number | null
    timePlayed: number | null
    totalDamageDealt: number | null
    totalDamageDealtToChampions: number | null
    totalDamageShieldedOnTeammates: number | null
    totalDamageTaken: number | null
    totalHeal: number | null
    totalHealsOnTeammates: number | null
    totalMinionsKilled: number | null
    totalTimeCCDealt: number | null
    totalTimeSpentDead: number | null
    totalUnitsHealed: number | null
    tripleKills: number | null
    trueDamageDealt: number | null
    trueDamageDealtToChampions: number | null
    trueDamageTaken: number | null
    turretsKilled: number | null
    turretTakedowns: number | null
    turretsLost: number | null
    unrealKills: number | null
    visionScore: number | null
    visionWardsBoughtInGame: number | null
    wardsKilled: number | null
    wardsPlaced: number | null
  }

  export type PlayerEndOfGameStatMinAggregateOutputType = {
    id: string | null
    playerId: string | null
    gameId: string | null
    perksId: string | null
    itemsId: string | null
    assists: number | null
    baronKills: number | null
    bountyLevel: number | null
    championExperience: number | null
    championLevel: number | null
    championId: number | null
    championName: string | null
    championTransform: number | null
    consumablesPurchased: number | null
    damageDealtToBuildings: number | null
    damageDealtToObjectives: number | null
    damageDealtToTurrets: number | null
    damageSelfMitigated: number | null
    deaths: number | null
    detectorWardsPlaced: number | null
    doubleKills: number | null
    dragonKills: number | null
    firstBlood: boolean | null
    firstBloodAssist: boolean | null
    firstTowerKill: boolean | null
    firstTowerAssist: boolean | null
    gameEndedInEarlySurrender: boolean | null
    gameEndedInSurrender: boolean | null
    goldEarned: number | null
    goldSpent: number | null
    individualPosition: string | null
    inhibitorKills: number | null
    inhibitorTakedowns: number | null
    inhibitorsLost: number | null
    item0: number | null
    item1: number | null
    item2: number | null
    item3: number | null
    item4: number | null
    item5: number | null
    item6: number | null
    itemsPurchased: number | null
    killingSprees: number | null
    kills: number | null
    lane: string | null
    largestCriticalStrike: number | null
    largestKillingSpree: number | null
    largestMultiKill: number | null
    longestTimeSpentLiving: number | null
    magicDamageDealt: number | null
    magicDamageDealtToChampions: number | null
    magicDamageTaken: number | null
    neutralMinionsKilled: number | null
    nexusKills: number | null
    nexusLost: number | null
    nexusTakedowns: number | null
    objectivesStolen: number | null
    objectivesStolenAssists: number | null
    participantId: number | null
    pentaKills: number | null
    physicalDamageDealt: number | null
    physicalDamageDealtToChampions: number | null
    physicalDamageTaken: number | null
    quadraKills: number | null
    riotIdName: string | null
    riotIdTagline: string | null
    role: string | null
    sightWardsBoughtInGame: number | null
    spell1Casts: number | null
    spell2Casts: number | null
    spell3Casts: number | null
    spell4Casts: number | null
    summoner1Casts: number | null
    summoner1Id: number | null
    summoner2Casts: number | null
    summoner2Id: number | null
    summonerLevel: number | null
    summonerName: string | null
    teamEarlySurrendered: boolean | null
    teamId: number | null
    teamPosition: string | null
    timeCCingOthers: number | null
    timePlayed: number | null
    totalDamageDealt: number | null
    totalDamageDealtToChampions: number | null
    totalDamageShieldedOnTeammates: number | null
    totalDamageTaken: number | null
    totalHeal: number | null
    totalHealsOnTeammates: number | null
    totalMinionsKilled: number | null
    totalTimeCCDealt: number | null
    totalTimeSpentDead: number | null
    totalUnitsHealed: number | null
    tripleKills: number | null
    trueDamageDealt: number | null
    trueDamageDealtToChampions: number | null
    trueDamageTaken: number | null
    turretsKilled: number | null
    turretTakedowns: number | null
    turretsLost: number | null
    unrealKills: number | null
    visionScore: number | null
    visionWardsBoughtInGame: number | null
    wardsKilled: number | null
    wardsPlaced: number | null
    win: boolean | null
  }

  export type PlayerEndOfGameStatMaxAggregateOutputType = {
    id: string | null
    playerId: string | null
    gameId: string | null
    perksId: string | null
    itemsId: string | null
    assists: number | null
    baronKills: number | null
    bountyLevel: number | null
    championExperience: number | null
    championLevel: number | null
    championId: number | null
    championName: string | null
    championTransform: number | null
    consumablesPurchased: number | null
    damageDealtToBuildings: number | null
    damageDealtToObjectives: number | null
    damageDealtToTurrets: number | null
    damageSelfMitigated: number | null
    deaths: number | null
    detectorWardsPlaced: number | null
    doubleKills: number | null
    dragonKills: number | null
    firstBlood: boolean | null
    firstBloodAssist: boolean | null
    firstTowerKill: boolean | null
    firstTowerAssist: boolean | null
    gameEndedInEarlySurrender: boolean | null
    gameEndedInSurrender: boolean | null
    goldEarned: number | null
    goldSpent: number | null
    individualPosition: string | null
    inhibitorKills: number | null
    inhibitorTakedowns: number | null
    inhibitorsLost: number | null
    item0: number | null
    item1: number | null
    item2: number | null
    item3: number | null
    item4: number | null
    item5: number | null
    item6: number | null
    itemsPurchased: number | null
    killingSprees: number | null
    kills: number | null
    lane: string | null
    largestCriticalStrike: number | null
    largestKillingSpree: number | null
    largestMultiKill: number | null
    longestTimeSpentLiving: number | null
    magicDamageDealt: number | null
    magicDamageDealtToChampions: number | null
    magicDamageTaken: number | null
    neutralMinionsKilled: number | null
    nexusKills: number | null
    nexusLost: number | null
    nexusTakedowns: number | null
    objectivesStolen: number | null
    objectivesStolenAssists: number | null
    participantId: number | null
    pentaKills: number | null
    physicalDamageDealt: number | null
    physicalDamageDealtToChampions: number | null
    physicalDamageTaken: number | null
    quadraKills: number | null
    riotIdName: string | null
    riotIdTagline: string | null
    role: string | null
    sightWardsBoughtInGame: number | null
    spell1Casts: number | null
    spell2Casts: number | null
    spell3Casts: number | null
    spell4Casts: number | null
    summoner1Casts: number | null
    summoner1Id: number | null
    summoner2Casts: number | null
    summoner2Id: number | null
    summonerLevel: number | null
    summonerName: string | null
    teamEarlySurrendered: boolean | null
    teamId: number | null
    teamPosition: string | null
    timeCCingOthers: number | null
    timePlayed: number | null
    totalDamageDealt: number | null
    totalDamageDealtToChampions: number | null
    totalDamageShieldedOnTeammates: number | null
    totalDamageTaken: number | null
    totalHeal: number | null
    totalHealsOnTeammates: number | null
    totalMinionsKilled: number | null
    totalTimeCCDealt: number | null
    totalTimeSpentDead: number | null
    totalUnitsHealed: number | null
    tripleKills: number | null
    trueDamageDealt: number | null
    trueDamageDealtToChampions: number | null
    trueDamageTaken: number | null
    turretsKilled: number | null
    turretTakedowns: number | null
    turretsLost: number | null
    unrealKills: number | null
    visionScore: number | null
    visionWardsBoughtInGame: number | null
    wardsKilled: number | null
    wardsPlaced: number | null
    win: boolean | null
  }

  export type PlayerEndOfGameStatCountAggregateOutputType = {
    id: number
    playerId: number
    gameId: number
    perksId: number
    itemsId: number
    assists: number
    baronKills: number
    bountyLevel: number
    championExperience: number
    championLevel: number
    championId: number
    championName: number
    championTransform: number
    consumablesPurchased: number
    damageDealtToBuildings: number
    damageDealtToObjectives: number
    damageDealtToTurrets: number
    damageSelfMitigated: number
    deaths: number
    detectorWardsPlaced: number
    doubleKills: number
    dragonKills: number
    firstBlood: number
    firstBloodAssist: number
    firstTowerKill: number
    firstTowerAssist: number
    gameEndedInEarlySurrender: number
    gameEndedInSurrender: number
    goldEarned: number
    goldSpent: number
    individualPosition: number
    inhibitorKills: number
    inhibitorTakedowns: number
    inhibitorsLost: number
    item0: number
    item1: number
    item2: number
    item3: number
    item4: number
    item5: number
    item6: number
    itemsPurchased: number
    killingSprees: number
    kills: number
    lane: number
    largestCriticalStrike: number
    largestKillingSpree: number
    largestMultiKill: number
    longestTimeSpentLiving: number
    magicDamageDealt: number
    magicDamageDealtToChampions: number
    magicDamageTaken: number
    neutralMinionsKilled: number
    nexusKills: number
    nexusLost: number
    nexusTakedowns: number
    objectivesStolen: number
    objectivesStolenAssists: number
    participantId: number
    pentaKills: number
    physicalDamageDealt: number
    physicalDamageDealtToChampions: number
    physicalDamageTaken: number
    quadraKills: number
    riotIdName: number
    riotIdTagline: number
    role: number
    sightWardsBoughtInGame: number
    spell1Casts: number
    spell2Casts: number
    spell3Casts: number
    spell4Casts: number
    summoner1Casts: number
    summoner1Id: number
    summoner2Casts: number
    summoner2Id: number
    summonerLevel: number
    summonerName: number
    teamEarlySurrendered: number
    teamId: number
    teamPosition: number
    timeCCingOthers: number
    timePlayed: number
    totalDamageDealt: number
    totalDamageDealtToChampions: number
    totalDamageShieldedOnTeammates: number
    totalDamageTaken: number
    totalHeal: number
    totalHealsOnTeammates: number
    totalMinionsKilled: number
    totalTimeCCDealt: number
    totalTimeSpentDead: number
    totalUnitsHealed: number
    tripleKills: number
    trueDamageDealt: number
    trueDamageDealtToChampions: number
    trueDamageTaken: number
    turretsKilled: number
    turretTakedowns: number
    turretsLost: number
    unrealKills: number
    visionScore: number
    visionWardsBoughtInGame: number
    wardsKilled: number
    wardsPlaced: number
    win: number
    _all: number
  }


  export type PlayerEndOfGameStatAvgAggregateInputType = {
    assists?: true
    baronKills?: true
    bountyLevel?: true
    championExperience?: true
    championLevel?: true
    championId?: true
    championTransform?: true
    consumablesPurchased?: true
    damageDealtToBuildings?: true
    damageDealtToObjectives?: true
    damageDealtToTurrets?: true
    damageSelfMitigated?: true
    deaths?: true
    detectorWardsPlaced?: true
    doubleKills?: true
    dragonKills?: true
    goldEarned?: true
    goldSpent?: true
    inhibitorKills?: true
    inhibitorTakedowns?: true
    inhibitorsLost?: true
    item0?: true
    item1?: true
    item2?: true
    item3?: true
    item4?: true
    item5?: true
    item6?: true
    itemsPurchased?: true
    killingSprees?: true
    kills?: true
    largestCriticalStrike?: true
    largestKillingSpree?: true
    largestMultiKill?: true
    longestTimeSpentLiving?: true
    magicDamageDealt?: true
    magicDamageDealtToChampions?: true
    magicDamageTaken?: true
    neutralMinionsKilled?: true
    nexusKills?: true
    nexusLost?: true
    nexusTakedowns?: true
    objectivesStolen?: true
    objectivesStolenAssists?: true
    participantId?: true
    pentaKills?: true
    physicalDamageDealt?: true
    physicalDamageDealtToChampions?: true
    physicalDamageTaken?: true
    quadraKills?: true
    sightWardsBoughtInGame?: true
    spell1Casts?: true
    spell2Casts?: true
    spell3Casts?: true
    spell4Casts?: true
    summoner1Casts?: true
    summoner1Id?: true
    summoner2Casts?: true
    summoner2Id?: true
    summonerLevel?: true
    teamId?: true
    timeCCingOthers?: true
    timePlayed?: true
    totalDamageDealt?: true
    totalDamageDealtToChampions?: true
    totalDamageShieldedOnTeammates?: true
    totalDamageTaken?: true
    totalHeal?: true
    totalHealsOnTeammates?: true
    totalMinionsKilled?: true
    totalTimeCCDealt?: true
    totalTimeSpentDead?: true
    totalUnitsHealed?: true
    tripleKills?: true
    trueDamageDealt?: true
    trueDamageDealtToChampions?: true
    trueDamageTaken?: true
    turretsKilled?: true
    turretTakedowns?: true
    turretsLost?: true
    unrealKills?: true
    visionScore?: true
    visionWardsBoughtInGame?: true
    wardsKilled?: true
    wardsPlaced?: true
  }

  export type PlayerEndOfGameStatSumAggregateInputType = {
    assists?: true
    baronKills?: true
    bountyLevel?: true
    championExperience?: true
    championLevel?: true
    championId?: true
    championTransform?: true
    consumablesPurchased?: true
    damageDealtToBuildings?: true
    damageDealtToObjectives?: true
    damageDealtToTurrets?: true
    damageSelfMitigated?: true
    deaths?: true
    detectorWardsPlaced?: true
    doubleKills?: true
    dragonKills?: true
    goldEarned?: true
    goldSpent?: true
    inhibitorKills?: true
    inhibitorTakedowns?: true
    inhibitorsLost?: true
    item0?: true
    item1?: true
    item2?: true
    item3?: true
    item4?: true
    item5?: true
    item6?: true
    itemsPurchased?: true
    killingSprees?: true
    kills?: true
    largestCriticalStrike?: true
    largestKillingSpree?: true
    largestMultiKill?: true
    longestTimeSpentLiving?: true
    magicDamageDealt?: true
    magicDamageDealtToChampions?: true
    magicDamageTaken?: true
    neutralMinionsKilled?: true
    nexusKills?: true
    nexusLost?: true
    nexusTakedowns?: true
    objectivesStolen?: true
    objectivesStolenAssists?: true
    participantId?: true
    pentaKills?: true
    physicalDamageDealt?: true
    physicalDamageDealtToChampions?: true
    physicalDamageTaken?: true
    quadraKills?: true
    sightWardsBoughtInGame?: true
    spell1Casts?: true
    spell2Casts?: true
    spell3Casts?: true
    spell4Casts?: true
    summoner1Casts?: true
    summoner1Id?: true
    summoner2Casts?: true
    summoner2Id?: true
    summonerLevel?: true
    teamId?: true
    timeCCingOthers?: true
    timePlayed?: true
    totalDamageDealt?: true
    totalDamageDealtToChampions?: true
    totalDamageShieldedOnTeammates?: true
    totalDamageTaken?: true
    totalHeal?: true
    totalHealsOnTeammates?: true
    totalMinionsKilled?: true
    totalTimeCCDealt?: true
    totalTimeSpentDead?: true
    totalUnitsHealed?: true
    tripleKills?: true
    trueDamageDealt?: true
    trueDamageDealtToChampions?: true
    trueDamageTaken?: true
    turretsKilled?: true
    turretTakedowns?: true
    turretsLost?: true
    unrealKills?: true
    visionScore?: true
    visionWardsBoughtInGame?: true
    wardsKilled?: true
    wardsPlaced?: true
  }

  export type PlayerEndOfGameStatMinAggregateInputType = {
    id?: true
    playerId?: true
    gameId?: true
    perksId?: true
    itemsId?: true
    assists?: true
    baronKills?: true
    bountyLevel?: true
    championExperience?: true
    championLevel?: true
    championId?: true
    championName?: true
    championTransform?: true
    consumablesPurchased?: true
    damageDealtToBuildings?: true
    damageDealtToObjectives?: true
    damageDealtToTurrets?: true
    damageSelfMitigated?: true
    deaths?: true
    detectorWardsPlaced?: true
    doubleKills?: true
    dragonKills?: true
    firstBlood?: true
    firstBloodAssist?: true
    firstTowerKill?: true
    firstTowerAssist?: true
    gameEndedInEarlySurrender?: true
    gameEndedInSurrender?: true
    goldEarned?: true
    goldSpent?: true
    individualPosition?: true
    inhibitorKills?: true
    inhibitorTakedowns?: true
    inhibitorsLost?: true
    item0?: true
    item1?: true
    item2?: true
    item3?: true
    item4?: true
    item5?: true
    item6?: true
    itemsPurchased?: true
    killingSprees?: true
    kills?: true
    lane?: true
    largestCriticalStrike?: true
    largestKillingSpree?: true
    largestMultiKill?: true
    longestTimeSpentLiving?: true
    magicDamageDealt?: true
    magicDamageDealtToChampions?: true
    magicDamageTaken?: true
    neutralMinionsKilled?: true
    nexusKills?: true
    nexusLost?: true
    nexusTakedowns?: true
    objectivesStolen?: true
    objectivesStolenAssists?: true
    participantId?: true
    pentaKills?: true
    physicalDamageDealt?: true
    physicalDamageDealtToChampions?: true
    physicalDamageTaken?: true
    quadraKills?: true
    riotIdName?: true
    riotIdTagline?: true
    role?: true
    sightWardsBoughtInGame?: true
    spell1Casts?: true
    spell2Casts?: true
    spell3Casts?: true
    spell4Casts?: true
    summoner1Casts?: true
    summoner1Id?: true
    summoner2Casts?: true
    summoner2Id?: true
    summonerLevel?: true
    summonerName?: true
    teamEarlySurrendered?: true
    teamId?: true
    teamPosition?: true
    timeCCingOthers?: true
    timePlayed?: true
    totalDamageDealt?: true
    totalDamageDealtToChampions?: true
    totalDamageShieldedOnTeammates?: true
    totalDamageTaken?: true
    totalHeal?: true
    totalHealsOnTeammates?: true
    totalMinionsKilled?: true
    totalTimeCCDealt?: true
    totalTimeSpentDead?: true
    totalUnitsHealed?: true
    tripleKills?: true
    trueDamageDealt?: true
    trueDamageDealtToChampions?: true
    trueDamageTaken?: true
    turretsKilled?: true
    turretTakedowns?: true
    turretsLost?: true
    unrealKills?: true
    visionScore?: true
    visionWardsBoughtInGame?: true
    wardsKilled?: true
    wardsPlaced?: true
    win?: true
  }

  export type PlayerEndOfGameStatMaxAggregateInputType = {
    id?: true
    playerId?: true
    gameId?: true
    perksId?: true
    itemsId?: true
    assists?: true
    baronKills?: true
    bountyLevel?: true
    championExperience?: true
    championLevel?: true
    championId?: true
    championName?: true
    championTransform?: true
    consumablesPurchased?: true
    damageDealtToBuildings?: true
    damageDealtToObjectives?: true
    damageDealtToTurrets?: true
    damageSelfMitigated?: true
    deaths?: true
    detectorWardsPlaced?: true
    doubleKills?: true
    dragonKills?: true
    firstBlood?: true
    firstBloodAssist?: true
    firstTowerKill?: true
    firstTowerAssist?: true
    gameEndedInEarlySurrender?: true
    gameEndedInSurrender?: true
    goldEarned?: true
    goldSpent?: true
    individualPosition?: true
    inhibitorKills?: true
    inhibitorTakedowns?: true
    inhibitorsLost?: true
    item0?: true
    item1?: true
    item2?: true
    item3?: true
    item4?: true
    item5?: true
    item6?: true
    itemsPurchased?: true
    killingSprees?: true
    kills?: true
    lane?: true
    largestCriticalStrike?: true
    largestKillingSpree?: true
    largestMultiKill?: true
    longestTimeSpentLiving?: true
    magicDamageDealt?: true
    magicDamageDealtToChampions?: true
    magicDamageTaken?: true
    neutralMinionsKilled?: true
    nexusKills?: true
    nexusLost?: true
    nexusTakedowns?: true
    objectivesStolen?: true
    objectivesStolenAssists?: true
    participantId?: true
    pentaKills?: true
    physicalDamageDealt?: true
    physicalDamageDealtToChampions?: true
    physicalDamageTaken?: true
    quadraKills?: true
    riotIdName?: true
    riotIdTagline?: true
    role?: true
    sightWardsBoughtInGame?: true
    spell1Casts?: true
    spell2Casts?: true
    spell3Casts?: true
    spell4Casts?: true
    summoner1Casts?: true
    summoner1Id?: true
    summoner2Casts?: true
    summoner2Id?: true
    summonerLevel?: true
    summonerName?: true
    teamEarlySurrendered?: true
    teamId?: true
    teamPosition?: true
    timeCCingOthers?: true
    timePlayed?: true
    totalDamageDealt?: true
    totalDamageDealtToChampions?: true
    totalDamageShieldedOnTeammates?: true
    totalDamageTaken?: true
    totalHeal?: true
    totalHealsOnTeammates?: true
    totalMinionsKilled?: true
    totalTimeCCDealt?: true
    totalTimeSpentDead?: true
    totalUnitsHealed?: true
    tripleKills?: true
    trueDamageDealt?: true
    trueDamageDealtToChampions?: true
    trueDamageTaken?: true
    turretsKilled?: true
    turretTakedowns?: true
    turretsLost?: true
    unrealKills?: true
    visionScore?: true
    visionWardsBoughtInGame?: true
    wardsKilled?: true
    wardsPlaced?: true
    win?: true
  }

  export type PlayerEndOfGameStatCountAggregateInputType = {
    id?: true
    playerId?: true
    gameId?: true
    perksId?: true
    itemsId?: true
    assists?: true
    baronKills?: true
    bountyLevel?: true
    championExperience?: true
    championLevel?: true
    championId?: true
    championName?: true
    championTransform?: true
    consumablesPurchased?: true
    damageDealtToBuildings?: true
    damageDealtToObjectives?: true
    damageDealtToTurrets?: true
    damageSelfMitigated?: true
    deaths?: true
    detectorWardsPlaced?: true
    doubleKills?: true
    dragonKills?: true
    firstBlood?: true
    firstBloodAssist?: true
    firstTowerKill?: true
    firstTowerAssist?: true
    gameEndedInEarlySurrender?: true
    gameEndedInSurrender?: true
    goldEarned?: true
    goldSpent?: true
    individualPosition?: true
    inhibitorKills?: true
    inhibitorTakedowns?: true
    inhibitorsLost?: true
    item0?: true
    item1?: true
    item2?: true
    item3?: true
    item4?: true
    item5?: true
    item6?: true
    itemsPurchased?: true
    killingSprees?: true
    kills?: true
    lane?: true
    largestCriticalStrike?: true
    largestKillingSpree?: true
    largestMultiKill?: true
    longestTimeSpentLiving?: true
    magicDamageDealt?: true
    magicDamageDealtToChampions?: true
    magicDamageTaken?: true
    neutralMinionsKilled?: true
    nexusKills?: true
    nexusLost?: true
    nexusTakedowns?: true
    objectivesStolen?: true
    objectivesStolenAssists?: true
    participantId?: true
    pentaKills?: true
    physicalDamageDealt?: true
    physicalDamageDealtToChampions?: true
    physicalDamageTaken?: true
    quadraKills?: true
    riotIdName?: true
    riotIdTagline?: true
    role?: true
    sightWardsBoughtInGame?: true
    spell1Casts?: true
    spell2Casts?: true
    spell3Casts?: true
    spell4Casts?: true
    summoner1Casts?: true
    summoner1Id?: true
    summoner2Casts?: true
    summoner2Id?: true
    summonerLevel?: true
    summonerName?: true
    teamEarlySurrendered?: true
    teamId?: true
    teamPosition?: true
    timeCCingOthers?: true
    timePlayed?: true
    totalDamageDealt?: true
    totalDamageDealtToChampions?: true
    totalDamageShieldedOnTeammates?: true
    totalDamageTaken?: true
    totalHeal?: true
    totalHealsOnTeammates?: true
    totalMinionsKilled?: true
    totalTimeCCDealt?: true
    totalTimeSpentDead?: true
    totalUnitsHealed?: true
    tripleKills?: true
    trueDamageDealt?: true
    trueDamageDealtToChampions?: true
    trueDamageTaken?: true
    turretsKilled?: true
    turretTakedowns?: true
    turretsLost?: true
    unrealKills?: true
    visionScore?: true
    visionWardsBoughtInGame?: true
    wardsKilled?: true
    wardsPlaced?: true
    win?: true
    _all?: true
  }

  export type PlayerEndOfGameStatAggregateArgs = {
    /**
     * Filter which PlayerEndOfGameStat to aggregate.
     * 
    **/
    where?: PlayerEndOfGameStatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerEndOfGameStats to fetch.
     * 
    **/
    orderBy?: Enumerable<PlayerEndOfGameStatOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: PlayerEndOfGameStatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerEndOfGameStats from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerEndOfGameStats.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlayerEndOfGameStats
    **/
    _count?: true | PlayerEndOfGameStatCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlayerEndOfGameStatAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlayerEndOfGameStatSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlayerEndOfGameStatMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlayerEndOfGameStatMaxAggregateInputType
  }

  export type GetPlayerEndOfGameStatAggregateType<T extends PlayerEndOfGameStatAggregateArgs> = {
        [P in keyof T & keyof AggregatePlayerEndOfGameStat]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlayerEndOfGameStat[P]>
      : GetScalarType<T[P], AggregatePlayerEndOfGameStat[P]>
  }




  export type PlayerEndOfGameStatGroupByArgs = {
    where?: PlayerEndOfGameStatWhereInput
    orderBy?: Enumerable<PlayerEndOfGameStatOrderByWithAggregationInput>
    by: Array<PlayerEndOfGameStatScalarFieldEnum>
    having?: PlayerEndOfGameStatScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlayerEndOfGameStatCountAggregateInputType | true
    _avg?: PlayerEndOfGameStatAvgAggregateInputType
    _sum?: PlayerEndOfGameStatSumAggregateInputType
    _min?: PlayerEndOfGameStatMinAggregateInputType
    _max?: PlayerEndOfGameStatMaxAggregateInputType
  }


  export type PlayerEndOfGameStatGroupByOutputType = {
    id: string
    playerId: string | null
    gameId: string | null
    perksId: string | null
    itemsId: string | null
    assists: number | null
    baronKills: number | null
    bountyLevel: number | null
    championExperience: number | null
    championLevel: number | null
    championId: number | null
    championName: string
    championTransform: number | null
    consumablesPurchased: number | null
    damageDealtToBuildings: number | null
    damageDealtToObjectives: number | null
    damageDealtToTurrets: number | null
    damageSelfMitigated: number | null
    deaths: number | null
    detectorWardsPlaced: number | null
    doubleKills: number | null
    dragonKills: number | null
    firstBlood: boolean
    firstBloodAssist: boolean
    firstTowerKill: boolean
    firstTowerAssist: boolean
    gameEndedInEarlySurrender: boolean
    gameEndedInSurrender: boolean
    goldEarned: number | null
    goldSpent: number | null
    individualPosition: string
    inhibitorKills: number | null
    inhibitorTakedowns: number | null
    inhibitorsLost: number | null
    item0: number | null
    item1: number | null
    item2: number | null
    item3: number | null
    item4: number | null
    item5: number | null
    item6: number | null
    itemsPurchased: number | null
    killingSprees: number | null
    kills: number | null
    lane: string
    largestCriticalStrike: number | null
    largestKillingSpree: number | null
    largestMultiKill: number | null
    longestTimeSpentLiving: number | null
    magicDamageDealt: number | null
    magicDamageDealtToChampions: number | null
    magicDamageTaken: number | null
    neutralMinionsKilled: number | null
    nexusKills: number | null
    nexusLost: number | null
    nexusTakedowns: number | null
    objectivesStolen: number | null
    objectivesStolenAssists: number | null
    participantId: number | null
    pentaKills: number | null
    physicalDamageDealt: number | null
    physicalDamageDealtToChampions: number | null
    physicalDamageTaken: number | null
    quadraKills: number | null
    riotIdName: string
    riotIdTagline: string
    role: string
    sightWardsBoughtInGame: number | null
    spell1Casts: number | null
    spell2Casts: number | null
    spell3Casts: number | null
    spell4Casts: number | null
    summoner1Casts: number | null
    summoner1Id: number | null
    summoner2Casts: number | null
    summoner2Id: number | null
    summonerLevel: number | null
    summonerName: string
    teamEarlySurrendered: boolean
    teamId: number | null
    teamPosition: string
    timeCCingOthers: number | null
    timePlayed: number | null
    totalDamageDealt: number | null
    totalDamageDealtToChampions: number | null
    totalDamageShieldedOnTeammates: number | null
    totalDamageTaken: number | null
    totalHeal: number | null
    totalHealsOnTeammates: number | null
    totalMinionsKilled: number | null
    totalTimeCCDealt: number | null
    totalTimeSpentDead: number | null
    totalUnitsHealed: number | null
    tripleKills: number | null
    trueDamageDealt: number | null
    trueDamageDealtToChampions: number | null
    trueDamageTaken: number | null
    turretsKilled: number | null
    turretTakedowns: number | null
    turretsLost: number | null
    unrealKills: number | null
    visionScore: number | null
    visionWardsBoughtInGame: number | null
    wardsKilled: number | null
    wardsPlaced: number | null
    win: boolean
    _count: PlayerEndOfGameStatCountAggregateOutputType | null
    _avg: PlayerEndOfGameStatAvgAggregateOutputType | null
    _sum: PlayerEndOfGameStatSumAggregateOutputType | null
    _min: PlayerEndOfGameStatMinAggregateOutputType | null
    _max: PlayerEndOfGameStatMaxAggregateOutputType | null
  }

  type GetPlayerEndOfGameStatGroupByPayload<T extends PlayerEndOfGameStatGroupByArgs> = PrismaPromise<
    Array<
      PickArray<PlayerEndOfGameStatGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlayerEndOfGameStatGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlayerEndOfGameStatGroupByOutputType[P]>
            : GetScalarType<T[P], PlayerEndOfGameStatGroupByOutputType[P]>
        }
      >
    >


  export type PlayerEndOfGameStatSelect = {
    id?: boolean
    player?: boolean | PlayerArgs
    playerId?: boolean
    game?: boolean | GameArgs
    gameId?: boolean
    perks?: boolean | PlayerRuneArgs
    perksId?: boolean
    items?: boolean | PlayerItemArgs
    itemsId?: boolean
    assists?: boolean
    baronKills?: boolean
    bountyLevel?: boolean
    championExperience?: boolean
    championLevel?: boolean
    championId?: boolean
    championName?: boolean
    championTransform?: boolean
    consumablesPurchased?: boolean
    damageDealtToBuildings?: boolean
    damageDealtToObjectives?: boolean
    damageDealtToTurrets?: boolean
    damageSelfMitigated?: boolean
    deaths?: boolean
    detectorWardsPlaced?: boolean
    doubleKills?: boolean
    dragonKills?: boolean
    firstBlood?: boolean
    firstBloodAssist?: boolean
    firstTowerKill?: boolean
    firstTowerAssist?: boolean
    gameEndedInEarlySurrender?: boolean
    gameEndedInSurrender?: boolean
    goldEarned?: boolean
    goldSpent?: boolean
    individualPosition?: boolean
    inhibitorKills?: boolean
    inhibitorTakedowns?: boolean
    inhibitorsLost?: boolean
    item0?: boolean
    item1?: boolean
    item2?: boolean
    item3?: boolean
    item4?: boolean
    item5?: boolean
    item6?: boolean
    itemsPurchased?: boolean
    killingSprees?: boolean
    kills?: boolean
    lane?: boolean
    largestCriticalStrike?: boolean
    largestKillingSpree?: boolean
    largestMultiKill?: boolean
    longestTimeSpentLiving?: boolean
    magicDamageDealt?: boolean
    magicDamageDealtToChampions?: boolean
    magicDamageTaken?: boolean
    neutralMinionsKilled?: boolean
    nexusKills?: boolean
    nexusLost?: boolean
    nexusTakedowns?: boolean
    objectivesStolen?: boolean
    objectivesStolenAssists?: boolean
    participantId?: boolean
    pentaKills?: boolean
    physicalDamageDealt?: boolean
    physicalDamageDealtToChampions?: boolean
    physicalDamageTaken?: boolean
    quadraKills?: boolean
    riotIdName?: boolean
    riotIdTagline?: boolean
    role?: boolean
    sightWardsBoughtInGame?: boolean
    spell1Casts?: boolean
    spell2Casts?: boolean
    spell3Casts?: boolean
    spell4Casts?: boolean
    summoner1Casts?: boolean
    summoner1Id?: boolean
    summoner2Casts?: boolean
    summoner2Id?: boolean
    summonerLevel?: boolean
    summonerName?: boolean
    teamEarlySurrendered?: boolean
    teamId?: boolean
    teamPosition?: boolean
    timeCCingOthers?: boolean
    timePlayed?: boolean
    totalDamageDealt?: boolean
    totalDamageDealtToChampions?: boolean
    totalDamageShieldedOnTeammates?: boolean
    totalDamageTaken?: boolean
    totalHeal?: boolean
    totalHealsOnTeammates?: boolean
    totalMinionsKilled?: boolean
    totalTimeCCDealt?: boolean
    totalTimeSpentDead?: boolean
    totalUnitsHealed?: boolean
    tripleKills?: boolean
    trueDamageDealt?: boolean
    trueDamageDealtToChampions?: boolean
    trueDamageTaken?: boolean
    turretsKilled?: boolean
    turretTakedowns?: boolean
    turretsLost?: boolean
    unrealKills?: boolean
    visionScore?: boolean
    visionWardsBoughtInGame?: boolean
    wardsKilled?: boolean
    wardsPlaced?: boolean
    win?: boolean
  }

  export type PlayerEndOfGameStatInclude = {
    player?: boolean | PlayerArgs
    game?: boolean | GameArgs
    perks?: boolean | PlayerRuneArgs
    items?: boolean | PlayerItemArgs
  }

  export type PlayerEndOfGameStatGetPayload<
    S extends boolean | null | undefined | PlayerEndOfGameStatArgs,
    U = keyof S
      > = S extends true
        ? PlayerEndOfGameStat
    : S extends undefined
    ? never
    : S extends PlayerEndOfGameStatArgs | PlayerEndOfGameStatFindManyArgs
    ?'include' extends U
    ? PlayerEndOfGameStat  & {
    [P in TrueKeys<S['include']>]:
        P extends 'player' ? PlayerGetPayload<S['include'][P]> | null :
        P extends 'game' ? GameGetPayload<S['include'][P]> | null :
        P extends 'perks' ? PlayerRuneGetPayload<S['include'][P]> | null :
        P extends 'items' ? PlayerItemGetPayload<S['include'][P]> | null :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'player' ? PlayerGetPayload<S['select'][P]> | null :
        P extends 'game' ? GameGetPayload<S['select'][P]> | null :
        P extends 'perks' ? PlayerRuneGetPayload<S['select'][P]> | null :
        P extends 'items' ? PlayerItemGetPayload<S['select'][P]> | null :  P extends keyof PlayerEndOfGameStat ? PlayerEndOfGameStat[P] : never
  } 
    : PlayerEndOfGameStat
  : PlayerEndOfGameStat


  type PlayerEndOfGameStatCountArgs = Merge<
    Omit<PlayerEndOfGameStatFindManyArgs, 'select' | 'include'> & {
      select?: PlayerEndOfGameStatCountAggregateInputType | true
    }
  >

  export interface PlayerEndOfGameStatDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one PlayerEndOfGameStat that matches the filter.
     * @param {PlayerEndOfGameStatFindUniqueArgs} args - Arguments to find a PlayerEndOfGameStat
     * @example
     * // Get one PlayerEndOfGameStat
     * const playerEndOfGameStat = await prisma.playerEndOfGameStat.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PlayerEndOfGameStatFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PlayerEndOfGameStatFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'PlayerEndOfGameStat'> extends True ? CheckSelect<T, Prisma__PlayerEndOfGameStatClient<PlayerEndOfGameStat>, Prisma__PlayerEndOfGameStatClient<PlayerEndOfGameStatGetPayload<T>>> : CheckSelect<T, Prisma__PlayerEndOfGameStatClient<PlayerEndOfGameStat | null >, Prisma__PlayerEndOfGameStatClient<PlayerEndOfGameStatGetPayload<T> | null >>

    /**
     * Find the first PlayerEndOfGameStat that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerEndOfGameStatFindFirstArgs} args - Arguments to find a PlayerEndOfGameStat
     * @example
     * // Get one PlayerEndOfGameStat
     * const playerEndOfGameStat = await prisma.playerEndOfGameStat.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PlayerEndOfGameStatFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PlayerEndOfGameStatFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'PlayerEndOfGameStat'> extends True ? CheckSelect<T, Prisma__PlayerEndOfGameStatClient<PlayerEndOfGameStat>, Prisma__PlayerEndOfGameStatClient<PlayerEndOfGameStatGetPayload<T>>> : CheckSelect<T, Prisma__PlayerEndOfGameStatClient<PlayerEndOfGameStat | null >, Prisma__PlayerEndOfGameStatClient<PlayerEndOfGameStatGetPayload<T> | null >>

    /**
     * Find zero or more PlayerEndOfGameStats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerEndOfGameStatFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlayerEndOfGameStats
     * const playerEndOfGameStats = await prisma.playerEndOfGameStat.findMany()
     * 
     * // Get first 10 PlayerEndOfGameStats
     * const playerEndOfGameStats = await prisma.playerEndOfGameStat.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const playerEndOfGameStatWithIdOnly = await prisma.playerEndOfGameStat.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PlayerEndOfGameStatFindManyArgs>(
      args?: SelectSubset<T, PlayerEndOfGameStatFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<PlayerEndOfGameStat>>, PrismaPromise<Array<PlayerEndOfGameStatGetPayload<T>>>>

    /**
     * Create a PlayerEndOfGameStat.
     * @param {PlayerEndOfGameStatCreateArgs} args - Arguments to create a PlayerEndOfGameStat.
     * @example
     * // Create one PlayerEndOfGameStat
     * const PlayerEndOfGameStat = await prisma.playerEndOfGameStat.create({
     *   data: {
     *     // ... data to create a PlayerEndOfGameStat
     *   }
     * })
     * 
    **/
    create<T extends PlayerEndOfGameStatCreateArgs>(
      args: SelectSubset<T, PlayerEndOfGameStatCreateArgs>
    ): CheckSelect<T, Prisma__PlayerEndOfGameStatClient<PlayerEndOfGameStat>, Prisma__PlayerEndOfGameStatClient<PlayerEndOfGameStatGetPayload<T>>>

    /**
     * Create many PlayerEndOfGameStats.
     *     @param {PlayerEndOfGameStatCreateManyArgs} args - Arguments to create many PlayerEndOfGameStats.
     *     @example
     *     // Create many PlayerEndOfGameStats
     *     const playerEndOfGameStat = await prisma.playerEndOfGameStat.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PlayerEndOfGameStatCreateManyArgs>(
      args?: SelectSubset<T, PlayerEndOfGameStatCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a PlayerEndOfGameStat.
     * @param {PlayerEndOfGameStatDeleteArgs} args - Arguments to delete one PlayerEndOfGameStat.
     * @example
     * // Delete one PlayerEndOfGameStat
     * const PlayerEndOfGameStat = await prisma.playerEndOfGameStat.delete({
     *   where: {
     *     // ... filter to delete one PlayerEndOfGameStat
     *   }
     * })
     * 
    **/
    delete<T extends PlayerEndOfGameStatDeleteArgs>(
      args: SelectSubset<T, PlayerEndOfGameStatDeleteArgs>
    ): CheckSelect<T, Prisma__PlayerEndOfGameStatClient<PlayerEndOfGameStat>, Prisma__PlayerEndOfGameStatClient<PlayerEndOfGameStatGetPayload<T>>>

    /**
     * Update one PlayerEndOfGameStat.
     * @param {PlayerEndOfGameStatUpdateArgs} args - Arguments to update one PlayerEndOfGameStat.
     * @example
     * // Update one PlayerEndOfGameStat
     * const playerEndOfGameStat = await prisma.playerEndOfGameStat.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PlayerEndOfGameStatUpdateArgs>(
      args: SelectSubset<T, PlayerEndOfGameStatUpdateArgs>
    ): CheckSelect<T, Prisma__PlayerEndOfGameStatClient<PlayerEndOfGameStat>, Prisma__PlayerEndOfGameStatClient<PlayerEndOfGameStatGetPayload<T>>>

    /**
     * Delete zero or more PlayerEndOfGameStats.
     * @param {PlayerEndOfGameStatDeleteManyArgs} args - Arguments to filter PlayerEndOfGameStats to delete.
     * @example
     * // Delete a few PlayerEndOfGameStats
     * const { count } = await prisma.playerEndOfGameStat.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PlayerEndOfGameStatDeleteManyArgs>(
      args?: SelectSubset<T, PlayerEndOfGameStatDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlayerEndOfGameStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerEndOfGameStatUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlayerEndOfGameStats
     * const playerEndOfGameStat = await prisma.playerEndOfGameStat.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PlayerEndOfGameStatUpdateManyArgs>(
      args: SelectSubset<T, PlayerEndOfGameStatUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one PlayerEndOfGameStat.
     * @param {PlayerEndOfGameStatUpsertArgs} args - Arguments to update or create a PlayerEndOfGameStat.
     * @example
     * // Update or create a PlayerEndOfGameStat
     * const playerEndOfGameStat = await prisma.playerEndOfGameStat.upsert({
     *   create: {
     *     // ... data to create a PlayerEndOfGameStat
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlayerEndOfGameStat we want to update
     *   }
     * })
    **/
    upsert<T extends PlayerEndOfGameStatUpsertArgs>(
      args: SelectSubset<T, PlayerEndOfGameStatUpsertArgs>
    ): CheckSelect<T, Prisma__PlayerEndOfGameStatClient<PlayerEndOfGameStat>, Prisma__PlayerEndOfGameStatClient<PlayerEndOfGameStatGetPayload<T>>>

    /**
     * Count the number of PlayerEndOfGameStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerEndOfGameStatCountArgs} args - Arguments to filter PlayerEndOfGameStats to count.
     * @example
     * // Count the number of PlayerEndOfGameStats
     * const count = await prisma.playerEndOfGameStat.count({
     *   where: {
     *     // ... the filter for the PlayerEndOfGameStats we want to count
     *   }
     * })
    **/
    count<T extends PlayerEndOfGameStatCountArgs>(
      args?: Subset<T, PlayerEndOfGameStatCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlayerEndOfGameStatCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlayerEndOfGameStat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerEndOfGameStatAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlayerEndOfGameStatAggregateArgs>(args: Subset<T, PlayerEndOfGameStatAggregateArgs>): PrismaPromise<GetPlayerEndOfGameStatAggregateType<T>>

    /**
     * Group by PlayerEndOfGameStat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerEndOfGameStatGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlayerEndOfGameStatGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlayerEndOfGameStatGroupByArgs['orderBy'] }
        : { orderBy?: PlayerEndOfGameStatGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlayerEndOfGameStatGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlayerEndOfGameStatGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlayerEndOfGameStat.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PlayerEndOfGameStatClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    player<T extends PlayerArgs = {}>(args?: Subset<T, PlayerArgs>): CheckSelect<T, Prisma__PlayerClient<Player | null >, Prisma__PlayerClient<PlayerGetPayload<T> | null >>;

    game<T extends GameArgs = {}>(args?: Subset<T, GameArgs>): CheckSelect<T, Prisma__GameClient<Game | null >, Prisma__GameClient<GameGetPayload<T> | null >>;

    perks<T extends PlayerRuneArgs = {}>(args?: Subset<T, PlayerRuneArgs>): CheckSelect<T, Prisma__PlayerRuneClient<PlayerRune | null >, Prisma__PlayerRuneClient<PlayerRuneGetPayload<T> | null >>;

    items<T extends PlayerItemArgs = {}>(args?: Subset<T, PlayerItemArgs>): CheckSelect<T, Prisma__PlayerItemClient<PlayerItem | null >, Prisma__PlayerItemClient<PlayerItemGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * PlayerEndOfGameStat findUnique
   */
  export type PlayerEndOfGameStatFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the PlayerEndOfGameStat
     * 
    **/
    select?: PlayerEndOfGameStatSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PlayerEndOfGameStatInclude | null
    /**
     * Throw an Error if a PlayerEndOfGameStat can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which PlayerEndOfGameStat to fetch.
     * 
    **/
    where: PlayerEndOfGameStatWhereUniqueInput
  }


  /**
   * PlayerEndOfGameStat findFirst
   */
  export type PlayerEndOfGameStatFindFirstArgs = {
    /**
     * Select specific fields to fetch from the PlayerEndOfGameStat
     * 
    **/
    select?: PlayerEndOfGameStatSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PlayerEndOfGameStatInclude | null
    /**
     * Throw an Error if a PlayerEndOfGameStat can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which PlayerEndOfGameStat to fetch.
     * 
    **/
    where?: PlayerEndOfGameStatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerEndOfGameStats to fetch.
     * 
    **/
    orderBy?: Enumerable<PlayerEndOfGameStatOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlayerEndOfGameStats.
     * 
    **/
    cursor?: PlayerEndOfGameStatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerEndOfGameStats from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerEndOfGameStats.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlayerEndOfGameStats.
     * 
    **/
    distinct?: Enumerable<PlayerEndOfGameStatScalarFieldEnum>
  }


  /**
   * PlayerEndOfGameStat findMany
   */
  export type PlayerEndOfGameStatFindManyArgs = {
    /**
     * Select specific fields to fetch from the PlayerEndOfGameStat
     * 
    **/
    select?: PlayerEndOfGameStatSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PlayerEndOfGameStatInclude | null
    /**
     * Filter, which PlayerEndOfGameStats to fetch.
     * 
    **/
    where?: PlayerEndOfGameStatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerEndOfGameStats to fetch.
     * 
    **/
    orderBy?: Enumerable<PlayerEndOfGameStatOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlayerEndOfGameStats.
     * 
    **/
    cursor?: PlayerEndOfGameStatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerEndOfGameStats from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerEndOfGameStats.
     * 
    **/
    skip?: number
    distinct?: Enumerable<PlayerEndOfGameStatScalarFieldEnum>
  }


  /**
   * PlayerEndOfGameStat create
   */
  export type PlayerEndOfGameStatCreateArgs = {
    /**
     * Select specific fields to fetch from the PlayerEndOfGameStat
     * 
    **/
    select?: PlayerEndOfGameStatSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PlayerEndOfGameStatInclude | null
    /**
     * The data needed to create a PlayerEndOfGameStat.
     * 
    **/
    data: XOR<PlayerEndOfGameStatCreateInput, PlayerEndOfGameStatUncheckedCreateInput>
  }


  /**
   * PlayerEndOfGameStat createMany
   */
  export type PlayerEndOfGameStatCreateManyArgs = {
    /**
     * The data used to create many PlayerEndOfGameStats.
     * 
    **/
    data: Enumerable<PlayerEndOfGameStatCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * PlayerEndOfGameStat update
   */
  export type PlayerEndOfGameStatUpdateArgs = {
    /**
     * Select specific fields to fetch from the PlayerEndOfGameStat
     * 
    **/
    select?: PlayerEndOfGameStatSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PlayerEndOfGameStatInclude | null
    /**
     * The data needed to update a PlayerEndOfGameStat.
     * 
    **/
    data: XOR<PlayerEndOfGameStatUpdateInput, PlayerEndOfGameStatUncheckedUpdateInput>
    /**
     * Choose, which PlayerEndOfGameStat to update.
     * 
    **/
    where: PlayerEndOfGameStatWhereUniqueInput
  }


  /**
   * PlayerEndOfGameStat updateMany
   */
  export type PlayerEndOfGameStatUpdateManyArgs = {
    /**
     * The data used to update PlayerEndOfGameStats.
     * 
    **/
    data: XOR<PlayerEndOfGameStatUpdateManyMutationInput, PlayerEndOfGameStatUncheckedUpdateManyInput>
    /**
     * Filter which PlayerEndOfGameStats to update
     * 
    **/
    where?: PlayerEndOfGameStatWhereInput
  }


  /**
   * PlayerEndOfGameStat upsert
   */
  export type PlayerEndOfGameStatUpsertArgs = {
    /**
     * Select specific fields to fetch from the PlayerEndOfGameStat
     * 
    **/
    select?: PlayerEndOfGameStatSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PlayerEndOfGameStatInclude | null
    /**
     * The filter to search for the PlayerEndOfGameStat to update in case it exists.
     * 
    **/
    where: PlayerEndOfGameStatWhereUniqueInput
    /**
     * In case the PlayerEndOfGameStat found by the `where` argument doesn't exist, create a new PlayerEndOfGameStat with this data.
     * 
    **/
    create: XOR<PlayerEndOfGameStatCreateInput, PlayerEndOfGameStatUncheckedCreateInput>
    /**
     * In case the PlayerEndOfGameStat was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<PlayerEndOfGameStatUpdateInput, PlayerEndOfGameStatUncheckedUpdateInput>
  }


  /**
   * PlayerEndOfGameStat delete
   */
  export type PlayerEndOfGameStatDeleteArgs = {
    /**
     * Select specific fields to fetch from the PlayerEndOfGameStat
     * 
    **/
    select?: PlayerEndOfGameStatSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PlayerEndOfGameStatInclude | null
    /**
     * Filter which PlayerEndOfGameStat to delete.
     * 
    **/
    where: PlayerEndOfGameStatWhereUniqueInput
  }


  /**
   * PlayerEndOfGameStat deleteMany
   */
  export type PlayerEndOfGameStatDeleteManyArgs = {
    /**
     * Filter which PlayerEndOfGameStats to delete
     * 
    **/
    where?: PlayerEndOfGameStatWhereInput
  }


  /**
   * PlayerEndOfGameStat without action
   */
  export type PlayerEndOfGameStatArgs = {
    /**
     * Select specific fields to fetch from the PlayerEndOfGameStat
     * 
    **/
    select?: PlayerEndOfGameStatSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PlayerEndOfGameStatInclude | null
  }



  /**
   * Model PlayerItem
   */


  export type AggregatePlayerItem = {
    _count: PlayerItemCountAggregateOutputType | null
    _avg: PlayerItemAvgAggregateOutputType | null
    _sum: PlayerItemSumAggregateOutputType | null
    _min: PlayerItemMinAggregateOutputType | null
    _max: PlayerItemMaxAggregateOutputType | null
  }

  export type PlayerItemAvgAggregateOutputType = {
    slot: number | null
    itemId: number | null
  }

  export type PlayerItemSumAggregateOutputType = {
    slot: number | null
    itemId: number | null
  }

  export type PlayerItemMinAggregateOutputType = {
    id: string | null
    slot: number | null
    itemId: number | null
    name: string | null
  }

  export type PlayerItemMaxAggregateOutputType = {
    id: string | null
    slot: number | null
    itemId: number | null
    name: string | null
  }

  export type PlayerItemCountAggregateOutputType = {
    id: number
    slot: number
    itemId: number
    name: number
    _all: number
  }


  export type PlayerItemAvgAggregateInputType = {
    slot?: true
    itemId?: true
  }

  export type PlayerItemSumAggregateInputType = {
    slot?: true
    itemId?: true
  }

  export type PlayerItemMinAggregateInputType = {
    id?: true
    slot?: true
    itemId?: true
    name?: true
  }

  export type PlayerItemMaxAggregateInputType = {
    id?: true
    slot?: true
    itemId?: true
    name?: true
  }

  export type PlayerItemCountAggregateInputType = {
    id?: true
    slot?: true
    itemId?: true
    name?: true
    _all?: true
  }

  export type PlayerItemAggregateArgs = {
    /**
     * Filter which PlayerItem to aggregate.
     * 
    **/
    where?: PlayerItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerItems to fetch.
     * 
    **/
    orderBy?: Enumerable<PlayerItemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: PlayerItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerItems from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerItems.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlayerItems
    **/
    _count?: true | PlayerItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlayerItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlayerItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlayerItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlayerItemMaxAggregateInputType
  }

  export type GetPlayerItemAggregateType<T extends PlayerItemAggregateArgs> = {
        [P in keyof T & keyof AggregatePlayerItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlayerItem[P]>
      : GetScalarType<T[P], AggregatePlayerItem[P]>
  }




  export type PlayerItemGroupByArgs = {
    where?: PlayerItemWhereInput
    orderBy?: Enumerable<PlayerItemOrderByWithAggregationInput>
    by: Array<PlayerItemScalarFieldEnum>
    having?: PlayerItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlayerItemCountAggregateInputType | true
    _avg?: PlayerItemAvgAggregateInputType
    _sum?: PlayerItemSumAggregateInputType
    _min?: PlayerItemMinAggregateInputType
    _max?: PlayerItemMaxAggregateInputType
  }


  export type PlayerItemGroupByOutputType = {
    id: string
    slot: number | null
    itemId: number | null
    name: string
    _count: PlayerItemCountAggregateOutputType | null
    _avg: PlayerItemAvgAggregateOutputType | null
    _sum: PlayerItemSumAggregateOutputType | null
    _min: PlayerItemMinAggregateOutputType | null
    _max: PlayerItemMaxAggregateOutputType | null
  }

  type GetPlayerItemGroupByPayload<T extends PlayerItemGroupByArgs> = PrismaPromise<
    Array<
      PickArray<PlayerItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlayerItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlayerItemGroupByOutputType[P]>
            : GetScalarType<T[P], PlayerItemGroupByOutputType[P]>
        }
      >
    >


  export type PlayerItemSelect = {
    id?: boolean
    slot?: boolean
    itemId?: boolean
    name?: boolean
    playerEndOfGameStat?: boolean | PlayerEndOfGameStatFindManyArgs
    _count?: boolean | PlayerItemCountOutputTypeArgs
  }

  export type PlayerItemInclude = {
    playerEndOfGameStat?: boolean | PlayerEndOfGameStatFindManyArgs
    _count?: boolean | PlayerItemCountOutputTypeArgs
  }

  export type PlayerItemGetPayload<
    S extends boolean | null | undefined | PlayerItemArgs,
    U = keyof S
      > = S extends true
        ? PlayerItem
    : S extends undefined
    ? never
    : S extends PlayerItemArgs | PlayerItemFindManyArgs
    ?'include' extends U
    ? PlayerItem  & {
    [P in TrueKeys<S['include']>]:
        P extends 'playerEndOfGameStat' ? Array < PlayerEndOfGameStatGetPayload<S['include'][P]>>  :
        P extends '_count' ? PlayerItemCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'playerEndOfGameStat' ? Array < PlayerEndOfGameStatGetPayload<S['select'][P]>>  :
        P extends '_count' ? PlayerItemCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof PlayerItem ? PlayerItem[P] : never
  } 
    : PlayerItem
  : PlayerItem


  type PlayerItemCountArgs = Merge<
    Omit<PlayerItemFindManyArgs, 'select' | 'include'> & {
      select?: PlayerItemCountAggregateInputType | true
    }
  >

  export interface PlayerItemDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one PlayerItem that matches the filter.
     * @param {PlayerItemFindUniqueArgs} args - Arguments to find a PlayerItem
     * @example
     * // Get one PlayerItem
     * const playerItem = await prisma.playerItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PlayerItemFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PlayerItemFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'PlayerItem'> extends True ? CheckSelect<T, Prisma__PlayerItemClient<PlayerItem>, Prisma__PlayerItemClient<PlayerItemGetPayload<T>>> : CheckSelect<T, Prisma__PlayerItemClient<PlayerItem | null >, Prisma__PlayerItemClient<PlayerItemGetPayload<T> | null >>

    /**
     * Find the first PlayerItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerItemFindFirstArgs} args - Arguments to find a PlayerItem
     * @example
     * // Get one PlayerItem
     * const playerItem = await prisma.playerItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PlayerItemFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PlayerItemFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'PlayerItem'> extends True ? CheckSelect<T, Prisma__PlayerItemClient<PlayerItem>, Prisma__PlayerItemClient<PlayerItemGetPayload<T>>> : CheckSelect<T, Prisma__PlayerItemClient<PlayerItem | null >, Prisma__PlayerItemClient<PlayerItemGetPayload<T> | null >>

    /**
     * Find zero or more PlayerItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerItemFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlayerItems
     * const playerItems = await prisma.playerItem.findMany()
     * 
     * // Get first 10 PlayerItems
     * const playerItems = await prisma.playerItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const playerItemWithIdOnly = await prisma.playerItem.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PlayerItemFindManyArgs>(
      args?: SelectSubset<T, PlayerItemFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<PlayerItem>>, PrismaPromise<Array<PlayerItemGetPayload<T>>>>

    /**
     * Create a PlayerItem.
     * @param {PlayerItemCreateArgs} args - Arguments to create a PlayerItem.
     * @example
     * // Create one PlayerItem
     * const PlayerItem = await prisma.playerItem.create({
     *   data: {
     *     // ... data to create a PlayerItem
     *   }
     * })
     * 
    **/
    create<T extends PlayerItemCreateArgs>(
      args: SelectSubset<T, PlayerItemCreateArgs>
    ): CheckSelect<T, Prisma__PlayerItemClient<PlayerItem>, Prisma__PlayerItemClient<PlayerItemGetPayload<T>>>

    /**
     * Create many PlayerItems.
     *     @param {PlayerItemCreateManyArgs} args - Arguments to create many PlayerItems.
     *     @example
     *     // Create many PlayerItems
     *     const playerItem = await prisma.playerItem.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PlayerItemCreateManyArgs>(
      args?: SelectSubset<T, PlayerItemCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a PlayerItem.
     * @param {PlayerItemDeleteArgs} args - Arguments to delete one PlayerItem.
     * @example
     * // Delete one PlayerItem
     * const PlayerItem = await prisma.playerItem.delete({
     *   where: {
     *     // ... filter to delete one PlayerItem
     *   }
     * })
     * 
    **/
    delete<T extends PlayerItemDeleteArgs>(
      args: SelectSubset<T, PlayerItemDeleteArgs>
    ): CheckSelect<T, Prisma__PlayerItemClient<PlayerItem>, Prisma__PlayerItemClient<PlayerItemGetPayload<T>>>

    /**
     * Update one PlayerItem.
     * @param {PlayerItemUpdateArgs} args - Arguments to update one PlayerItem.
     * @example
     * // Update one PlayerItem
     * const playerItem = await prisma.playerItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PlayerItemUpdateArgs>(
      args: SelectSubset<T, PlayerItemUpdateArgs>
    ): CheckSelect<T, Prisma__PlayerItemClient<PlayerItem>, Prisma__PlayerItemClient<PlayerItemGetPayload<T>>>

    /**
     * Delete zero or more PlayerItems.
     * @param {PlayerItemDeleteManyArgs} args - Arguments to filter PlayerItems to delete.
     * @example
     * // Delete a few PlayerItems
     * const { count } = await prisma.playerItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PlayerItemDeleteManyArgs>(
      args?: SelectSubset<T, PlayerItemDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlayerItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlayerItems
     * const playerItem = await prisma.playerItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PlayerItemUpdateManyArgs>(
      args: SelectSubset<T, PlayerItemUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one PlayerItem.
     * @param {PlayerItemUpsertArgs} args - Arguments to update or create a PlayerItem.
     * @example
     * // Update or create a PlayerItem
     * const playerItem = await prisma.playerItem.upsert({
     *   create: {
     *     // ... data to create a PlayerItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlayerItem we want to update
     *   }
     * })
    **/
    upsert<T extends PlayerItemUpsertArgs>(
      args: SelectSubset<T, PlayerItemUpsertArgs>
    ): CheckSelect<T, Prisma__PlayerItemClient<PlayerItem>, Prisma__PlayerItemClient<PlayerItemGetPayload<T>>>

    /**
     * Count the number of PlayerItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerItemCountArgs} args - Arguments to filter PlayerItems to count.
     * @example
     * // Count the number of PlayerItems
     * const count = await prisma.playerItem.count({
     *   where: {
     *     // ... the filter for the PlayerItems we want to count
     *   }
     * })
    **/
    count<T extends PlayerItemCountArgs>(
      args?: Subset<T, PlayerItemCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlayerItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlayerItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlayerItemAggregateArgs>(args: Subset<T, PlayerItemAggregateArgs>): PrismaPromise<GetPlayerItemAggregateType<T>>

    /**
     * Group by PlayerItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlayerItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlayerItemGroupByArgs['orderBy'] }
        : { orderBy?: PlayerItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlayerItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlayerItemGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlayerItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PlayerItemClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    playerEndOfGameStat<T extends PlayerEndOfGameStatFindManyArgs = {}>(args?: Subset<T, PlayerEndOfGameStatFindManyArgs>): CheckSelect<T, PrismaPromise<Array<PlayerEndOfGameStat>>, PrismaPromise<Array<PlayerEndOfGameStatGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * PlayerItem findUnique
   */
  export type PlayerItemFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the PlayerItem
     * 
    **/
    select?: PlayerItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PlayerItemInclude | null
    /**
     * Throw an Error if a PlayerItem can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which PlayerItem to fetch.
     * 
    **/
    where: PlayerItemWhereUniqueInput
  }


  /**
   * PlayerItem findFirst
   */
  export type PlayerItemFindFirstArgs = {
    /**
     * Select specific fields to fetch from the PlayerItem
     * 
    **/
    select?: PlayerItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PlayerItemInclude | null
    /**
     * Throw an Error if a PlayerItem can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which PlayerItem to fetch.
     * 
    **/
    where?: PlayerItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerItems to fetch.
     * 
    **/
    orderBy?: Enumerable<PlayerItemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlayerItems.
     * 
    **/
    cursor?: PlayerItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerItems from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerItems.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlayerItems.
     * 
    **/
    distinct?: Enumerable<PlayerItemScalarFieldEnum>
  }


  /**
   * PlayerItem findMany
   */
  export type PlayerItemFindManyArgs = {
    /**
     * Select specific fields to fetch from the PlayerItem
     * 
    **/
    select?: PlayerItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PlayerItemInclude | null
    /**
     * Filter, which PlayerItems to fetch.
     * 
    **/
    where?: PlayerItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerItems to fetch.
     * 
    **/
    orderBy?: Enumerable<PlayerItemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlayerItems.
     * 
    **/
    cursor?: PlayerItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerItems from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerItems.
     * 
    **/
    skip?: number
    distinct?: Enumerable<PlayerItemScalarFieldEnum>
  }


  /**
   * PlayerItem create
   */
  export type PlayerItemCreateArgs = {
    /**
     * Select specific fields to fetch from the PlayerItem
     * 
    **/
    select?: PlayerItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PlayerItemInclude | null
    /**
     * The data needed to create a PlayerItem.
     * 
    **/
    data: XOR<PlayerItemCreateInput, PlayerItemUncheckedCreateInput>
  }


  /**
   * PlayerItem createMany
   */
  export type PlayerItemCreateManyArgs = {
    /**
     * The data used to create many PlayerItems.
     * 
    **/
    data: Enumerable<PlayerItemCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * PlayerItem update
   */
  export type PlayerItemUpdateArgs = {
    /**
     * Select specific fields to fetch from the PlayerItem
     * 
    **/
    select?: PlayerItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PlayerItemInclude | null
    /**
     * The data needed to update a PlayerItem.
     * 
    **/
    data: XOR<PlayerItemUpdateInput, PlayerItemUncheckedUpdateInput>
    /**
     * Choose, which PlayerItem to update.
     * 
    **/
    where: PlayerItemWhereUniqueInput
  }


  /**
   * PlayerItem updateMany
   */
  export type PlayerItemUpdateManyArgs = {
    /**
     * The data used to update PlayerItems.
     * 
    **/
    data: XOR<PlayerItemUpdateManyMutationInput, PlayerItemUncheckedUpdateManyInput>
    /**
     * Filter which PlayerItems to update
     * 
    **/
    where?: PlayerItemWhereInput
  }


  /**
   * PlayerItem upsert
   */
  export type PlayerItemUpsertArgs = {
    /**
     * Select specific fields to fetch from the PlayerItem
     * 
    **/
    select?: PlayerItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PlayerItemInclude | null
    /**
     * The filter to search for the PlayerItem to update in case it exists.
     * 
    **/
    where: PlayerItemWhereUniqueInput
    /**
     * In case the PlayerItem found by the `where` argument doesn't exist, create a new PlayerItem with this data.
     * 
    **/
    create: XOR<PlayerItemCreateInput, PlayerItemUncheckedCreateInput>
    /**
     * In case the PlayerItem was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<PlayerItemUpdateInput, PlayerItemUncheckedUpdateInput>
  }


  /**
   * PlayerItem delete
   */
  export type PlayerItemDeleteArgs = {
    /**
     * Select specific fields to fetch from the PlayerItem
     * 
    **/
    select?: PlayerItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PlayerItemInclude | null
    /**
     * Filter which PlayerItem to delete.
     * 
    **/
    where: PlayerItemWhereUniqueInput
  }


  /**
   * PlayerItem deleteMany
   */
  export type PlayerItemDeleteManyArgs = {
    /**
     * Filter which PlayerItems to delete
     * 
    **/
    where?: PlayerItemWhereInput
  }


  /**
   * PlayerItem without action
   */
  export type PlayerItemArgs = {
    /**
     * Select specific fields to fetch from the PlayerItem
     * 
    **/
    select?: PlayerItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PlayerItemInclude | null
  }



  /**
   * Model PlayerItemEvent
   */


  export type AggregatePlayerItemEvent = {
    _count: PlayerItemEventCountAggregateOutputType | null
    _avg: PlayerItemEventAvgAggregateOutputType | null
    _sum: PlayerItemEventSumAggregateOutputType | null
    _min: PlayerItemEventMinAggregateOutputType | null
    _max: PlayerItemEventMaxAggregateOutputType | null
  }

  export type PlayerItemEventAvgAggregateOutputType = {
    itemId: number | null
    undoId: number | null
  }

  export type PlayerItemEventSumAggregateOutputType = {
    itemId: number | null
    undoId: number | null
  }

  export type PlayerItemEventMinAggregateOutputType = {
    id: string | null
    type: string | null
    itemId: number | null
    name: string | null
    undoId: number | null
  }

  export type PlayerItemEventMaxAggregateOutputType = {
    id: string | null
    type: string | null
    itemId: number | null
    name: string | null
    undoId: number | null
  }

  export type PlayerItemEventCountAggregateOutputType = {
    id: number
    type: number
    itemId: number
    name: number
    undoId: number
    _all: number
  }


  export type PlayerItemEventAvgAggregateInputType = {
    itemId?: true
    undoId?: true
  }

  export type PlayerItemEventSumAggregateInputType = {
    itemId?: true
    undoId?: true
  }

  export type PlayerItemEventMinAggregateInputType = {
    id?: true
    type?: true
    itemId?: true
    name?: true
    undoId?: true
  }

  export type PlayerItemEventMaxAggregateInputType = {
    id?: true
    type?: true
    itemId?: true
    name?: true
    undoId?: true
  }

  export type PlayerItemEventCountAggregateInputType = {
    id?: true
    type?: true
    itemId?: true
    name?: true
    undoId?: true
    _all?: true
  }

  export type PlayerItemEventAggregateArgs = {
    /**
     * Filter which PlayerItemEvent to aggregate.
     * 
    **/
    where?: PlayerItemEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerItemEvents to fetch.
     * 
    **/
    orderBy?: Enumerable<PlayerItemEventOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: PlayerItemEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerItemEvents from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerItemEvents.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlayerItemEvents
    **/
    _count?: true | PlayerItemEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlayerItemEventAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlayerItemEventSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlayerItemEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlayerItemEventMaxAggregateInputType
  }

  export type GetPlayerItemEventAggregateType<T extends PlayerItemEventAggregateArgs> = {
        [P in keyof T & keyof AggregatePlayerItemEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlayerItemEvent[P]>
      : GetScalarType<T[P], AggregatePlayerItemEvent[P]>
  }




  export type PlayerItemEventGroupByArgs = {
    where?: PlayerItemEventWhereInput
    orderBy?: Enumerable<PlayerItemEventOrderByWithAggregationInput>
    by: Array<PlayerItemEventScalarFieldEnum>
    having?: PlayerItemEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlayerItemEventCountAggregateInputType | true
    _avg?: PlayerItemEventAvgAggregateInputType
    _sum?: PlayerItemEventSumAggregateInputType
    _min?: PlayerItemEventMinAggregateInputType
    _max?: PlayerItemEventMaxAggregateInputType
  }


  export type PlayerItemEventGroupByOutputType = {
    id: string
    type: string
    itemId: number | null
    name: string
    undoId: number | null
    _count: PlayerItemEventCountAggregateOutputType | null
    _avg: PlayerItemEventAvgAggregateOutputType | null
    _sum: PlayerItemEventSumAggregateOutputType | null
    _min: PlayerItemEventMinAggregateOutputType | null
    _max: PlayerItemEventMaxAggregateOutputType | null
  }

  type GetPlayerItemEventGroupByPayload<T extends PlayerItemEventGroupByArgs> = PrismaPromise<
    Array<
      PickArray<PlayerItemEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlayerItemEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlayerItemEventGroupByOutputType[P]>
            : GetScalarType<T[P], PlayerItemEventGroupByOutputType[P]>
        }
      >
    >


  export type PlayerItemEventSelect = {
    id?: boolean
    player?: boolean | PlayerFindManyArgs
    type?: boolean
    itemId?: boolean
    name?: boolean
    undoId?: boolean
    _count?: boolean | PlayerItemEventCountOutputTypeArgs
  }

  export type PlayerItemEventInclude = {
    player?: boolean | PlayerFindManyArgs
    _count?: boolean | PlayerItemEventCountOutputTypeArgs
  }

  export type PlayerItemEventGetPayload<
    S extends boolean | null | undefined | PlayerItemEventArgs,
    U = keyof S
      > = S extends true
        ? PlayerItemEvent
    : S extends undefined
    ? never
    : S extends PlayerItemEventArgs | PlayerItemEventFindManyArgs
    ?'include' extends U
    ? PlayerItemEvent  & {
    [P in TrueKeys<S['include']>]:
        P extends 'player' ? Array < PlayerGetPayload<S['include'][P]>>  :
        P extends '_count' ? PlayerItemEventCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'player' ? Array < PlayerGetPayload<S['select'][P]>>  :
        P extends '_count' ? PlayerItemEventCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof PlayerItemEvent ? PlayerItemEvent[P] : never
  } 
    : PlayerItemEvent
  : PlayerItemEvent


  type PlayerItemEventCountArgs = Merge<
    Omit<PlayerItemEventFindManyArgs, 'select' | 'include'> & {
      select?: PlayerItemEventCountAggregateInputType | true
    }
  >

  export interface PlayerItemEventDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one PlayerItemEvent that matches the filter.
     * @param {PlayerItemEventFindUniqueArgs} args - Arguments to find a PlayerItemEvent
     * @example
     * // Get one PlayerItemEvent
     * const playerItemEvent = await prisma.playerItemEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PlayerItemEventFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PlayerItemEventFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'PlayerItemEvent'> extends True ? CheckSelect<T, Prisma__PlayerItemEventClient<PlayerItemEvent>, Prisma__PlayerItemEventClient<PlayerItemEventGetPayload<T>>> : CheckSelect<T, Prisma__PlayerItemEventClient<PlayerItemEvent | null >, Prisma__PlayerItemEventClient<PlayerItemEventGetPayload<T> | null >>

    /**
     * Find the first PlayerItemEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerItemEventFindFirstArgs} args - Arguments to find a PlayerItemEvent
     * @example
     * // Get one PlayerItemEvent
     * const playerItemEvent = await prisma.playerItemEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PlayerItemEventFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PlayerItemEventFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'PlayerItemEvent'> extends True ? CheckSelect<T, Prisma__PlayerItemEventClient<PlayerItemEvent>, Prisma__PlayerItemEventClient<PlayerItemEventGetPayload<T>>> : CheckSelect<T, Prisma__PlayerItemEventClient<PlayerItemEvent | null >, Prisma__PlayerItemEventClient<PlayerItemEventGetPayload<T> | null >>

    /**
     * Find zero or more PlayerItemEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerItemEventFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlayerItemEvents
     * const playerItemEvents = await prisma.playerItemEvent.findMany()
     * 
     * // Get first 10 PlayerItemEvents
     * const playerItemEvents = await prisma.playerItemEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const playerItemEventWithIdOnly = await prisma.playerItemEvent.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PlayerItemEventFindManyArgs>(
      args?: SelectSubset<T, PlayerItemEventFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<PlayerItemEvent>>, PrismaPromise<Array<PlayerItemEventGetPayload<T>>>>

    /**
     * Create a PlayerItemEvent.
     * @param {PlayerItemEventCreateArgs} args - Arguments to create a PlayerItemEvent.
     * @example
     * // Create one PlayerItemEvent
     * const PlayerItemEvent = await prisma.playerItemEvent.create({
     *   data: {
     *     // ... data to create a PlayerItemEvent
     *   }
     * })
     * 
    **/
    create<T extends PlayerItemEventCreateArgs>(
      args: SelectSubset<T, PlayerItemEventCreateArgs>
    ): CheckSelect<T, Prisma__PlayerItemEventClient<PlayerItemEvent>, Prisma__PlayerItemEventClient<PlayerItemEventGetPayload<T>>>

    /**
     * Create many PlayerItemEvents.
     *     @param {PlayerItemEventCreateManyArgs} args - Arguments to create many PlayerItemEvents.
     *     @example
     *     // Create many PlayerItemEvents
     *     const playerItemEvent = await prisma.playerItemEvent.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PlayerItemEventCreateManyArgs>(
      args?: SelectSubset<T, PlayerItemEventCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a PlayerItemEvent.
     * @param {PlayerItemEventDeleteArgs} args - Arguments to delete one PlayerItemEvent.
     * @example
     * // Delete one PlayerItemEvent
     * const PlayerItemEvent = await prisma.playerItemEvent.delete({
     *   where: {
     *     // ... filter to delete one PlayerItemEvent
     *   }
     * })
     * 
    **/
    delete<T extends PlayerItemEventDeleteArgs>(
      args: SelectSubset<T, PlayerItemEventDeleteArgs>
    ): CheckSelect<T, Prisma__PlayerItemEventClient<PlayerItemEvent>, Prisma__PlayerItemEventClient<PlayerItemEventGetPayload<T>>>

    /**
     * Update one PlayerItemEvent.
     * @param {PlayerItemEventUpdateArgs} args - Arguments to update one PlayerItemEvent.
     * @example
     * // Update one PlayerItemEvent
     * const playerItemEvent = await prisma.playerItemEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PlayerItemEventUpdateArgs>(
      args: SelectSubset<T, PlayerItemEventUpdateArgs>
    ): CheckSelect<T, Prisma__PlayerItemEventClient<PlayerItemEvent>, Prisma__PlayerItemEventClient<PlayerItemEventGetPayload<T>>>

    /**
     * Delete zero or more PlayerItemEvents.
     * @param {PlayerItemEventDeleteManyArgs} args - Arguments to filter PlayerItemEvents to delete.
     * @example
     * // Delete a few PlayerItemEvents
     * const { count } = await prisma.playerItemEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PlayerItemEventDeleteManyArgs>(
      args?: SelectSubset<T, PlayerItemEventDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlayerItemEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerItemEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlayerItemEvents
     * const playerItemEvent = await prisma.playerItemEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PlayerItemEventUpdateManyArgs>(
      args: SelectSubset<T, PlayerItemEventUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one PlayerItemEvent.
     * @param {PlayerItemEventUpsertArgs} args - Arguments to update or create a PlayerItemEvent.
     * @example
     * // Update or create a PlayerItemEvent
     * const playerItemEvent = await prisma.playerItemEvent.upsert({
     *   create: {
     *     // ... data to create a PlayerItemEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlayerItemEvent we want to update
     *   }
     * })
    **/
    upsert<T extends PlayerItemEventUpsertArgs>(
      args: SelectSubset<T, PlayerItemEventUpsertArgs>
    ): CheckSelect<T, Prisma__PlayerItemEventClient<PlayerItemEvent>, Prisma__PlayerItemEventClient<PlayerItemEventGetPayload<T>>>

    /**
     * Count the number of PlayerItemEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerItemEventCountArgs} args - Arguments to filter PlayerItemEvents to count.
     * @example
     * // Count the number of PlayerItemEvents
     * const count = await prisma.playerItemEvent.count({
     *   where: {
     *     // ... the filter for the PlayerItemEvents we want to count
     *   }
     * })
    **/
    count<T extends PlayerItemEventCountArgs>(
      args?: Subset<T, PlayerItemEventCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlayerItemEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlayerItemEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerItemEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlayerItemEventAggregateArgs>(args: Subset<T, PlayerItemEventAggregateArgs>): PrismaPromise<GetPlayerItemEventAggregateType<T>>

    /**
     * Group by PlayerItemEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerItemEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlayerItemEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlayerItemEventGroupByArgs['orderBy'] }
        : { orderBy?: PlayerItemEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlayerItemEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlayerItemEventGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlayerItemEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PlayerItemEventClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    player<T extends PlayerFindManyArgs = {}>(args?: Subset<T, PlayerFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Player>>, PrismaPromise<Array<PlayerGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * PlayerItemEvent findUnique
   */
  export type PlayerItemEventFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the PlayerItemEvent
     * 
    **/
    select?: PlayerItemEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PlayerItemEventInclude | null
    /**
     * Throw an Error if a PlayerItemEvent can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which PlayerItemEvent to fetch.
     * 
    **/
    where: PlayerItemEventWhereUniqueInput
  }


  /**
   * PlayerItemEvent findFirst
   */
  export type PlayerItemEventFindFirstArgs = {
    /**
     * Select specific fields to fetch from the PlayerItemEvent
     * 
    **/
    select?: PlayerItemEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PlayerItemEventInclude | null
    /**
     * Throw an Error if a PlayerItemEvent can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which PlayerItemEvent to fetch.
     * 
    **/
    where?: PlayerItemEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerItemEvents to fetch.
     * 
    **/
    orderBy?: Enumerable<PlayerItemEventOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlayerItemEvents.
     * 
    **/
    cursor?: PlayerItemEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerItemEvents from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerItemEvents.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlayerItemEvents.
     * 
    **/
    distinct?: Enumerable<PlayerItemEventScalarFieldEnum>
  }


  /**
   * PlayerItemEvent findMany
   */
  export type PlayerItemEventFindManyArgs = {
    /**
     * Select specific fields to fetch from the PlayerItemEvent
     * 
    **/
    select?: PlayerItemEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PlayerItemEventInclude | null
    /**
     * Filter, which PlayerItemEvents to fetch.
     * 
    **/
    where?: PlayerItemEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerItemEvents to fetch.
     * 
    **/
    orderBy?: Enumerable<PlayerItemEventOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlayerItemEvents.
     * 
    **/
    cursor?: PlayerItemEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerItemEvents from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerItemEvents.
     * 
    **/
    skip?: number
    distinct?: Enumerable<PlayerItemEventScalarFieldEnum>
  }


  /**
   * PlayerItemEvent create
   */
  export type PlayerItemEventCreateArgs = {
    /**
     * Select specific fields to fetch from the PlayerItemEvent
     * 
    **/
    select?: PlayerItemEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PlayerItemEventInclude | null
    /**
     * The data needed to create a PlayerItemEvent.
     * 
    **/
    data: XOR<PlayerItemEventCreateInput, PlayerItemEventUncheckedCreateInput>
  }


  /**
   * PlayerItemEvent createMany
   */
  export type PlayerItemEventCreateManyArgs = {
    /**
     * The data used to create many PlayerItemEvents.
     * 
    **/
    data: Enumerable<PlayerItemEventCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * PlayerItemEvent update
   */
  export type PlayerItemEventUpdateArgs = {
    /**
     * Select specific fields to fetch from the PlayerItemEvent
     * 
    **/
    select?: PlayerItemEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PlayerItemEventInclude | null
    /**
     * The data needed to update a PlayerItemEvent.
     * 
    **/
    data: XOR<PlayerItemEventUpdateInput, PlayerItemEventUncheckedUpdateInput>
    /**
     * Choose, which PlayerItemEvent to update.
     * 
    **/
    where: PlayerItemEventWhereUniqueInput
  }


  /**
   * PlayerItemEvent updateMany
   */
  export type PlayerItemEventUpdateManyArgs = {
    /**
     * The data used to update PlayerItemEvents.
     * 
    **/
    data: XOR<PlayerItemEventUpdateManyMutationInput, PlayerItemEventUncheckedUpdateManyInput>
    /**
     * Filter which PlayerItemEvents to update
     * 
    **/
    where?: PlayerItemEventWhereInput
  }


  /**
   * PlayerItemEvent upsert
   */
  export type PlayerItemEventUpsertArgs = {
    /**
     * Select specific fields to fetch from the PlayerItemEvent
     * 
    **/
    select?: PlayerItemEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PlayerItemEventInclude | null
    /**
     * The filter to search for the PlayerItemEvent to update in case it exists.
     * 
    **/
    where: PlayerItemEventWhereUniqueInput
    /**
     * In case the PlayerItemEvent found by the `where` argument doesn't exist, create a new PlayerItemEvent with this data.
     * 
    **/
    create: XOR<PlayerItemEventCreateInput, PlayerItemEventUncheckedCreateInput>
    /**
     * In case the PlayerItemEvent was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<PlayerItemEventUpdateInput, PlayerItemEventUncheckedUpdateInput>
  }


  /**
   * PlayerItemEvent delete
   */
  export type PlayerItemEventDeleteArgs = {
    /**
     * Select specific fields to fetch from the PlayerItemEvent
     * 
    **/
    select?: PlayerItemEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PlayerItemEventInclude | null
    /**
     * Filter which PlayerItemEvent to delete.
     * 
    **/
    where: PlayerItemEventWhereUniqueInput
  }


  /**
   * PlayerItemEvent deleteMany
   */
  export type PlayerItemEventDeleteManyArgs = {
    /**
     * Filter which PlayerItemEvents to delete
     * 
    **/
    where?: PlayerItemEventWhereInput
  }


  /**
   * PlayerItemEvent without action
   */
  export type PlayerItemEventArgs = {
    /**
     * Select specific fields to fetch from the PlayerItemEvent
     * 
    **/
    select?: PlayerItemEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PlayerItemEventInclude | null
  }



  /**
   * Model PlayerKill
   */


  export type AggregatePlayerKill = {
    _count: PlayerKillCountAggregateOutputType | null
    _min: PlayerKillMinAggregateOutputType | null
    _max: PlayerKillMaxAggregateOutputType | null
  }

  export type PlayerKillMinAggregateOutputType = {
    id: string | null
  }

  export type PlayerKillMaxAggregateOutputType = {
    id: string | null
  }

  export type PlayerKillCountAggregateOutputType = {
    id: number
    _all: number
  }


  export type PlayerKillMinAggregateInputType = {
    id?: true
  }

  export type PlayerKillMaxAggregateInputType = {
    id?: true
  }

  export type PlayerKillCountAggregateInputType = {
    id?: true
    _all?: true
  }

  export type PlayerKillAggregateArgs = {
    /**
     * Filter which PlayerKill to aggregate.
     * 
    **/
    where?: PlayerKillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerKills to fetch.
     * 
    **/
    orderBy?: Enumerable<PlayerKillOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: PlayerKillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerKills from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerKills.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlayerKills
    **/
    _count?: true | PlayerKillCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlayerKillMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlayerKillMaxAggregateInputType
  }

  export type GetPlayerKillAggregateType<T extends PlayerKillAggregateArgs> = {
        [P in keyof T & keyof AggregatePlayerKill]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlayerKill[P]>
      : GetScalarType<T[P], AggregatePlayerKill[P]>
  }




  export type PlayerKillGroupByArgs = {
    where?: PlayerKillWhereInput
    orderBy?: Enumerable<PlayerKillOrderByWithAggregationInput>
    by: Array<PlayerKillScalarFieldEnum>
    having?: PlayerKillScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlayerKillCountAggregateInputType | true
    _min?: PlayerKillMinAggregateInputType
    _max?: PlayerKillMaxAggregateInputType
  }


  export type PlayerKillGroupByOutputType = {
    id: string
    _count: PlayerKillCountAggregateOutputType | null
    _min: PlayerKillMinAggregateOutputType | null
    _max: PlayerKillMaxAggregateOutputType | null
  }

  type GetPlayerKillGroupByPayload<T extends PlayerKillGroupByArgs> = PrismaPromise<
    Array<
      PickArray<PlayerKillGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlayerKillGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlayerKillGroupByOutputType[P]>
            : GetScalarType<T[P], PlayerKillGroupByOutputType[P]>
        }
      >
    >


  export type PlayerKillSelect = {
    id?: boolean
    killer?: boolean | PlayerFindManyArgs
    victim?: boolean | PlayerFindManyArgs
    _count?: boolean | PlayerKillCountOutputTypeArgs
  }

  export type PlayerKillInclude = {
    killer?: boolean | PlayerFindManyArgs
    victim?: boolean | PlayerFindManyArgs
    _count?: boolean | PlayerKillCountOutputTypeArgs
  }

  export type PlayerKillGetPayload<
    S extends boolean | null | undefined | PlayerKillArgs,
    U = keyof S
      > = S extends true
        ? PlayerKill
    : S extends undefined
    ? never
    : S extends PlayerKillArgs | PlayerKillFindManyArgs
    ?'include' extends U
    ? PlayerKill  & {
    [P in TrueKeys<S['include']>]:
        P extends 'killer' ? Array < PlayerGetPayload<S['include'][P]>>  :
        P extends 'victim' ? Array < PlayerGetPayload<S['include'][P]>>  :
        P extends '_count' ? PlayerKillCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'killer' ? Array < PlayerGetPayload<S['select'][P]>>  :
        P extends 'victim' ? Array < PlayerGetPayload<S['select'][P]>>  :
        P extends '_count' ? PlayerKillCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof PlayerKill ? PlayerKill[P] : never
  } 
    : PlayerKill
  : PlayerKill


  type PlayerKillCountArgs = Merge<
    Omit<PlayerKillFindManyArgs, 'select' | 'include'> & {
      select?: PlayerKillCountAggregateInputType | true
    }
  >

  export interface PlayerKillDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one PlayerKill that matches the filter.
     * @param {PlayerKillFindUniqueArgs} args - Arguments to find a PlayerKill
     * @example
     * // Get one PlayerKill
     * const playerKill = await prisma.playerKill.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PlayerKillFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PlayerKillFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'PlayerKill'> extends True ? CheckSelect<T, Prisma__PlayerKillClient<PlayerKill>, Prisma__PlayerKillClient<PlayerKillGetPayload<T>>> : CheckSelect<T, Prisma__PlayerKillClient<PlayerKill | null >, Prisma__PlayerKillClient<PlayerKillGetPayload<T> | null >>

    /**
     * Find the first PlayerKill that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerKillFindFirstArgs} args - Arguments to find a PlayerKill
     * @example
     * // Get one PlayerKill
     * const playerKill = await prisma.playerKill.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PlayerKillFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PlayerKillFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'PlayerKill'> extends True ? CheckSelect<T, Prisma__PlayerKillClient<PlayerKill>, Prisma__PlayerKillClient<PlayerKillGetPayload<T>>> : CheckSelect<T, Prisma__PlayerKillClient<PlayerKill | null >, Prisma__PlayerKillClient<PlayerKillGetPayload<T> | null >>

    /**
     * Find zero or more PlayerKills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerKillFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlayerKills
     * const playerKills = await prisma.playerKill.findMany()
     * 
     * // Get first 10 PlayerKills
     * const playerKills = await prisma.playerKill.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const playerKillWithIdOnly = await prisma.playerKill.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PlayerKillFindManyArgs>(
      args?: SelectSubset<T, PlayerKillFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<PlayerKill>>, PrismaPromise<Array<PlayerKillGetPayload<T>>>>

    /**
     * Create a PlayerKill.
     * @param {PlayerKillCreateArgs} args - Arguments to create a PlayerKill.
     * @example
     * // Create one PlayerKill
     * const PlayerKill = await prisma.playerKill.create({
     *   data: {
     *     // ... data to create a PlayerKill
     *   }
     * })
     * 
    **/
    create<T extends PlayerKillCreateArgs>(
      args: SelectSubset<T, PlayerKillCreateArgs>
    ): CheckSelect<T, Prisma__PlayerKillClient<PlayerKill>, Prisma__PlayerKillClient<PlayerKillGetPayload<T>>>

    /**
     * Create many PlayerKills.
     *     @param {PlayerKillCreateManyArgs} args - Arguments to create many PlayerKills.
     *     @example
     *     // Create many PlayerKills
     *     const playerKill = await prisma.playerKill.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PlayerKillCreateManyArgs>(
      args?: SelectSubset<T, PlayerKillCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a PlayerKill.
     * @param {PlayerKillDeleteArgs} args - Arguments to delete one PlayerKill.
     * @example
     * // Delete one PlayerKill
     * const PlayerKill = await prisma.playerKill.delete({
     *   where: {
     *     // ... filter to delete one PlayerKill
     *   }
     * })
     * 
    **/
    delete<T extends PlayerKillDeleteArgs>(
      args: SelectSubset<T, PlayerKillDeleteArgs>
    ): CheckSelect<T, Prisma__PlayerKillClient<PlayerKill>, Prisma__PlayerKillClient<PlayerKillGetPayload<T>>>

    /**
     * Update one PlayerKill.
     * @param {PlayerKillUpdateArgs} args - Arguments to update one PlayerKill.
     * @example
     * // Update one PlayerKill
     * const playerKill = await prisma.playerKill.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PlayerKillUpdateArgs>(
      args: SelectSubset<T, PlayerKillUpdateArgs>
    ): CheckSelect<T, Prisma__PlayerKillClient<PlayerKill>, Prisma__PlayerKillClient<PlayerKillGetPayload<T>>>

    /**
     * Delete zero or more PlayerKills.
     * @param {PlayerKillDeleteManyArgs} args - Arguments to filter PlayerKills to delete.
     * @example
     * // Delete a few PlayerKills
     * const { count } = await prisma.playerKill.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PlayerKillDeleteManyArgs>(
      args?: SelectSubset<T, PlayerKillDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlayerKills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerKillUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlayerKills
     * const playerKill = await prisma.playerKill.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PlayerKillUpdateManyArgs>(
      args: SelectSubset<T, PlayerKillUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one PlayerKill.
     * @param {PlayerKillUpsertArgs} args - Arguments to update or create a PlayerKill.
     * @example
     * // Update or create a PlayerKill
     * const playerKill = await prisma.playerKill.upsert({
     *   create: {
     *     // ... data to create a PlayerKill
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlayerKill we want to update
     *   }
     * })
    **/
    upsert<T extends PlayerKillUpsertArgs>(
      args: SelectSubset<T, PlayerKillUpsertArgs>
    ): CheckSelect<T, Prisma__PlayerKillClient<PlayerKill>, Prisma__PlayerKillClient<PlayerKillGetPayload<T>>>

    /**
     * Count the number of PlayerKills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerKillCountArgs} args - Arguments to filter PlayerKills to count.
     * @example
     * // Count the number of PlayerKills
     * const count = await prisma.playerKill.count({
     *   where: {
     *     // ... the filter for the PlayerKills we want to count
     *   }
     * })
    **/
    count<T extends PlayerKillCountArgs>(
      args?: Subset<T, PlayerKillCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlayerKillCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlayerKill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerKillAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlayerKillAggregateArgs>(args: Subset<T, PlayerKillAggregateArgs>): PrismaPromise<GetPlayerKillAggregateType<T>>

    /**
     * Group by PlayerKill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerKillGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlayerKillGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlayerKillGroupByArgs['orderBy'] }
        : { orderBy?: PlayerKillGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlayerKillGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlayerKillGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlayerKill.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PlayerKillClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    killer<T extends PlayerFindManyArgs = {}>(args?: Subset<T, PlayerFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Player>>, PrismaPromise<Array<PlayerGetPayload<T>>>>;

    victim<T extends PlayerFindManyArgs = {}>(args?: Subset<T, PlayerFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Player>>, PrismaPromise<Array<PlayerGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * PlayerKill findUnique
   */
  export type PlayerKillFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the PlayerKill
     * 
    **/
    select?: PlayerKillSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PlayerKillInclude | null
    /**
     * Throw an Error if a PlayerKill can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which PlayerKill to fetch.
     * 
    **/
    where: PlayerKillWhereUniqueInput
  }


  /**
   * PlayerKill findFirst
   */
  export type PlayerKillFindFirstArgs = {
    /**
     * Select specific fields to fetch from the PlayerKill
     * 
    **/
    select?: PlayerKillSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PlayerKillInclude | null
    /**
     * Throw an Error if a PlayerKill can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which PlayerKill to fetch.
     * 
    **/
    where?: PlayerKillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerKills to fetch.
     * 
    **/
    orderBy?: Enumerable<PlayerKillOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlayerKills.
     * 
    **/
    cursor?: PlayerKillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerKills from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerKills.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlayerKills.
     * 
    **/
    distinct?: Enumerable<PlayerKillScalarFieldEnum>
  }


  /**
   * PlayerKill findMany
   */
  export type PlayerKillFindManyArgs = {
    /**
     * Select specific fields to fetch from the PlayerKill
     * 
    **/
    select?: PlayerKillSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PlayerKillInclude | null
    /**
     * Filter, which PlayerKills to fetch.
     * 
    **/
    where?: PlayerKillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerKills to fetch.
     * 
    **/
    orderBy?: Enumerable<PlayerKillOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlayerKills.
     * 
    **/
    cursor?: PlayerKillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerKills from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerKills.
     * 
    **/
    skip?: number
    distinct?: Enumerable<PlayerKillScalarFieldEnum>
  }


  /**
   * PlayerKill create
   */
  export type PlayerKillCreateArgs = {
    /**
     * Select specific fields to fetch from the PlayerKill
     * 
    **/
    select?: PlayerKillSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PlayerKillInclude | null
    /**
     * The data needed to create a PlayerKill.
     * 
    **/
    data: XOR<PlayerKillCreateInput, PlayerKillUncheckedCreateInput>
  }


  /**
   * PlayerKill createMany
   */
  export type PlayerKillCreateManyArgs = {
    /**
     * The data used to create many PlayerKills.
     * 
    **/
    data: Enumerable<PlayerKillCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * PlayerKill update
   */
  export type PlayerKillUpdateArgs = {
    /**
     * Select specific fields to fetch from the PlayerKill
     * 
    **/
    select?: PlayerKillSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PlayerKillInclude | null
    /**
     * The data needed to update a PlayerKill.
     * 
    **/
    data: XOR<PlayerKillUpdateInput, PlayerKillUncheckedUpdateInput>
    /**
     * Choose, which PlayerKill to update.
     * 
    **/
    where: PlayerKillWhereUniqueInput
  }


  /**
   * PlayerKill updateMany
   */
  export type PlayerKillUpdateManyArgs = {
    /**
     * The data used to update PlayerKills.
     * 
    **/
    data: XOR<PlayerKillUpdateManyMutationInput, PlayerKillUncheckedUpdateManyInput>
    /**
     * Filter which PlayerKills to update
     * 
    **/
    where?: PlayerKillWhereInput
  }


  /**
   * PlayerKill upsert
   */
  export type PlayerKillUpsertArgs = {
    /**
     * Select specific fields to fetch from the PlayerKill
     * 
    **/
    select?: PlayerKillSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PlayerKillInclude | null
    /**
     * The filter to search for the PlayerKill to update in case it exists.
     * 
    **/
    where: PlayerKillWhereUniqueInput
    /**
     * In case the PlayerKill found by the `where` argument doesn't exist, create a new PlayerKill with this data.
     * 
    **/
    create: XOR<PlayerKillCreateInput, PlayerKillUncheckedCreateInput>
    /**
     * In case the PlayerKill was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<PlayerKillUpdateInput, PlayerKillUncheckedUpdateInput>
  }


  /**
   * PlayerKill delete
   */
  export type PlayerKillDeleteArgs = {
    /**
     * Select specific fields to fetch from the PlayerKill
     * 
    **/
    select?: PlayerKillSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PlayerKillInclude | null
    /**
     * Filter which PlayerKill to delete.
     * 
    **/
    where: PlayerKillWhereUniqueInput
  }


  /**
   * PlayerKill deleteMany
   */
  export type PlayerKillDeleteManyArgs = {
    /**
     * Filter which PlayerKills to delete
     * 
    **/
    where?: PlayerKillWhereInput
  }


  /**
   * PlayerKill without action
   */
  export type PlayerKillArgs = {
    /**
     * Select specific fields to fetch from the PlayerKill
     * 
    **/
    select?: PlayerKillSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PlayerKillInclude | null
  }



  /**
   * Model PlayerRune
   */


  export type AggregatePlayerRune = {
    _count: PlayerRuneCountAggregateOutputType | null
    _avg: PlayerRuneAvgAggregateOutputType | null
    _sum: PlayerRuneSumAggregateOutputType | null
    _min: PlayerRuneMinAggregateOutputType | null
    _max: PlayerRuneMaxAggregateOutputType | null
  }

  export type PlayerRuneAvgAggregateOutputType = {
    defense: number | null
    flex: number | null
    offense: number | null
  }

  export type PlayerRuneSumAggregateOutputType = {
    defense: number | null
    flex: number | null
    offense: number | null
  }

  export type PlayerRuneMinAggregateOutputType = {
    id: string | null
    defense: number | null
    flex: number | null
    offense: number | null
  }

  export type PlayerRuneMaxAggregateOutputType = {
    id: string | null
    defense: number | null
    flex: number | null
    offense: number | null
  }

  export type PlayerRuneCountAggregateOutputType = {
    id: number
    defense: number
    flex: number
    offense: number
    _all: number
  }


  export type PlayerRuneAvgAggregateInputType = {
    defense?: true
    flex?: true
    offense?: true
  }

  export type PlayerRuneSumAggregateInputType = {
    defense?: true
    flex?: true
    offense?: true
  }

  export type PlayerRuneMinAggregateInputType = {
    id?: true
    defense?: true
    flex?: true
    offense?: true
  }

  export type PlayerRuneMaxAggregateInputType = {
    id?: true
    defense?: true
    flex?: true
    offense?: true
  }

  export type PlayerRuneCountAggregateInputType = {
    id?: true
    defense?: true
    flex?: true
    offense?: true
    _all?: true
  }

  export type PlayerRuneAggregateArgs = {
    /**
     * Filter which PlayerRune to aggregate.
     * 
    **/
    where?: PlayerRuneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerRunes to fetch.
     * 
    **/
    orderBy?: Enumerable<PlayerRuneOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: PlayerRuneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerRunes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerRunes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlayerRunes
    **/
    _count?: true | PlayerRuneCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlayerRuneAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlayerRuneSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlayerRuneMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlayerRuneMaxAggregateInputType
  }

  export type GetPlayerRuneAggregateType<T extends PlayerRuneAggregateArgs> = {
        [P in keyof T & keyof AggregatePlayerRune]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlayerRune[P]>
      : GetScalarType<T[P], AggregatePlayerRune[P]>
  }




  export type PlayerRuneGroupByArgs = {
    where?: PlayerRuneWhereInput
    orderBy?: Enumerable<PlayerRuneOrderByWithAggregationInput>
    by: Array<PlayerRuneScalarFieldEnum>
    having?: PlayerRuneScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlayerRuneCountAggregateInputType | true
    _avg?: PlayerRuneAvgAggregateInputType
    _sum?: PlayerRuneSumAggregateInputType
    _min?: PlayerRuneMinAggregateInputType
    _max?: PlayerRuneMaxAggregateInputType
  }


  export type PlayerRuneGroupByOutputType = {
    id: string
    defense: number | null
    flex: number | null
    offense: number | null
    _count: PlayerRuneCountAggregateOutputType | null
    _avg: PlayerRuneAvgAggregateOutputType | null
    _sum: PlayerRuneSumAggregateOutputType | null
    _min: PlayerRuneMinAggregateOutputType | null
    _max: PlayerRuneMaxAggregateOutputType | null
  }

  type GetPlayerRuneGroupByPayload<T extends PlayerRuneGroupByArgs> = PrismaPromise<
    Array<
      PickArray<PlayerRuneGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlayerRuneGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlayerRuneGroupByOutputType[P]>
            : GetScalarType<T[P], PlayerRuneGroupByOutputType[P]>
        }
      >
    >


  export type PlayerRuneSelect = {
    id?: boolean
    playerEndOfGameStat?: boolean | PlayerEndOfGameStatArgs
    runeStyle?: boolean | RuneStyleFindManyArgs
    defense?: boolean
    flex?: boolean
    offense?: boolean
    _count?: boolean | PlayerRuneCountOutputTypeArgs
  }

  export type PlayerRuneInclude = {
    playerEndOfGameStat?: boolean | PlayerEndOfGameStatArgs
    runeStyle?: boolean | RuneStyleFindManyArgs
    _count?: boolean | PlayerRuneCountOutputTypeArgs
  }

  export type PlayerRuneGetPayload<
    S extends boolean | null | undefined | PlayerRuneArgs,
    U = keyof S
      > = S extends true
        ? PlayerRune
    : S extends undefined
    ? never
    : S extends PlayerRuneArgs | PlayerRuneFindManyArgs
    ?'include' extends U
    ? PlayerRune  & {
    [P in TrueKeys<S['include']>]:
        P extends 'playerEndOfGameStat' ? PlayerEndOfGameStatGetPayload<S['include'][P]> | null :
        P extends 'runeStyle' ? Array < RuneStyleGetPayload<S['include'][P]>>  :
        P extends '_count' ? PlayerRuneCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'playerEndOfGameStat' ? PlayerEndOfGameStatGetPayload<S['select'][P]> | null :
        P extends 'runeStyle' ? Array < RuneStyleGetPayload<S['select'][P]>>  :
        P extends '_count' ? PlayerRuneCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof PlayerRune ? PlayerRune[P] : never
  } 
    : PlayerRune
  : PlayerRune


  type PlayerRuneCountArgs = Merge<
    Omit<PlayerRuneFindManyArgs, 'select' | 'include'> & {
      select?: PlayerRuneCountAggregateInputType | true
    }
  >

  export interface PlayerRuneDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one PlayerRune that matches the filter.
     * @param {PlayerRuneFindUniqueArgs} args - Arguments to find a PlayerRune
     * @example
     * // Get one PlayerRune
     * const playerRune = await prisma.playerRune.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PlayerRuneFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PlayerRuneFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'PlayerRune'> extends True ? CheckSelect<T, Prisma__PlayerRuneClient<PlayerRune>, Prisma__PlayerRuneClient<PlayerRuneGetPayload<T>>> : CheckSelect<T, Prisma__PlayerRuneClient<PlayerRune | null >, Prisma__PlayerRuneClient<PlayerRuneGetPayload<T> | null >>

    /**
     * Find the first PlayerRune that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerRuneFindFirstArgs} args - Arguments to find a PlayerRune
     * @example
     * // Get one PlayerRune
     * const playerRune = await prisma.playerRune.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PlayerRuneFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PlayerRuneFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'PlayerRune'> extends True ? CheckSelect<T, Prisma__PlayerRuneClient<PlayerRune>, Prisma__PlayerRuneClient<PlayerRuneGetPayload<T>>> : CheckSelect<T, Prisma__PlayerRuneClient<PlayerRune | null >, Prisma__PlayerRuneClient<PlayerRuneGetPayload<T> | null >>

    /**
     * Find zero or more PlayerRunes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerRuneFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlayerRunes
     * const playerRunes = await prisma.playerRune.findMany()
     * 
     * // Get first 10 PlayerRunes
     * const playerRunes = await prisma.playerRune.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const playerRuneWithIdOnly = await prisma.playerRune.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PlayerRuneFindManyArgs>(
      args?: SelectSubset<T, PlayerRuneFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<PlayerRune>>, PrismaPromise<Array<PlayerRuneGetPayload<T>>>>

    /**
     * Create a PlayerRune.
     * @param {PlayerRuneCreateArgs} args - Arguments to create a PlayerRune.
     * @example
     * // Create one PlayerRune
     * const PlayerRune = await prisma.playerRune.create({
     *   data: {
     *     // ... data to create a PlayerRune
     *   }
     * })
     * 
    **/
    create<T extends PlayerRuneCreateArgs>(
      args: SelectSubset<T, PlayerRuneCreateArgs>
    ): CheckSelect<T, Prisma__PlayerRuneClient<PlayerRune>, Prisma__PlayerRuneClient<PlayerRuneGetPayload<T>>>

    /**
     * Create many PlayerRunes.
     *     @param {PlayerRuneCreateManyArgs} args - Arguments to create many PlayerRunes.
     *     @example
     *     // Create many PlayerRunes
     *     const playerRune = await prisma.playerRune.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PlayerRuneCreateManyArgs>(
      args?: SelectSubset<T, PlayerRuneCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a PlayerRune.
     * @param {PlayerRuneDeleteArgs} args - Arguments to delete one PlayerRune.
     * @example
     * // Delete one PlayerRune
     * const PlayerRune = await prisma.playerRune.delete({
     *   where: {
     *     // ... filter to delete one PlayerRune
     *   }
     * })
     * 
    **/
    delete<T extends PlayerRuneDeleteArgs>(
      args: SelectSubset<T, PlayerRuneDeleteArgs>
    ): CheckSelect<T, Prisma__PlayerRuneClient<PlayerRune>, Prisma__PlayerRuneClient<PlayerRuneGetPayload<T>>>

    /**
     * Update one PlayerRune.
     * @param {PlayerRuneUpdateArgs} args - Arguments to update one PlayerRune.
     * @example
     * // Update one PlayerRune
     * const playerRune = await prisma.playerRune.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PlayerRuneUpdateArgs>(
      args: SelectSubset<T, PlayerRuneUpdateArgs>
    ): CheckSelect<T, Prisma__PlayerRuneClient<PlayerRune>, Prisma__PlayerRuneClient<PlayerRuneGetPayload<T>>>

    /**
     * Delete zero or more PlayerRunes.
     * @param {PlayerRuneDeleteManyArgs} args - Arguments to filter PlayerRunes to delete.
     * @example
     * // Delete a few PlayerRunes
     * const { count } = await prisma.playerRune.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PlayerRuneDeleteManyArgs>(
      args?: SelectSubset<T, PlayerRuneDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlayerRunes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerRuneUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlayerRunes
     * const playerRune = await prisma.playerRune.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PlayerRuneUpdateManyArgs>(
      args: SelectSubset<T, PlayerRuneUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one PlayerRune.
     * @param {PlayerRuneUpsertArgs} args - Arguments to update or create a PlayerRune.
     * @example
     * // Update or create a PlayerRune
     * const playerRune = await prisma.playerRune.upsert({
     *   create: {
     *     // ... data to create a PlayerRune
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlayerRune we want to update
     *   }
     * })
    **/
    upsert<T extends PlayerRuneUpsertArgs>(
      args: SelectSubset<T, PlayerRuneUpsertArgs>
    ): CheckSelect<T, Prisma__PlayerRuneClient<PlayerRune>, Prisma__PlayerRuneClient<PlayerRuneGetPayload<T>>>

    /**
     * Count the number of PlayerRunes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerRuneCountArgs} args - Arguments to filter PlayerRunes to count.
     * @example
     * // Count the number of PlayerRunes
     * const count = await prisma.playerRune.count({
     *   where: {
     *     // ... the filter for the PlayerRunes we want to count
     *   }
     * })
    **/
    count<T extends PlayerRuneCountArgs>(
      args?: Subset<T, PlayerRuneCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlayerRuneCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlayerRune.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerRuneAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlayerRuneAggregateArgs>(args: Subset<T, PlayerRuneAggregateArgs>): PrismaPromise<GetPlayerRuneAggregateType<T>>

    /**
     * Group by PlayerRune.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerRuneGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlayerRuneGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlayerRuneGroupByArgs['orderBy'] }
        : { orderBy?: PlayerRuneGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlayerRuneGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlayerRuneGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlayerRune.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PlayerRuneClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    playerEndOfGameStat<T extends PlayerEndOfGameStatArgs = {}>(args?: Subset<T, PlayerEndOfGameStatArgs>): CheckSelect<T, Prisma__PlayerEndOfGameStatClient<PlayerEndOfGameStat | null >, Prisma__PlayerEndOfGameStatClient<PlayerEndOfGameStatGetPayload<T> | null >>;

    runeStyle<T extends RuneStyleFindManyArgs = {}>(args?: Subset<T, RuneStyleFindManyArgs>): CheckSelect<T, PrismaPromise<Array<RuneStyle>>, PrismaPromise<Array<RuneStyleGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * PlayerRune findUnique
   */
  export type PlayerRuneFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the PlayerRune
     * 
    **/
    select?: PlayerRuneSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PlayerRuneInclude | null
    /**
     * Throw an Error if a PlayerRune can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which PlayerRune to fetch.
     * 
    **/
    where: PlayerRuneWhereUniqueInput
  }


  /**
   * PlayerRune findFirst
   */
  export type PlayerRuneFindFirstArgs = {
    /**
     * Select specific fields to fetch from the PlayerRune
     * 
    **/
    select?: PlayerRuneSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PlayerRuneInclude | null
    /**
     * Throw an Error if a PlayerRune can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which PlayerRune to fetch.
     * 
    **/
    where?: PlayerRuneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerRunes to fetch.
     * 
    **/
    orderBy?: Enumerable<PlayerRuneOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlayerRunes.
     * 
    **/
    cursor?: PlayerRuneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerRunes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerRunes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlayerRunes.
     * 
    **/
    distinct?: Enumerable<PlayerRuneScalarFieldEnum>
  }


  /**
   * PlayerRune findMany
   */
  export type PlayerRuneFindManyArgs = {
    /**
     * Select specific fields to fetch from the PlayerRune
     * 
    **/
    select?: PlayerRuneSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PlayerRuneInclude | null
    /**
     * Filter, which PlayerRunes to fetch.
     * 
    **/
    where?: PlayerRuneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerRunes to fetch.
     * 
    **/
    orderBy?: Enumerable<PlayerRuneOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlayerRunes.
     * 
    **/
    cursor?: PlayerRuneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerRunes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerRunes.
     * 
    **/
    skip?: number
    distinct?: Enumerable<PlayerRuneScalarFieldEnum>
  }


  /**
   * PlayerRune create
   */
  export type PlayerRuneCreateArgs = {
    /**
     * Select specific fields to fetch from the PlayerRune
     * 
    **/
    select?: PlayerRuneSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PlayerRuneInclude | null
    /**
     * The data needed to create a PlayerRune.
     * 
    **/
    data: XOR<PlayerRuneCreateInput, PlayerRuneUncheckedCreateInput>
  }


  /**
   * PlayerRune createMany
   */
  export type PlayerRuneCreateManyArgs = {
    /**
     * The data used to create many PlayerRunes.
     * 
    **/
    data: Enumerable<PlayerRuneCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * PlayerRune update
   */
  export type PlayerRuneUpdateArgs = {
    /**
     * Select specific fields to fetch from the PlayerRune
     * 
    **/
    select?: PlayerRuneSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PlayerRuneInclude | null
    /**
     * The data needed to update a PlayerRune.
     * 
    **/
    data: XOR<PlayerRuneUpdateInput, PlayerRuneUncheckedUpdateInput>
    /**
     * Choose, which PlayerRune to update.
     * 
    **/
    where: PlayerRuneWhereUniqueInput
  }


  /**
   * PlayerRune updateMany
   */
  export type PlayerRuneUpdateManyArgs = {
    /**
     * The data used to update PlayerRunes.
     * 
    **/
    data: XOR<PlayerRuneUpdateManyMutationInput, PlayerRuneUncheckedUpdateManyInput>
    /**
     * Filter which PlayerRunes to update
     * 
    **/
    where?: PlayerRuneWhereInput
  }


  /**
   * PlayerRune upsert
   */
  export type PlayerRuneUpsertArgs = {
    /**
     * Select specific fields to fetch from the PlayerRune
     * 
    **/
    select?: PlayerRuneSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PlayerRuneInclude | null
    /**
     * The filter to search for the PlayerRune to update in case it exists.
     * 
    **/
    where: PlayerRuneWhereUniqueInput
    /**
     * In case the PlayerRune found by the `where` argument doesn't exist, create a new PlayerRune with this data.
     * 
    **/
    create: XOR<PlayerRuneCreateInput, PlayerRuneUncheckedCreateInput>
    /**
     * In case the PlayerRune was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<PlayerRuneUpdateInput, PlayerRuneUncheckedUpdateInput>
  }


  /**
   * PlayerRune delete
   */
  export type PlayerRuneDeleteArgs = {
    /**
     * Select specific fields to fetch from the PlayerRune
     * 
    **/
    select?: PlayerRuneSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PlayerRuneInclude | null
    /**
     * Filter which PlayerRune to delete.
     * 
    **/
    where: PlayerRuneWhereUniqueInput
  }


  /**
   * PlayerRune deleteMany
   */
  export type PlayerRuneDeleteManyArgs = {
    /**
     * Filter which PlayerRunes to delete
     * 
    **/
    where?: PlayerRuneWhereInput
  }


  /**
   * PlayerRune without action
   */
  export type PlayerRuneArgs = {
    /**
     * Select specific fields to fetch from the PlayerRune
     * 
    **/
    select?: PlayerRuneSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PlayerRuneInclude | null
  }



  /**
   * Model PlayerSkillLevelUpEvent
   */


  export type AggregatePlayerSkillLevelUpEvent = {
    _count: PlayerSkillLevelUpEventCountAggregateOutputType | null
    _avg: PlayerSkillLevelUpEventAvgAggregateOutputType | null
    _sum: PlayerSkillLevelUpEventSumAggregateOutputType | null
    _min: PlayerSkillLevelUpEventMinAggregateOutputType | null
    _max: PlayerSkillLevelUpEventMaxAggregateOutputType | null
  }

  export type PlayerSkillLevelUpEventAvgAggregateOutputType = {
    slot: number | null
  }

  export type PlayerSkillLevelUpEventSumAggregateOutputType = {
    slot: number | null
  }

  export type PlayerSkillLevelUpEventMinAggregateOutputType = {
    id: string | null
    type: string | null
    slot: number | null
  }

  export type PlayerSkillLevelUpEventMaxAggregateOutputType = {
    id: string | null
    type: string | null
    slot: number | null
  }

  export type PlayerSkillLevelUpEventCountAggregateOutputType = {
    id: number
    type: number
    slot: number
    _all: number
  }


  export type PlayerSkillLevelUpEventAvgAggregateInputType = {
    slot?: true
  }

  export type PlayerSkillLevelUpEventSumAggregateInputType = {
    slot?: true
  }

  export type PlayerSkillLevelUpEventMinAggregateInputType = {
    id?: true
    type?: true
    slot?: true
  }

  export type PlayerSkillLevelUpEventMaxAggregateInputType = {
    id?: true
    type?: true
    slot?: true
  }

  export type PlayerSkillLevelUpEventCountAggregateInputType = {
    id?: true
    type?: true
    slot?: true
    _all?: true
  }

  export type PlayerSkillLevelUpEventAggregateArgs = {
    /**
     * Filter which PlayerSkillLevelUpEvent to aggregate.
     * 
    **/
    where?: PlayerSkillLevelUpEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerSkillLevelUpEvents to fetch.
     * 
    **/
    orderBy?: Enumerable<PlayerSkillLevelUpEventOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: PlayerSkillLevelUpEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerSkillLevelUpEvents from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerSkillLevelUpEvents.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlayerSkillLevelUpEvents
    **/
    _count?: true | PlayerSkillLevelUpEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlayerSkillLevelUpEventAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlayerSkillLevelUpEventSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlayerSkillLevelUpEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlayerSkillLevelUpEventMaxAggregateInputType
  }

  export type GetPlayerSkillLevelUpEventAggregateType<T extends PlayerSkillLevelUpEventAggregateArgs> = {
        [P in keyof T & keyof AggregatePlayerSkillLevelUpEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlayerSkillLevelUpEvent[P]>
      : GetScalarType<T[P], AggregatePlayerSkillLevelUpEvent[P]>
  }




  export type PlayerSkillLevelUpEventGroupByArgs = {
    where?: PlayerSkillLevelUpEventWhereInput
    orderBy?: Enumerable<PlayerSkillLevelUpEventOrderByWithAggregationInput>
    by: Array<PlayerSkillLevelUpEventScalarFieldEnum>
    having?: PlayerSkillLevelUpEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlayerSkillLevelUpEventCountAggregateInputType | true
    _avg?: PlayerSkillLevelUpEventAvgAggregateInputType
    _sum?: PlayerSkillLevelUpEventSumAggregateInputType
    _min?: PlayerSkillLevelUpEventMinAggregateInputType
    _max?: PlayerSkillLevelUpEventMaxAggregateInputType
  }


  export type PlayerSkillLevelUpEventGroupByOutputType = {
    id: string
    type: string
    slot: number | null
    _count: PlayerSkillLevelUpEventCountAggregateOutputType | null
    _avg: PlayerSkillLevelUpEventAvgAggregateOutputType | null
    _sum: PlayerSkillLevelUpEventSumAggregateOutputType | null
    _min: PlayerSkillLevelUpEventMinAggregateOutputType | null
    _max: PlayerSkillLevelUpEventMaxAggregateOutputType | null
  }

  type GetPlayerSkillLevelUpEventGroupByPayload<T extends PlayerSkillLevelUpEventGroupByArgs> = PrismaPromise<
    Array<
      PickArray<PlayerSkillLevelUpEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlayerSkillLevelUpEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlayerSkillLevelUpEventGroupByOutputType[P]>
            : GetScalarType<T[P], PlayerSkillLevelUpEventGroupByOutputType[P]>
        }
      >
    >


  export type PlayerSkillLevelUpEventSelect = {
    id?: boolean
    player?: boolean | PlayerFindManyArgs
    type?: boolean
    slot?: boolean
    _count?: boolean | PlayerSkillLevelUpEventCountOutputTypeArgs
  }

  export type PlayerSkillLevelUpEventInclude = {
    player?: boolean | PlayerFindManyArgs
    _count?: boolean | PlayerSkillLevelUpEventCountOutputTypeArgs
  }

  export type PlayerSkillLevelUpEventGetPayload<
    S extends boolean | null | undefined | PlayerSkillLevelUpEventArgs,
    U = keyof S
      > = S extends true
        ? PlayerSkillLevelUpEvent
    : S extends undefined
    ? never
    : S extends PlayerSkillLevelUpEventArgs | PlayerSkillLevelUpEventFindManyArgs
    ?'include' extends U
    ? PlayerSkillLevelUpEvent  & {
    [P in TrueKeys<S['include']>]:
        P extends 'player' ? Array < PlayerGetPayload<S['include'][P]>>  :
        P extends '_count' ? PlayerSkillLevelUpEventCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'player' ? Array < PlayerGetPayload<S['select'][P]>>  :
        P extends '_count' ? PlayerSkillLevelUpEventCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof PlayerSkillLevelUpEvent ? PlayerSkillLevelUpEvent[P] : never
  } 
    : PlayerSkillLevelUpEvent
  : PlayerSkillLevelUpEvent


  type PlayerSkillLevelUpEventCountArgs = Merge<
    Omit<PlayerSkillLevelUpEventFindManyArgs, 'select' | 'include'> & {
      select?: PlayerSkillLevelUpEventCountAggregateInputType | true
    }
  >

  export interface PlayerSkillLevelUpEventDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one PlayerSkillLevelUpEvent that matches the filter.
     * @param {PlayerSkillLevelUpEventFindUniqueArgs} args - Arguments to find a PlayerSkillLevelUpEvent
     * @example
     * // Get one PlayerSkillLevelUpEvent
     * const playerSkillLevelUpEvent = await prisma.playerSkillLevelUpEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PlayerSkillLevelUpEventFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PlayerSkillLevelUpEventFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'PlayerSkillLevelUpEvent'> extends True ? CheckSelect<T, Prisma__PlayerSkillLevelUpEventClient<PlayerSkillLevelUpEvent>, Prisma__PlayerSkillLevelUpEventClient<PlayerSkillLevelUpEventGetPayload<T>>> : CheckSelect<T, Prisma__PlayerSkillLevelUpEventClient<PlayerSkillLevelUpEvent | null >, Prisma__PlayerSkillLevelUpEventClient<PlayerSkillLevelUpEventGetPayload<T> | null >>

    /**
     * Find the first PlayerSkillLevelUpEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerSkillLevelUpEventFindFirstArgs} args - Arguments to find a PlayerSkillLevelUpEvent
     * @example
     * // Get one PlayerSkillLevelUpEvent
     * const playerSkillLevelUpEvent = await prisma.playerSkillLevelUpEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PlayerSkillLevelUpEventFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PlayerSkillLevelUpEventFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'PlayerSkillLevelUpEvent'> extends True ? CheckSelect<T, Prisma__PlayerSkillLevelUpEventClient<PlayerSkillLevelUpEvent>, Prisma__PlayerSkillLevelUpEventClient<PlayerSkillLevelUpEventGetPayload<T>>> : CheckSelect<T, Prisma__PlayerSkillLevelUpEventClient<PlayerSkillLevelUpEvent | null >, Prisma__PlayerSkillLevelUpEventClient<PlayerSkillLevelUpEventGetPayload<T> | null >>

    /**
     * Find zero or more PlayerSkillLevelUpEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerSkillLevelUpEventFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlayerSkillLevelUpEvents
     * const playerSkillLevelUpEvents = await prisma.playerSkillLevelUpEvent.findMany()
     * 
     * // Get first 10 PlayerSkillLevelUpEvents
     * const playerSkillLevelUpEvents = await prisma.playerSkillLevelUpEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const playerSkillLevelUpEventWithIdOnly = await prisma.playerSkillLevelUpEvent.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PlayerSkillLevelUpEventFindManyArgs>(
      args?: SelectSubset<T, PlayerSkillLevelUpEventFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<PlayerSkillLevelUpEvent>>, PrismaPromise<Array<PlayerSkillLevelUpEventGetPayload<T>>>>

    /**
     * Create a PlayerSkillLevelUpEvent.
     * @param {PlayerSkillLevelUpEventCreateArgs} args - Arguments to create a PlayerSkillLevelUpEvent.
     * @example
     * // Create one PlayerSkillLevelUpEvent
     * const PlayerSkillLevelUpEvent = await prisma.playerSkillLevelUpEvent.create({
     *   data: {
     *     // ... data to create a PlayerSkillLevelUpEvent
     *   }
     * })
     * 
    **/
    create<T extends PlayerSkillLevelUpEventCreateArgs>(
      args: SelectSubset<T, PlayerSkillLevelUpEventCreateArgs>
    ): CheckSelect<T, Prisma__PlayerSkillLevelUpEventClient<PlayerSkillLevelUpEvent>, Prisma__PlayerSkillLevelUpEventClient<PlayerSkillLevelUpEventGetPayload<T>>>

    /**
     * Create many PlayerSkillLevelUpEvents.
     *     @param {PlayerSkillLevelUpEventCreateManyArgs} args - Arguments to create many PlayerSkillLevelUpEvents.
     *     @example
     *     // Create many PlayerSkillLevelUpEvents
     *     const playerSkillLevelUpEvent = await prisma.playerSkillLevelUpEvent.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PlayerSkillLevelUpEventCreateManyArgs>(
      args?: SelectSubset<T, PlayerSkillLevelUpEventCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a PlayerSkillLevelUpEvent.
     * @param {PlayerSkillLevelUpEventDeleteArgs} args - Arguments to delete one PlayerSkillLevelUpEvent.
     * @example
     * // Delete one PlayerSkillLevelUpEvent
     * const PlayerSkillLevelUpEvent = await prisma.playerSkillLevelUpEvent.delete({
     *   where: {
     *     // ... filter to delete one PlayerSkillLevelUpEvent
     *   }
     * })
     * 
    **/
    delete<T extends PlayerSkillLevelUpEventDeleteArgs>(
      args: SelectSubset<T, PlayerSkillLevelUpEventDeleteArgs>
    ): CheckSelect<T, Prisma__PlayerSkillLevelUpEventClient<PlayerSkillLevelUpEvent>, Prisma__PlayerSkillLevelUpEventClient<PlayerSkillLevelUpEventGetPayload<T>>>

    /**
     * Update one PlayerSkillLevelUpEvent.
     * @param {PlayerSkillLevelUpEventUpdateArgs} args - Arguments to update one PlayerSkillLevelUpEvent.
     * @example
     * // Update one PlayerSkillLevelUpEvent
     * const playerSkillLevelUpEvent = await prisma.playerSkillLevelUpEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PlayerSkillLevelUpEventUpdateArgs>(
      args: SelectSubset<T, PlayerSkillLevelUpEventUpdateArgs>
    ): CheckSelect<T, Prisma__PlayerSkillLevelUpEventClient<PlayerSkillLevelUpEvent>, Prisma__PlayerSkillLevelUpEventClient<PlayerSkillLevelUpEventGetPayload<T>>>

    /**
     * Delete zero or more PlayerSkillLevelUpEvents.
     * @param {PlayerSkillLevelUpEventDeleteManyArgs} args - Arguments to filter PlayerSkillLevelUpEvents to delete.
     * @example
     * // Delete a few PlayerSkillLevelUpEvents
     * const { count } = await prisma.playerSkillLevelUpEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PlayerSkillLevelUpEventDeleteManyArgs>(
      args?: SelectSubset<T, PlayerSkillLevelUpEventDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlayerSkillLevelUpEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerSkillLevelUpEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlayerSkillLevelUpEvents
     * const playerSkillLevelUpEvent = await prisma.playerSkillLevelUpEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PlayerSkillLevelUpEventUpdateManyArgs>(
      args: SelectSubset<T, PlayerSkillLevelUpEventUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one PlayerSkillLevelUpEvent.
     * @param {PlayerSkillLevelUpEventUpsertArgs} args - Arguments to update or create a PlayerSkillLevelUpEvent.
     * @example
     * // Update or create a PlayerSkillLevelUpEvent
     * const playerSkillLevelUpEvent = await prisma.playerSkillLevelUpEvent.upsert({
     *   create: {
     *     // ... data to create a PlayerSkillLevelUpEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlayerSkillLevelUpEvent we want to update
     *   }
     * })
    **/
    upsert<T extends PlayerSkillLevelUpEventUpsertArgs>(
      args: SelectSubset<T, PlayerSkillLevelUpEventUpsertArgs>
    ): CheckSelect<T, Prisma__PlayerSkillLevelUpEventClient<PlayerSkillLevelUpEvent>, Prisma__PlayerSkillLevelUpEventClient<PlayerSkillLevelUpEventGetPayload<T>>>

    /**
     * Count the number of PlayerSkillLevelUpEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerSkillLevelUpEventCountArgs} args - Arguments to filter PlayerSkillLevelUpEvents to count.
     * @example
     * // Count the number of PlayerSkillLevelUpEvents
     * const count = await prisma.playerSkillLevelUpEvent.count({
     *   where: {
     *     // ... the filter for the PlayerSkillLevelUpEvents we want to count
     *   }
     * })
    **/
    count<T extends PlayerSkillLevelUpEventCountArgs>(
      args?: Subset<T, PlayerSkillLevelUpEventCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlayerSkillLevelUpEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlayerSkillLevelUpEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerSkillLevelUpEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlayerSkillLevelUpEventAggregateArgs>(args: Subset<T, PlayerSkillLevelUpEventAggregateArgs>): PrismaPromise<GetPlayerSkillLevelUpEventAggregateType<T>>

    /**
     * Group by PlayerSkillLevelUpEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerSkillLevelUpEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlayerSkillLevelUpEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlayerSkillLevelUpEventGroupByArgs['orderBy'] }
        : { orderBy?: PlayerSkillLevelUpEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlayerSkillLevelUpEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlayerSkillLevelUpEventGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlayerSkillLevelUpEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PlayerSkillLevelUpEventClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    player<T extends PlayerFindManyArgs = {}>(args?: Subset<T, PlayerFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Player>>, PrismaPromise<Array<PlayerGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * PlayerSkillLevelUpEvent findUnique
   */
  export type PlayerSkillLevelUpEventFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the PlayerSkillLevelUpEvent
     * 
    **/
    select?: PlayerSkillLevelUpEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PlayerSkillLevelUpEventInclude | null
    /**
     * Throw an Error if a PlayerSkillLevelUpEvent can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which PlayerSkillLevelUpEvent to fetch.
     * 
    **/
    where: PlayerSkillLevelUpEventWhereUniqueInput
  }


  /**
   * PlayerSkillLevelUpEvent findFirst
   */
  export type PlayerSkillLevelUpEventFindFirstArgs = {
    /**
     * Select specific fields to fetch from the PlayerSkillLevelUpEvent
     * 
    **/
    select?: PlayerSkillLevelUpEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PlayerSkillLevelUpEventInclude | null
    /**
     * Throw an Error if a PlayerSkillLevelUpEvent can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which PlayerSkillLevelUpEvent to fetch.
     * 
    **/
    where?: PlayerSkillLevelUpEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerSkillLevelUpEvents to fetch.
     * 
    **/
    orderBy?: Enumerable<PlayerSkillLevelUpEventOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlayerSkillLevelUpEvents.
     * 
    **/
    cursor?: PlayerSkillLevelUpEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerSkillLevelUpEvents from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerSkillLevelUpEvents.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlayerSkillLevelUpEvents.
     * 
    **/
    distinct?: Enumerable<PlayerSkillLevelUpEventScalarFieldEnum>
  }


  /**
   * PlayerSkillLevelUpEvent findMany
   */
  export type PlayerSkillLevelUpEventFindManyArgs = {
    /**
     * Select specific fields to fetch from the PlayerSkillLevelUpEvent
     * 
    **/
    select?: PlayerSkillLevelUpEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PlayerSkillLevelUpEventInclude | null
    /**
     * Filter, which PlayerSkillLevelUpEvents to fetch.
     * 
    **/
    where?: PlayerSkillLevelUpEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerSkillLevelUpEvents to fetch.
     * 
    **/
    orderBy?: Enumerable<PlayerSkillLevelUpEventOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlayerSkillLevelUpEvents.
     * 
    **/
    cursor?: PlayerSkillLevelUpEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerSkillLevelUpEvents from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerSkillLevelUpEvents.
     * 
    **/
    skip?: number
    distinct?: Enumerable<PlayerSkillLevelUpEventScalarFieldEnum>
  }


  /**
   * PlayerSkillLevelUpEvent create
   */
  export type PlayerSkillLevelUpEventCreateArgs = {
    /**
     * Select specific fields to fetch from the PlayerSkillLevelUpEvent
     * 
    **/
    select?: PlayerSkillLevelUpEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PlayerSkillLevelUpEventInclude | null
    /**
     * The data needed to create a PlayerSkillLevelUpEvent.
     * 
    **/
    data: XOR<PlayerSkillLevelUpEventCreateInput, PlayerSkillLevelUpEventUncheckedCreateInput>
  }


  /**
   * PlayerSkillLevelUpEvent createMany
   */
  export type PlayerSkillLevelUpEventCreateManyArgs = {
    /**
     * The data used to create many PlayerSkillLevelUpEvents.
     * 
    **/
    data: Enumerable<PlayerSkillLevelUpEventCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * PlayerSkillLevelUpEvent update
   */
  export type PlayerSkillLevelUpEventUpdateArgs = {
    /**
     * Select specific fields to fetch from the PlayerSkillLevelUpEvent
     * 
    **/
    select?: PlayerSkillLevelUpEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PlayerSkillLevelUpEventInclude | null
    /**
     * The data needed to update a PlayerSkillLevelUpEvent.
     * 
    **/
    data: XOR<PlayerSkillLevelUpEventUpdateInput, PlayerSkillLevelUpEventUncheckedUpdateInput>
    /**
     * Choose, which PlayerSkillLevelUpEvent to update.
     * 
    **/
    where: PlayerSkillLevelUpEventWhereUniqueInput
  }


  /**
   * PlayerSkillLevelUpEvent updateMany
   */
  export type PlayerSkillLevelUpEventUpdateManyArgs = {
    /**
     * The data used to update PlayerSkillLevelUpEvents.
     * 
    **/
    data: XOR<PlayerSkillLevelUpEventUpdateManyMutationInput, PlayerSkillLevelUpEventUncheckedUpdateManyInput>
    /**
     * Filter which PlayerSkillLevelUpEvents to update
     * 
    **/
    where?: PlayerSkillLevelUpEventWhereInput
  }


  /**
   * PlayerSkillLevelUpEvent upsert
   */
  export type PlayerSkillLevelUpEventUpsertArgs = {
    /**
     * Select specific fields to fetch from the PlayerSkillLevelUpEvent
     * 
    **/
    select?: PlayerSkillLevelUpEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PlayerSkillLevelUpEventInclude | null
    /**
     * The filter to search for the PlayerSkillLevelUpEvent to update in case it exists.
     * 
    **/
    where: PlayerSkillLevelUpEventWhereUniqueInput
    /**
     * In case the PlayerSkillLevelUpEvent found by the `where` argument doesn't exist, create a new PlayerSkillLevelUpEvent with this data.
     * 
    **/
    create: XOR<PlayerSkillLevelUpEventCreateInput, PlayerSkillLevelUpEventUncheckedCreateInput>
    /**
     * In case the PlayerSkillLevelUpEvent was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<PlayerSkillLevelUpEventUpdateInput, PlayerSkillLevelUpEventUncheckedUpdateInput>
  }


  /**
   * PlayerSkillLevelUpEvent delete
   */
  export type PlayerSkillLevelUpEventDeleteArgs = {
    /**
     * Select specific fields to fetch from the PlayerSkillLevelUpEvent
     * 
    **/
    select?: PlayerSkillLevelUpEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PlayerSkillLevelUpEventInclude | null
    /**
     * Filter which PlayerSkillLevelUpEvent to delete.
     * 
    **/
    where: PlayerSkillLevelUpEventWhereUniqueInput
  }


  /**
   * PlayerSkillLevelUpEvent deleteMany
   */
  export type PlayerSkillLevelUpEventDeleteManyArgs = {
    /**
     * Filter which PlayerSkillLevelUpEvents to delete
     * 
    **/
    where?: PlayerSkillLevelUpEventWhereInput
  }


  /**
   * PlayerSkillLevelUpEvent without action
   */
  export type PlayerSkillLevelUpEventArgs = {
    /**
     * Select specific fields to fetch from the PlayerSkillLevelUpEvent
     * 
    **/
    select?: PlayerSkillLevelUpEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PlayerSkillLevelUpEventInclude | null
  }



  /**
   * Model PlayerSnapshot
   */


  export type AggregatePlayerSnapshot = {
    _count: PlayerSnapshotCountAggregateOutputType | null
    _avg: PlayerSnapshotAvgAggregateOutputType | null
    _sum: PlayerSnapshotSumAggregateOutputType | null
    _min: PlayerSnapshotMinAggregateOutputType | null
    _max: PlayerSnapshotMaxAggregateOutputType | null
  }

  export type PlayerSnapshotAvgAggregateOutputType = {
    timestamp: number | null
    currentGold: number | null
    totalGold: number | null
    totalGoldDiff: number | null
    xp: number | null
    xpDiff: number | null
    level: number | null
    cs: number | null
    csDiff: number | null
    monstersKilled: number | null
    monstersKilledDiff: number | null
  }

  export type PlayerSnapshotSumAggregateOutputType = {
    timestamp: number | null
    currentGold: number | null
    totalGold: number | null
    totalGoldDiff: number | null
    xp: number | null
    xpDiff: number | null
    level: number | null
    cs: number | null
    csDiff: number | null
    monstersKilled: number | null
    monstersKilledDiff: number | null
  }

  export type PlayerSnapshotMinAggregateOutputType = {
    id: string | null
    timestamp: number | null
    currentGold: number | null
    totalGold: number | null
    totalGoldDiff: number | null
    xp: number | null
    xpDiff: number | null
    level: number | null
    cs: number | null
    csDiff: number | null
    monstersKilled: number | null
    monstersKilledDiff: number | null
  }

  export type PlayerSnapshotMaxAggregateOutputType = {
    id: string | null
    timestamp: number | null
    currentGold: number | null
    totalGold: number | null
    totalGoldDiff: number | null
    xp: number | null
    xpDiff: number | null
    level: number | null
    cs: number | null
    csDiff: number | null
    monstersKilled: number | null
    monstersKilledDiff: number | null
  }

  export type PlayerSnapshotCountAggregateOutputType = {
    id: number
    timestamp: number
    currentGold: number
    totalGold: number
    totalGoldDiff: number
    xp: number
    xpDiff: number
    level: number
    cs: number
    csDiff: number
    monstersKilled: number
    monstersKilledDiff: number
    _all: number
  }


  export type PlayerSnapshotAvgAggregateInputType = {
    timestamp?: true
    currentGold?: true
    totalGold?: true
    totalGoldDiff?: true
    xp?: true
    xpDiff?: true
    level?: true
    cs?: true
    csDiff?: true
    monstersKilled?: true
    monstersKilledDiff?: true
  }

  export type PlayerSnapshotSumAggregateInputType = {
    timestamp?: true
    currentGold?: true
    totalGold?: true
    totalGoldDiff?: true
    xp?: true
    xpDiff?: true
    level?: true
    cs?: true
    csDiff?: true
    monstersKilled?: true
    monstersKilledDiff?: true
  }

  export type PlayerSnapshotMinAggregateInputType = {
    id?: true
    timestamp?: true
    currentGold?: true
    totalGold?: true
    totalGoldDiff?: true
    xp?: true
    xpDiff?: true
    level?: true
    cs?: true
    csDiff?: true
    monstersKilled?: true
    monstersKilledDiff?: true
  }

  export type PlayerSnapshotMaxAggregateInputType = {
    id?: true
    timestamp?: true
    currentGold?: true
    totalGold?: true
    totalGoldDiff?: true
    xp?: true
    xpDiff?: true
    level?: true
    cs?: true
    csDiff?: true
    monstersKilled?: true
    monstersKilledDiff?: true
  }

  export type PlayerSnapshotCountAggregateInputType = {
    id?: true
    timestamp?: true
    currentGold?: true
    totalGold?: true
    totalGoldDiff?: true
    xp?: true
    xpDiff?: true
    level?: true
    cs?: true
    csDiff?: true
    monstersKilled?: true
    monstersKilledDiff?: true
    _all?: true
  }

  export type PlayerSnapshotAggregateArgs = {
    /**
     * Filter which PlayerSnapshot to aggregate.
     * 
    **/
    where?: PlayerSnapshotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerSnapshots to fetch.
     * 
    **/
    orderBy?: Enumerable<PlayerSnapshotOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: PlayerSnapshotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerSnapshots from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerSnapshots.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlayerSnapshots
    **/
    _count?: true | PlayerSnapshotCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlayerSnapshotAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlayerSnapshotSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlayerSnapshotMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlayerSnapshotMaxAggregateInputType
  }

  export type GetPlayerSnapshotAggregateType<T extends PlayerSnapshotAggregateArgs> = {
        [P in keyof T & keyof AggregatePlayerSnapshot]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlayerSnapshot[P]>
      : GetScalarType<T[P], AggregatePlayerSnapshot[P]>
  }




  export type PlayerSnapshotGroupByArgs = {
    where?: PlayerSnapshotWhereInput
    orderBy?: Enumerable<PlayerSnapshotOrderByWithAggregationInput>
    by: Array<PlayerSnapshotScalarFieldEnum>
    having?: PlayerSnapshotScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlayerSnapshotCountAggregateInputType | true
    _avg?: PlayerSnapshotAvgAggregateInputType
    _sum?: PlayerSnapshotSumAggregateInputType
    _min?: PlayerSnapshotMinAggregateInputType
    _max?: PlayerSnapshotMaxAggregateInputType
  }


  export type PlayerSnapshotGroupByOutputType = {
    id: string
    timestamp: number | null
    currentGold: number | null
    totalGold: number | null
    totalGoldDiff: number | null
    xp: number | null
    xpDiff: number | null
    level: number | null
    cs: number | null
    csDiff: number | null
    monstersKilled: number | null
    monstersKilledDiff: number | null
    _count: PlayerSnapshotCountAggregateOutputType | null
    _avg: PlayerSnapshotAvgAggregateOutputType | null
    _sum: PlayerSnapshotSumAggregateOutputType | null
    _min: PlayerSnapshotMinAggregateOutputType | null
    _max: PlayerSnapshotMaxAggregateOutputType | null
  }

  type GetPlayerSnapshotGroupByPayload<T extends PlayerSnapshotGroupByArgs> = PrismaPromise<
    Array<
      PickArray<PlayerSnapshotGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlayerSnapshotGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlayerSnapshotGroupByOutputType[P]>
            : GetScalarType<T[P], PlayerSnapshotGroupByOutputType[P]>
        }
      >
    >


  export type PlayerSnapshotSelect = {
    id?: boolean
    timestamp?: boolean
    currentGold?: boolean
    totalGold?: boolean
    totalGoldDiff?: boolean
    xp?: boolean
    xpDiff?: boolean
    level?: boolean
    cs?: boolean
    csDiff?: boolean
    monstersKilled?: boolean
    monstersKilledDiff?: boolean
    position?: boolean | PositionFindManyArgs
    player?: boolean | PlayerFindManyArgs
    _count?: boolean | PlayerSnapshotCountOutputTypeArgs
  }

  export type PlayerSnapshotInclude = {
    position?: boolean | PositionFindManyArgs
    player?: boolean | PlayerFindManyArgs
    _count?: boolean | PlayerSnapshotCountOutputTypeArgs
  }

  export type PlayerSnapshotGetPayload<
    S extends boolean | null | undefined | PlayerSnapshotArgs,
    U = keyof S
      > = S extends true
        ? PlayerSnapshot
    : S extends undefined
    ? never
    : S extends PlayerSnapshotArgs | PlayerSnapshotFindManyArgs
    ?'include' extends U
    ? PlayerSnapshot  & {
    [P in TrueKeys<S['include']>]:
        P extends 'position' ? Array < PositionGetPayload<S['include'][P]>>  :
        P extends 'player' ? Array < PlayerGetPayload<S['include'][P]>>  :
        P extends '_count' ? PlayerSnapshotCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'position' ? Array < PositionGetPayload<S['select'][P]>>  :
        P extends 'player' ? Array < PlayerGetPayload<S['select'][P]>>  :
        P extends '_count' ? PlayerSnapshotCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof PlayerSnapshot ? PlayerSnapshot[P] : never
  } 
    : PlayerSnapshot
  : PlayerSnapshot


  type PlayerSnapshotCountArgs = Merge<
    Omit<PlayerSnapshotFindManyArgs, 'select' | 'include'> & {
      select?: PlayerSnapshotCountAggregateInputType | true
    }
  >

  export interface PlayerSnapshotDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one PlayerSnapshot that matches the filter.
     * @param {PlayerSnapshotFindUniqueArgs} args - Arguments to find a PlayerSnapshot
     * @example
     * // Get one PlayerSnapshot
     * const playerSnapshot = await prisma.playerSnapshot.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PlayerSnapshotFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PlayerSnapshotFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'PlayerSnapshot'> extends True ? CheckSelect<T, Prisma__PlayerSnapshotClient<PlayerSnapshot>, Prisma__PlayerSnapshotClient<PlayerSnapshotGetPayload<T>>> : CheckSelect<T, Prisma__PlayerSnapshotClient<PlayerSnapshot | null >, Prisma__PlayerSnapshotClient<PlayerSnapshotGetPayload<T> | null >>

    /**
     * Find the first PlayerSnapshot that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerSnapshotFindFirstArgs} args - Arguments to find a PlayerSnapshot
     * @example
     * // Get one PlayerSnapshot
     * const playerSnapshot = await prisma.playerSnapshot.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PlayerSnapshotFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PlayerSnapshotFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'PlayerSnapshot'> extends True ? CheckSelect<T, Prisma__PlayerSnapshotClient<PlayerSnapshot>, Prisma__PlayerSnapshotClient<PlayerSnapshotGetPayload<T>>> : CheckSelect<T, Prisma__PlayerSnapshotClient<PlayerSnapshot | null >, Prisma__PlayerSnapshotClient<PlayerSnapshotGetPayload<T> | null >>

    /**
     * Find zero or more PlayerSnapshots that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerSnapshotFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlayerSnapshots
     * const playerSnapshots = await prisma.playerSnapshot.findMany()
     * 
     * // Get first 10 PlayerSnapshots
     * const playerSnapshots = await prisma.playerSnapshot.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const playerSnapshotWithIdOnly = await prisma.playerSnapshot.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PlayerSnapshotFindManyArgs>(
      args?: SelectSubset<T, PlayerSnapshotFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<PlayerSnapshot>>, PrismaPromise<Array<PlayerSnapshotGetPayload<T>>>>

    /**
     * Create a PlayerSnapshot.
     * @param {PlayerSnapshotCreateArgs} args - Arguments to create a PlayerSnapshot.
     * @example
     * // Create one PlayerSnapshot
     * const PlayerSnapshot = await prisma.playerSnapshot.create({
     *   data: {
     *     // ... data to create a PlayerSnapshot
     *   }
     * })
     * 
    **/
    create<T extends PlayerSnapshotCreateArgs>(
      args: SelectSubset<T, PlayerSnapshotCreateArgs>
    ): CheckSelect<T, Prisma__PlayerSnapshotClient<PlayerSnapshot>, Prisma__PlayerSnapshotClient<PlayerSnapshotGetPayload<T>>>

    /**
     * Create many PlayerSnapshots.
     *     @param {PlayerSnapshotCreateManyArgs} args - Arguments to create many PlayerSnapshots.
     *     @example
     *     // Create many PlayerSnapshots
     *     const playerSnapshot = await prisma.playerSnapshot.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PlayerSnapshotCreateManyArgs>(
      args?: SelectSubset<T, PlayerSnapshotCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a PlayerSnapshot.
     * @param {PlayerSnapshotDeleteArgs} args - Arguments to delete one PlayerSnapshot.
     * @example
     * // Delete one PlayerSnapshot
     * const PlayerSnapshot = await prisma.playerSnapshot.delete({
     *   where: {
     *     // ... filter to delete one PlayerSnapshot
     *   }
     * })
     * 
    **/
    delete<T extends PlayerSnapshotDeleteArgs>(
      args: SelectSubset<T, PlayerSnapshotDeleteArgs>
    ): CheckSelect<T, Prisma__PlayerSnapshotClient<PlayerSnapshot>, Prisma__PlayerSnapshotClient<PlayerSnapshotGetPayload<T>>>

    /**
     * Update one PlayerSnapshot.
     * @param {PlayerSnapshotUpdateArgs} args - Arguments to update one PlayerSnapshot.
     * @example
     * // Update one PlayerSnapshot
     * const playerSnapshot = await prisma.playerSnapshot.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PlayerSnapshotUpdateArgs>(
      args: SelectSubset<T, PlayerSnapshotUpdateArgs>
    ): CheckSelect<T, Prisma__PlayerSnapshotClient<PlayerSnapshot>, Prisma__PlayerSnapshotClient<PlayerSnapshotGetPayload<T>>>

    /**
     * Delete zero or more PlayerSnapshots.
     * @param {PlayerSnapshotDeleteManyArgs} args - Arguments to filter PlayerSnapshots to delete.
     * @example
     * // Delete a few PlayerSnapshots
     * const { count } = await prisma.playerSnapshot.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PlayerSnapshotDeleteManyArgs>(
      args?: SelectSubset<T, PlayerSnapshotDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlayerSnapshots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerSnapshotUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlayerSnapshots
     * const playerSnapshot = await prisma.playerSnapshot.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PlayerSnapshotUpdateManyArgs>(
      args: SelectSubset<T, PlayerSnapshotUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one PlayerSnapshot.
     * @param {PlayerSnapshotUpsertArgs} args - Arguments to update or create a PlayerSnapshot.
     * @example
     * // Update or create a PlayerSnapshot
     * const playerSnapshot = await prisma.playerSnapshot.upsert({
     *   create: {
     *     // ... data to create a PlayerSnapshot
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlayerSnapshot we want to update
     *   }
     * })
    **/
    upsert<T extends PlayerSnapshotUpsertArgs>(
      args: SelectSubset<T, PlayerSnapshotUpsertArgs>
    ): CheckSelect<T, Prisma__PlayerSnapshotClient<PlayerSnapshot>, Prisma__PlayerSnapshotClient<PlayerSnapshotGetPayload<T>>>

    /**
     * Count the number of PlayerSnapshots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerSnapshotCountArgs} args - Arguments to filter PlayerSnapshots to count.
     * @example
     * // Count the number of PlayerSnapshots
     * const count = await prisma.playerSnapshot.count({
     *   where: {
     *     // ... the filter for the PlayerSnapshots we want to count
     *   }
     * })
    **/
    count<T extends PlayerSnapshotCountArgs>(
      args?: Subset<T, PlayerSnapshotCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlayerSnapshotCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlayerSnapshot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerSnapshotAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlayerSnapshotAggregateArgs>(args: Subset<T, PlayerSnapshotAggregateArgs>): PrismaPromise<GetPlayerSnapshotAggregateType<T>>

    /**
     * Group by PlayerSnapshot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerSnapshotGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlayerSnapshotGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlayerSnapshotGroupByArgs['orderBy'] }
        : { orderBy?: PlayerSnapshotGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlayerSnapshotGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlayerSnapshotGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlayerSnapshot.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PlayerSnapshotClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    position<T extends PositionFindManyArgs = {}>(args?: Subset<T, PositionFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Position>>, PrismaPromise<Array<PositionGetPayload<T>>>>;

    player<T extends PlayerFindManyArgs = {}>(args?: Subset<T, PlayerFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Player>>, PrismaPromise<Array<PlayerGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * PlayerSnapshot findUnique
   */
  export type PlayerSnapshotFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the PlayerSnapshot
     * 
    **/
    select?: PlayerSnapshotSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PlayerSnapshotInclude | null
    /**
     * Throw an Error if a PlayerSnapshot can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which PlayerSnapshot to fetch.
     * 
    **/
    where: PlayerSnapshotWhereUniqueInput
  }


  /**
   * PlayerSnapshot findFirst
   */
  export type PlayerSnapshotFindFirstArgs = {
    /**
     * Select specific fields to fetch from the PlayerSnapshot
     * 
    **/
    select?: PlayerSnapshotSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PlayerSnapshotInclude | null
    /**
     * Throw an Error if a PlayerSnapshot can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which PlayerSnapshot to fetch.
     * 
    **/
    where?: PlayerSnapshotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerSnapshots to fetch.
     * 
    **/
    orderBy?: Enumerable<PlayerSnapshotOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlayerSnapshots.
     * 
    **/
    cursor?: PlayerSnapshotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerSnapshots from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerSnapshots.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlayerSnapshots.
     * 
    **/
    distinct?: Enumerable<PlayerSnapshotScalarFieldEnum>
  }


  /**
   * PlayerSnapshot findMany
   */
  export type PlayerSnapshotFindManyArgs = {
    /**
     * Select specific fields to fetch from the PlayerSnapshot
     * 
    **/
    select?: PlayerSnapshotSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PlayerSnapshotInclude | null
    /**
     * Filter, which PlayerSnapshots to fetch.
     * 
    **/
    where?: PlayerSnapshotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerSnapshots to fetch.
     * 
    **/
    orderBy?: Enumerable<PlayerSnapshotOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlayerSnapshots.
     * 
    **/
    cursor?: PlayerSnapshotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerSnapshots from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerSnapshots.
     * 
    **/
    skip?: number
    distinct?: Enumerable<PlayerSnapshotScalarFieldEnum>
  }


  /**
   * PlayerSnapshot create
   */
  export type PlayerSnapshotCreateArgs = {
    /**
     * Select specific fields to fetch from the PlayerSnapshot
     * 
    **/
    select?: PlayerSnapshotSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PlayerSnapshotInclude | null
    /**
     * The data needed to create a PlayerSnapshot.
     * 
    **/
    data: XOR<PlayerSnapshotCreateInput, PlayerSnapshotUncheckedCreateInput>
  }


  /**
   * PlayerSnapshot createMany
   */
  export type PlayerSnapshotCreateManyArgs = {
    /**
     * The data used to create many PlayerSnapshots.
     * 
    **/
    data: Enumerable<PlayerSnapshotCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * PlayerSnapshot update
   */
  export type PlayerSnapshotUpdateArgs = {
    /**
     * Select specific fields to fetch from the PlayerSnapshot
     * 
    **/
    select?: PlayerSnapshotSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PlayerSnapshotInclude | null
    /**
     * The data needed to update a PlayerSnapshot.
     * 
    **/
    data: XOR<PlayerSnapshotUpdateInput, PlayerSnapshotUncheckedUpdateInput>
    /**
     * Choose, which PlayerSnapshot to update.
     * 
    **/
    where: PlayerSnapshotWhereUniqueInput
  }


  /**
   * PlayerSnapshot updateMany
   */
  export type PlayerSnapshotUpdateManyArgs = {
    /**
     * The data used to update PlayerSnapshots.
     * 
    **/
    data: XOR<PlayerSnapshotUpdateManyMutationInput, PlayerSnapshotUncheckedUpdateManyInput>
    /**
     * Filter which PlayerSnapshots to update
     * 
    **/
    where?: PlayerSnapshotWhereInput
  }


  /**
   * PlayerSnapshot upsert
   */
  export type PlayerSnapshotUpsertArgs = {
    /**
     * Select specific fields to fetch from the PlayerSnapshot
     * 
    **/
    select?: PlayerSnapshotSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PlayerSnapshotInclude | null
    /**
     * The filter to search for the PlayerSnapshot to update in case it exists.
     * 
    **/
    where: PlayerSnapshotWhereUniqueInput
    /**
     * In case the PlayerSnapshot found by the `where` argument doesn't exist, create a new PlayerSnapshot with this data.
     * 
    **/
    create: XOR<PlayerSnapshotCreateInput, PlayerSnapshotUncheckedCreateInput>
    /**
     * In case the PlayerSnapshot was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<PlayerSnapshotUpdateInput, PlayerSnapshotUncheckedUpdateInput>
  }


  /**
   * PlayerSnapshot delete
   */
  export type PlayerSnapshotDeleteArgs = {
    /**
     * Select specific fields to fetch from the PlayerSnapshot
     * 
    **/
    select?: PlayerSnapshotSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PlayerSnapshotInclude | null
    /**
     * Filter which PlayerSnapshot to delete.
     * 
    **/
    where: PlayerSnapshotWhereUniqueInput
  }


  /**
   * PlayerSnapshot deleteMany
   */
  export type PlayerSnapshotDeleteManyArgs = {
    /**
     * Filter which PlayerSnapshots to delete
     * 
    **/
    where?: PlayerSnapshotWhereInput
  }


  /**
   * PlayerSnapshot without action
   */
  export type PlayerSnapshotArgs = {
    /**
     * Select specific fields to fetch from the PlayerSnapshot
     * 
    **/
    select?: PlayerSnapshotSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PlayerSnapshotInclude | null
  }



  /**
   * Model PlayerWardEvent
   */


  export type AggregatePlayerWardEvent = {
    _count: PlayerWardEventCountAggregateOutputType | null
    _min: PlayerWardEventMinAggregateOutputType | null
    _max: PlayerWardEventMaxAggregateOutputType | null
  }

  export type PlayerWardEventMinAggregateOutputType = {
    id: string | null
    type: string | null
    wardType: PlayerWardEventWardTypeType | null
  }

  export type PlayerWardEventMaxAggregateOutputType = {
    id: string | null
    type: string | null
    wardType: PlayerWardEventWardTypeType | null
  }

  export type PlayerWardEventCountAggregateOutputType = {
    id: number
    type: number
    wardType: number
    _all: number
  }


  export type PlayerWardEventMinAggregateInputType = {
    id?: true
    type?: true
    wardType?: true
  }

  export type PlayerWardEventMaxAggregateInputType = {
    id?: true
    type?: true
    wardType?: true
  }

  export type PlayerWardEventCountAggregateInputType = {
    id?: true
    type?: true
    wardType?: true
    _all?: true
  }

  export type PlayerWardEventAggregateArgs = {
    /**
     * Filter which PlayerWardEvent to aggregate.
     * 
    **/
    where?: PlayerWardEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerWardEvents to fetch.
     * 
    **/
    orderBy?: Enumerable<PlayerWardEventOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: PlayerWardEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerWardEvents from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerWardEvents.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlayerWardEvents
    **/
    _count?: true | PlayerWardEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlayerWardEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlayerWardEventMaxAggregateInputType
  }

  export type GetPlayerWardEventAggregateType<T extends PlayerWardEventAggregateArgs> = {
        [P in keyof T & keyof AggregatePlayerWardEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlayerWardEvent[P]>
      : GetScalarType<T[P], AggregatePlayerWardEvent[P]>
  }




  export type PlayerWardEventGroupByArgs = {
    where?: PlayerWardEventWhereInput
    orderBy?: Enumerable<PlayerWardEventOrderByWithAggregationInput>
    by: Array<PlayerWardEventScalarFieldEnum>
    having?: PlayerWardEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlayerWardEventCountAggregateInputType | true
    _min?: PlayerWardEventMinAggregateInputType
    _max?: PlayerWardEventMaxAggregateInputType
  }


  export type PlayerWardEventGroupByOutputType = {
    id: string
    type: string
    wardType: PlayerWardEventWardTypeType | null
    _count: PlayerWardEventCountAggregateOutputType | null
    _min: PlayerWardEventMinAggregateOutputType | null
    _max: PlayerWardEventMaxAggregateOutputType | null
  }

  type GetPlayerWardEventGroupByPayload<T extends PlayerWardEventGroupByArgs> = PrismaPromise<
    Array<
      PickArray<PlayerWardEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlayerWardEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlayerWardEventGroupByOutputType[P]>
            : GetScalarType<T[P], PlayerWardEventGroupByOutputType[P]>
        }
      >
    >


  export type PlayerWardEventSelect = {
    id?: boolean
    player?: boolean | PlayerFindManyArgs
    type?: boolean
    wardType?: boolean
    _count?: boolean | PlayerWardEventCountOutputTypeArgs
  }

  export type PlayerWardEventInclude = {
    player?: boolean | PlayerFindManyArgs
    _count?: boolean | PlayerWardEventCountOutputTypeArgs
  }

  export type PlayerWardEventGetPayload<
    S extends boolean | null | undefined | PlayerWardEventArgs,
    U = keyof S
      > = S extends true
        ? PlayerWardEvent
    : S extends undefined
    ? never
    : S extends PlayerWardEventArgs | PlayerWardEventFindManyArgs
    ?'include' extends U
    ? PlayerWardEvent  & {
    [P in TrueKeys<S['include']>]:
        P extends 'player' ? Array < PlayerGetPayload<S['include'][P]>>  :
        P extends '_count' ? PlayerWardEventCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'player' ? Array < PlayerGetPayload<S['select'][P]>>  :
        P extends '_count' ? PlayerWardEventCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof PlayerWardEvent ? PlayerWardEvent[P] : never
  } 
    : PlayerWardEvent
  : PlayerWardEvent


  type PlayerWardEventCountArgs = Merge<
    Omit<PlayerWardEventFindManyArgs, 'select' | 'include'> & {
      select?: PlayerWardEventCountAggregateInputType | true
    }
  >

  export interface PlayerWardEventDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one PlayerWardEvent that matches the filter.
     * @param {PlayerWardEventFindUniqueArgs} args - Arguments to find a PlayerWardEvent
     * @example
     * // Get one PlayerWardEvent
     * const playerWardEvent = await prisma.playerWardEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PlayerWardEventFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PlayerWardEventFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'PlayerWardEvent'> extends True ? CheckSelect<T, Prisma__PlayerWardEventClient<PlayerWardEvent>, Prisma__PlayerWardEventClient<PlayerWardEventGetPayload<T>>> : CheckSelect<T, Prisma__PlayerWardEventClient<PlayerWardEvent | null >, Prisma__PlayerWardEventClient<PlayerWardEventGetPayload<T> | null >>

    /**
     * Find the first PlayerWardEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerWardEventFindFirstArgs} args - Arguments to find a PlayerWardEvent
     * @example
     * // Get one PlayerWardEvent
     * const playerWardEvent = await prisma.playerWardEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PlayerWardEventFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PlayerWardEventFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'PlayerWardEvent'> extends True ? CheckSelect<T, Prisma__PlayerWardEventClient<PlayerWardEvent>, Prisma__PlayerWardEventClient<PlayerWardEventGetPayload<T>>> : CheckSelect<T, Prisma__PlayerWardEventClient<PlayerWardEvent | null >, Prisma__PlayerWardEventClient<PlayerWardEventGetPayload<T> | null >>

    /**
     * Find zero or more PlayerWardEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerWardEventFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlayerWardEvents
     * const playerWardEvents = await prisma.playerWardEvent.findMany()
     * 
     * // Get first 10 PlayerWardEvents
     * const playerWardEvents = await prisma.playerWardEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const playerWardEventWithIdOnly = await prisma.playerWardEvent.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PlayerWardEventFindManyArgs>(
      args?: SelectSubset<T, PlayerWardEventFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<PlayerWardEvent>>, PrismaPromise<Array<PlayerWardEventGetPayload<T>>>>

    /**
     * Create a PlayerWardEvent.
     * @param {PlayerWardEventCreateArgs} args - Arguments to create a PlayerWardEvent.
     * @example
     * // Create one PlayerWardEvent
     * const PlayerWardEvent = await prisma.playerWardEvent.create({
     *   data: {
     *     // ... data to create a PlayerWardEvent
     *   }
     * })
     * 
    **/
    create<T extends PlayerWardEventCreateArgs>(
      args: SelectSubset<T, PlayerWardEventCreateArgs>
    ): CheckSelect<T, Prisma__PlayerWardEventClient<PlayerWardEvent>, Prisma__PlayerWardEventClient<PlayerWardEventGetPayload<T>>>

    /**
     * Create many PlayerWardEvents.
     *     @param {PlayerWardEventCreateManyArgs} args - Arguments to create many PlayerWardEvents.
     *     @example
     *     // Create many PlayerWardEvents
     *     const playerWardEvent = await prisma.playerWardEvent.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PlayerWardEventCreateManyArgs>(
      args?: SelectSubset<T, PlayerWardEventCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a PlayerWardEvent.
     * @param {PlayerWardEventDeleteArgs} args - Arguments to delete one PlayerWardEvent.
     * @example
     * // Delete one PlayerWardEvent
     * const PlayerWardEvent = await prisma.playerWardEvent.delete({
     *   where: {
     *     // ... filter to delete one PlayerWardEvent
     *   }
     * })
     * 
    **/
    delete<T extends PlayerWardEventDeleteArgs>(
      args: SelectSubset<T, PlayerWardEventDeleteArgs>
    ): CheckSelect<T, Prisma__PlayerWardEventClient<PlayerWardEvent>, Prisma__PlayerWardEventClient<PlayerWardEventGetPayload<T>>>

    /**
     * Update one PlayerWardEvent.
     * @param {PlayerWardEventUpdateArgs} args - Arguments to update one PlayerWardEvent.
     * @example
     * // Update one PlayerWardEvent
     * const playerWardEvent = await prisma.playerWardEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PlayerWardEventUpdateArgs>(
      args: SelectSubset<T, PlayerWardEventUpdateArgs>
    ): CheckSelect<T, Prisma__PlayerWardEventClient<PlayerWardEvent>, Prisma__PlayerWardEventClient<PlayerWardEventGetPayload<T>>>

    /**
     * Delete zero or more PlayerWardEvents.
     * @param {PlayerWardEventDeleteManyArgs} args - Arguments to filter PlayerWardEvents to delete.
     * @example
     * // Delete a few PlayerWardEvents
     * const { count } = await prisma.playerWardEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PlayerWardEventDeleteManyArgs>(
      args?: SelectSubset<T, PlayerWardEventDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlayerWardEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerWardEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlayerWardEvents
     * const playerWardEvent = await prisma.playerWardEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PlayerWardEventUpdateManyArgs>(
      args: SelectSubset<T, PlayerWardEventUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one PlayerWardEvent.
     * @param {PlayerWardEventUpsertArgs} args - Arguments to update or create a PlayerWardEvent.
     * @example
     * // Update or create a PlayerWardEvent
     * const playerWardEvent = await prisma.playerWardEvent.upsert({
     *   create: {
     *     // ... data to create a PlayerWardEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlayerWardEvent we want to update
     *   }
     * })
    **/
    upsert<T extends PlayerWardEventUpsertArgs>(
      args: SelectSubset<T, PlayerWardEventUpsertArgs>
    ): CheckSelect<T, Prisma__PlayerWardEventClient<PlayerWardEvent>, Prisma__PlayerWardEventClient<PlayerWardEventGetPayload<T>>>

    /**
     * Count the number of PlayerWardEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerWardEventCountArgs} args - Arguments to filter PlayerWardEvents to count.
     * @example
     * // Count the number of PlayerWardEvents
     * const count = await prisma.playerWardEvent.count({
     *   where: {
     *     // ... the filter for the PlayerWardEvents we want to count
     *   }
     * })
    **/
    count<T extends PlayerWardEventCountArgs>(
      args?: Subset<T, PlayerWardEventCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlayerWardEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlayerWardEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerWardEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlayerWardEventAggregateArgs>(args: Subset<T, PlayerWardEventAggregateArgs>): PrismaPromise<GetPlayerWardEventAggregateType<T>>

    /**
     * Group by PlayerWardEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerWardEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlayerWardEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlayerWardEventGroupByArgs['orderBy'] }
        : { orderBy?: PlayerWardEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlayerWardEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlayerWardEventGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlayerWardEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PlayerWardEventClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    player<T extends PlayerFindManyArgs = {}>(args?: Subset<T, PlayerFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Player>>, PrismaPromise<Array<PlayerGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * PlayerWardEvent findUnique
   */
  export type PlayerWardEventFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the PlayerWardEvent
     * 
    **/
    select?: PlayerWardEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PlayerWardEventInclude | null
    /**
     * Throw an Error if a PlayerWardEvent can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which PlayerWardEvent to fetch.
     * 
    **/
    where: PlayerWardEventWhereUniqueInput
  }


  /**
   * PlayerWardEvent findFirst
   */
  export type PlayerWardEventFindFirstArgs = {
    /**
     * Select specific fields to fetch from the PlayerWardEvent
     * 
    **/
    select?: PlayerWardEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PlayerWardEventInclude | null
    /**
     * Throw an Error if a PlayerWardEvent can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which PlayerWardEvent to fetch.
     * 
    **/
    where?: PlayerWardEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerWardEvents to fetch.
     * 
    **/
    orderBy?: Enumerable<PlayerWardEventOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlayerWardEvents.
     * 
    **/
    cursor?: PlayerWardEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerWardEvents from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerWardEvents.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlayerWardEvents.
     * 
    **/
    distinct?: Enumerable<PlayerWardEventScalarFieldEnum>
  }


  /**
   * PlayerWardEvent findMany
   */
  export type PlayerWardEventFindManyArgs = {
    /**
     * Select specific fields to fetch from the PlayerWardEvent
     * 
    **/
    select?: PlayerWardEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PlayerWardEventInclude | null
    /**
     * Filter, which PlayerWardEvents to fetch.
     * 
    **/
    where?: PlayerWardEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerWardEvents to fetch.
     * 
    **/
    orderBy?: Enumerable<PlayerWardEventOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlayerWardEvents.
     * 
    **/
    cursor?: PlayerWardEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerWardEvents from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerWardEvents.
     * 
    **/
    skip?: number
    distinct?: Enumerable<PlayerWardEventScalarFieldEnum>
  }


  /**
   * PlayerWardEvent create
   */
  export type PlayerWardEventCreateArgs = {
    /**
     * Select specific fields to fetch from the PlayerWardEvent
     * 
    **/
    select?: PlayerWardEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PlayerWardEventInclude | null
    /**
     * The data needed to create a PlayerWardEvent.
     * 
    **/
    data: XOR<PlayerWardEventCreateInput, PlayerWardEventUncheckedCreateInput>
  }


  /**
   * PlayerWardEvent createMany
   */
  export type PlayerWardEventCreateManyArgs = {
    /**
     * The data used to create many PlayerWardEvents.
     * 
    **/
    data: Enumerable<PlayerWardEventCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * PlayerWardEvent update
   */
  export type PlayerWardEventUpdateArgs = {
    /**
     * Select specific fields to fetch from the PlayerWardEvent
     * 
    **/
    select?: PlayerWardEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PlayerWardEventInclude | null
    /**
     * The data needed to update a PlayerWardEvent.
     * 
    **/
    data: XOR<PlayerWardEventUpdateInput, PlayerWardEventUncheckedUpdateInput>
    /**
     * Choose, which PlayerWardEvent to update.
     * 
    **/
    where: PlayerWardEventWhereUniqueInput
  }


  /**
   * PlayerWardEvent updateMany
   */
  export type PlayerWardEventUpdateManyArgs = {
    /**
     * The data used to update PlayerWardEvents.
     * 
    **/
    data: XOR<PlayerWardEventUpdateManyMutationInput, PlayerWardEventUncheckedUpdateManyInput>
    /**
     * Filter which PlayerWardEvents to update
     * 
    **/
    where?: PlayerWardEventWhereInput
  }


  /**
   * PlayerWardEvent upsert
   */
  export type PlayerWardEventUpsertArgs = {
    /**
     * Select specific fields to fetch from the PlayerWardEvent
     * 
    **/
    select?: PlayerWardEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PlayerWardEventInclude | null
    /**
     * The filter to search for the PlayerWardEvent to update in case it exists.
     * 
    **/
    where: PlayerWardEventWhereUniqueInput
    /**
     * In case the PlayerWardEvent found by the `where` argument doesn't exist, create a new PlayerWardEvent with this data.
     * 
    **/
    create: XOR<PlayerWardEventCreateInput, PlayerWardEventUncheckedCreateInput>
    /**
     * In case the PlayerWardEvent was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<PlayerWardEventUpdateInput, PlayerWardEventUncheckedUpdateInput>
  }


  /**
   * PlayerWardEvent delete
   */
  export type PlayerWardEventDeleteArgs = {
    /**
     * Select specific fields to fetch from the PlayerWardEvent
     * 
    **/
    select?: PlayerWardEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PlayerWardEventInclude | null
    /**
     * Filter which PlayerWardEvent to delete.
     * 
    **/
    where: PlayerWardEventWhereUniqueInput
  }


  /**
   * PlayerWardEvent deleteMany
   */
  export type PlayerWardEventDeleteManyArgs = {
    /**
     * Filter which PlayerWardEvents to delete
     * 
    **/
    where?: PlayerWardEventWhereInput
  }


  /**
   * PlayerWardEvent without action
   */
  export type PlayerWardEventArgs = {
    /**
     * Select specific fields to fetch from the PlayerWardEvent
     * 
    **/
    select?: PlayerWardEventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PlayerWardEventInclude | null
  }



  /**
   * Model Position
   */


  export type AggregatePosition = {
    _count: PositionCountAggregateOutputType | null
    _avg: PositionAvgAggregateOutputType | null
    _sum: PositionSumAggregateOutputType | null
    _min: PositionMinAggregateOutputType | null
    _max: PositionMaxAggregateOutputType | null
  }

  export type PositionAvgAggregateOutputType = {
    x: number | null
    y: number | null
  }

  export type PositionSumAggregateOutputType = {
    x: number | null
    y: number | null
  }

  export type PositionMinAggregateOutputType = {
    id: string | null
    x: number | null
    y: number | null
  }

  export type PositionMaxAggregateOutputType = {
    id: string | null
    x: number | null
    y: number | null
  }

  export type PositionCountAggregateOutputType = {
    id: number
    x: number
    y: number
    _all: number
  }


  export type PositionAvgAggregateInputType = {
    x?: true
    y?: true
  }

  export type PositionSumAggregateInputType = {
    x?: true
    y?: true
  }

  export type PositionMinAggregateInputType = {
    id?: true
    x?: true
    y?: true
  }

  export type PositionMaxAggregateInputType = {
    id?: true
    x?: true
    y?: true
  }

  export type PositionCountAggregateInputType = {
    id?: true
    x?: true
    y?: true
    _all?: true
  }

  export type PositionAggregateArgs = {
    /**
     * Filter which Position to aggregate.
     * 
    **/
    where?: PositionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Positions to fetch.
     * 
    **/
    orderBy?: Enumerable<PositionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: PositionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Positions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Positions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Positions
    **/
    _count?: true | PositionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PositionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PositionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PositionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PositionMaxAggregateInputType
  }

  export type GetPositionAggregateType<T extends PositionAggregateArgs> = {
        [P in keyof T & keyof AggregatePosition]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePosition[P]>
      : GetScalarType<T[P], AggregatePosition[P]>
  }




  export type PositionGroupByArgs = {
    where?: PositionWhereInput
    orderBy?: Enumerable<PositionOrderByWithAggregationInput>
    by: Array<PositionScalarFieldEnum>
    having?: PositionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PositionCountAggregateInputType | true
    _avg?: PositionAvgAggregateInputType
    _sum?: PositionSumAggregateInputType
    _min?: PositionMinAggregateInputType
    _max?: PositionMaxAggregateInputType
  }


  export type PositionGroupByOutputType = {
    id: string
    x: number | null
    y: number | null
    _count: PositionCountAggregateOutputType | null
    _avg: PositionAvgAggregateOutputType | null
    _sum: PositionSumAggregateOutputType | null
    _min: PositionMinAggregateOutputType | null
    _max: PositionMaxAggregateOutputType | null
  }

  type GetPositionGroupByPayload<T extends PositionGroupByArgs> = PrismaPromise<
    Array<
      PickArray<PositionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PositionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PositionGroupByOutputType[P]>
            : GetScalarType<T[P], PositionGroupByOutputType[P]>
        }
      >
    >


  export type PositionSelect = {
    id?: boolean
    event?: boolean | EventFindManyArgs
    x?: boolean
    y?: boolean
    playerSnapshot?: boolean | PlayerSnapshotFindManyArgs
    _count?: boolean | PositionCountOutputTypeArgs
  }

  export type PositionInclude = {
    event?: boolean | EventFindManyArgs
    playerSnapshot?: boolean | PlayerSnapshotFindManyArgs
    _count?: boolean | PositionCountOutputTypeArgs
  }

  export type PositionGetPayload<
    S extends boolean | null | undefined | PositionArgs,
    U = keyof S
      > = S extends true
        ? Position
    : S extends undefined
    ? never
    : S extends PositionArgs | PositionFindManyArgs
    ?'include' extends U
    ? Position  & {
    [P in TrueKeys<S['include']>]:
        P extends 'event' ? Array < EventGetPayload<S['include'][P]>>  :
        P extends 'playerSnapshot' ? Array < PlayerSnapshotGetPayload<S['include'][P]>>  :
        P extends '_count' ? PositionCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'event' ? Array < EventGetPayload<S['select'][P]>>  :
        P extends 'playerSnapshot' ? Array < PlayerSnapshotGetPayload<S['select'][P]>>  :
        P extends '_count' ? PositionCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Position ? Position[P] : never
  } 
    : Position
  : Position


  type PositionCountArgs = Merge<
    Omit<PositionFindManyArgs, 'select' | 'include'> & {
      select?: PositionCountAggregateInputType | true
    }
  >

  export interface PositionDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Position that matches the filter.
     * @param {PositionFindUniqueArgs} args - Arguments to find a Position
     * @example
     * // Get one Position
     * const position = await prisma.position.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PositionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PositionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Position'> extends True ? CheckSelect<T, Prisma__PositionClient<Position>, Prisma__PositionClient<PositionGetPayload<T>>> : CheckSelect<T, Prisma__PositionClient<Position | null >, Prisma__PositionClient<PositionGetPayload<T> | null >>

    /**
     * Find the first Position that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PositionFindFirstArgs} args - Arguments to find a Position
     * @example
     * // Get one Position
     * const position = await prisma.position.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PositionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PositionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Position'> extends True ? CheckSelect<T, Prisma__PositionClient<Position>, Prisma__PositionClient<PositionGetPayload<T>>> : CheckSelect<T, Prisma__PositionClient<Position | null >, Prisma__PositionClient<PositionGetPayload<T> | null >>

    /**
     * Find zero or more Positions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PositionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Positions
     * const positions = await prisma.position.findMany()
     * 
     * // Get first 10 Positions
     * const positions = await prisma.position.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const positionWithIdOnly = await prisma.position.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PositionFindManyArgs>(
      args?: SelectSubset<T, PositionFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Position>>, PrismaPromise<Array<PositionGetPayload<T>>>>

    /**
     * Create a Position.
     * @param {PositionCreateArgs} args - Arguments to create a Position.
     * @example
     * // Create one Position
     * const Position = await prisma.position.create({
     *   data: {
     *     // ... data to create a Position
     *   }
     * })
     * 
    **/
    create<T extends PositionCreateArgs>(
      args: SelectSubset<T, PositionCreateArgs>
    ): CheckSelect<T, Prisma__PositionClient<Position>, Prisma__PositionClient<PositionGetPayload<T>>>

    /**
     * Create many Positions.
     *     @param {PositionCreateManyArgs} args - Arguments to create many Positions.
     *     @example
     *     // Create many Positions
     *     const position = await prisma.position.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PositionCreateManyArgs>(
      args?: SelectSubset<T, PositionCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Position.
     * @param {PositionDeleteArgs} args - Arguments to delete one Position.
     * @example
     * // Delete one Position
     * const Position = await prisma.position.delete({
     *   where: {
     *     // ... filter to delete one Position
     *   }
     * })
     * 
    **/
    delete<T extends PositionDeleteArgs>(
      args: SelectSubset<T, PositionDeleteArgs>
    ): CheckSelect<T, Prisma__PositionClient<Position>, Prisma__PositionClient<PositionGetPayload<T>>>

    /**
     * Update one Position.
     * @param {PositionUpdateArgs} args - Arguments to update one Position.
     * @example
     * // Update one Position
     * const position = await prisma.position.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PositionUpdateArgs>(
      args: SelectSubset<T, PositionUpdateArgs>
    ): CheckSelect<T, Prisma__PositionClient<Position>, Prisma__PositionClient<PositionGetPayload<T>>>

    /**
     * Delete zero or more Positions.
     * @param {PositionDeleteManyArgs} args - Arguments to filter Positions to delete.
     * @example
     * // Delete a few Positions
     * const { count } = await prisma.position.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PositionDeleteManyArgs>(
      args?: SelectSubset<T, PositionDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Positions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PositionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Positions
     * const position = await prisma.position.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PositionUpdateManyArgs>(
      args: SelectSubset<T, PositionUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Position.
     * @param {PositionUpsertArgs} args - Arguments to update or create a Position.
     * @example
     * // Update or create a Position
     * const position = await prisma.position.upsert({
     *   create: {
     *     // ... data to create a Position
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Position we want to update
     *   }
     * })
    **/
    upsert<T extends PositionUpsertArgs>(
      args: SelectSubset<T, PositionUpsertArgs>
    ): CheckSelect<T, Prisma__PositionClient<Position>, Prisma__PositionClient<PositionGetPayload<T>>>

    /**
     * Count the number of Positions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PositionCountArgs} args - Arguments to filter Positions to count.
     * @example
     * // Count the number of Positions
     * const count = await prisma.position.count({
     *   where: {
     *     // ... the filter for the Positions we want to count
     *   }
     * })
    **/
    count<T extends PositionCountArgs>(
      args?: Subset<T, PositionCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PositionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Position.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PositionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PositionAggregateArgs>(args: Subset<T, PositionAggregateArgs>): PrismaPromise<GetPositionAggregateType<T>>

    /**
     * Group by Position.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PositionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PositionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PositionGroupByArgs['orderBy'] }
        : { orderBy?: PositionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PositionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPositionGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Position.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PositionClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    event<T extends EventFindManyArgs = {}>(args?: Subset<T, EventFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Event>>, PrismaPromise<Array<EventGetPayload<T>>>>;

    playerSnapshot<T extends PlayerSnapshotFindManyArgs = {}>(args?: Subset<T, PlayerSnapshotFindManyArgs>): CheckSelect<T, PrismaPromise<Array<PlayerSnapshot>>, PrismaPromise<Array<PlayerSnapshotGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Position findUnique
   */
  export type PositionFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Position
     * 
    **/
    select?: PositionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PositionInclude | null
    /**
     * Throw an Error if a Position can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Position to fetch.
     * 
    **/
    where: PositionWhereUniqueInput
  }


  /**
   * Position findFirst
   */
  export type PositionFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Position
     * 
    **/
    select?: PositionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PositionInclude | null
    /**
     * Throw an Error if a Position can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Position to fetch.
     * 
    **/
    where?: PositionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Positions to fetch.
     * 
    **/
    orderBy?: Enumerable<PositionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Positions.
     * 
    **/
    cursor?: PositionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Positions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Positions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Positions.
     * 
    **/
    distinct?: Enumerable<PositionScalarFieldEnum>
  }


  /**
   * Position findMany
   */
  export type PositionFindManyArgs = {
    /**
     * Select specific fields to fetch from the Position
     * 
    **/
    select?: PositionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PositionInclude | null
    /**
     * Filter, which Positions to fetch.
     * 
    **/
    where?: PositionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Positions to fetch.
     * 
    **/
    orderBy?: Enumerable<PositionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Positions.
     * 
    **/
    cursor?: PositionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Positions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Positions.
     * 
    **/
    skip?: number
    distinct?: Enumerable<PositionScalarFieldEnum>
  }


  /**
   * Position create
   */
  export type PositionCreateArgs = {
    /**
     * Select specific fields to fetch from the Position
     * 
    **/
    select?: PositionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PositionInclude | null
    /**
     * The data needed to create a Position.
     * 
    **/
    data: XOR<PositionCreateInput, PositionUncheckedCreateInput>
  }


  /**
   * Position createMany
   */
  export type PositionCreateManyArgs = {
    /**
     * The data used to create many Positions.
     * 
    **/
    data: Enumerable<PositionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Position update
   */
  export type PositionUpdateArgs = {
    /**
     * Select specific fields to fetch from the Position
     * 
    **/
    select?: PositionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PositionInclude | null
    /**
     * The data needed to update a Position.
     * 
    **/
    data: XOR<PositionUpdateInput, PositionUncheckedUpdateInput>
    /**
     * Choose, which Position to update.
     * 
    **/
    where: PositionWhereUniqueInput
  }


  /**
   * Position updateMany
   */
  export type PositionUpdateManyArgs = {
    /**
     * The data used to update Positions.
     * 
    **/
    data: XOR<PositionUpdateManyMutationInput, PositionUncheckedUpdateManyInput>
    /**
     * Filter which Positions to update
     * 
    **/
    where?: PositionWhereInput
  }


  /**
   * Position upsert
   */
  export type PositionUpsertArgs = {
    /**
     * Select specific fields to fetch from the Position
     * 
    **/
    select?: PositionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PositionInclude | null
    /**
     * The filter to search for the Position to update in case it exists.
     * 
    **/
    where: PositionWhereUniqueInput
    /**
     * In case the Position found by the `where` argument doesn't exist, create a new Position with this data.
     * 
    **/
    create: XOR<PositionCreateInput, PositionUncheckedCreateInput>
    /**
     * In case the Position was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<PositionUpdateInput, PositionUncheckedUpdateInput>
  }


  /**
   * Position delete
   */
  export type PositionDeleteArgs = {
    /**
     * Select specific fields to fetch from the Position
     * 
    **/
    select?: PositionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PositionInclude | null
    /**
     * Filter which Position to delete.
     * 
    **/
    where: PositionWhereUniqueInput
  }


  /**
   * Position deleteMany
   */
  export type PositionDeleteManyArgs = {
    /**
     * Filter which Positions to delete
     * 
    **/
    where?: PositionWhereInput
  }


  /**
   * Position without action
   */
  export type PositionArgs = {
    /**
     * Select specific fields to fetch from the Position
     * 
    **/
    select?: PositionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PositionInclude | null
  }



  /**
   * Model Profile
   */


  export type AggregateProfile = {
    _count: ProfileCountAggregateOutputType | null
    _avg: ProfileAvgAggregateOutputType | null
    _sum: ProfileSumAggregateOutputType | null
    _min: ProfileMinAggregateOutputType | null
    _max: ProfileMaxAggregateOutputType | null
  }

  export type ProfileAvgAggregateOutputType = {
    kills: number | null
    deaths: number | null
    assists: number | null
  }

  export type ProfileSumAggregateOutputType = {
    kills: number | null
    deaths: number | null
    assists: number | null
  }

  export type ProfileMinAggregateOutputType = {
    id: string | null
    update: boolean | null
    lastUpdate: Date | null
    kills: number | null
    deaths: number | null
    assists: number | null
    kda: string | null
    winRate: string | null
    csPerMinute: string | null
    damagePerMinute: string | null
    killsPerMinute: string | null
    goldPerMinute: string | null
    averageGameTime: string | null
    averageTimeSpentDead: string | null
    totalGameTime: string | null
  }

  export type ProfileMaxAggregateOutputType = {
    id: string | null
    update: boolean | null
    lastUpdate: Date | null
    kills: number | null
    deaths: number | null
    assists: number | null
    kda: string | null
    winRate: string | null
    csPerMinute: string | null
    damagePerMinute: string | null
    killsPerMinute: string | null
    goldPerMinute: string | null
    averageGameTime: string | null
    averageTimeSpentDead: string | null
    totalGameTime: string | null
  }

  export type ProfileCountAggregateOutputType = {
    id: number
    update: number
    lastUpdate: number
    kills: number
    deaths: number
    assists: number
    kda: number
    winRate: number
    csPerMinute: number
    damagePerMinute: number
    killsPerMinute: number
    goldPerMinute: number
    averageGameTime: number
    averageTimeSpentDead: number
    totalGameTime: number
    _all: number
  }


  export type ProfileAvgAggregateInputType = {
    kills?: true
    deaths?: true
    assists?: true
  }

  export type ProfileSumAggregateInputType = {
    kills?: true
    deaths?: true
    assists?: true
  }

  export type ProfileMinAggregateInputType = {
    id?: true
    update?: true
    lastUpdate?: true
    kills?: true
    deaths?: true
    assists?: true
    kda?: true
    winRate?: true
    csPerMinute?: true
    damagePerMinute?: true
    killsPerMinute?: true
    goldPerMinute?: true
    averageGameTime?: true
    averageTimeSpentDead?: true
    totalGameTime?: true
  }

  export type ProfileMaxAggregateInputType = {
    id?: true
    update?: true
    lastUpdate?: true
    kills?: true
    deaths?: true
    assists?: true
    kda?: true
    winRate?: true
    csPerMinute?: true
    damagePerMinute?: true
    killsPerMinute?: true
    goldPerMinute?: true
    averageGameTime?: true
    averageTimeSpentDead?: true
    totalGameTime?: true
  }

  export type ProfileCountAggregateInputType = {
    id?: true
    update?: true
    lastUpdate?: true
    kills?: true
    deaths?: true
    assists?: true
    kda?: true
    winRate?: true
    csPerMinute?: true
    damagePerMinute?: true
    killsPerMinute?: true
    goldPerMinute?: true
    averageGameTime?: true
    averageTimeSpentDead?: true
    totalGameTime?: true
    _all?: true
  }

  export type ProfileAggregateArgs = {
    /**
     * Filter which Profile to aggregate.
     * 
    **/
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     * 
    **/
    orderBy?: Enumerable<ProfileOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Profiles
    **/
    _count?: true | ProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProfileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProfileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProfileMaxAggregateInputType
  }

  export type GetProfileAggregateType<T extends ProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProfile[P]>
      : GetScalarType<T[P], AggregateProfile[P]>
  }




  export type ProfileGroupByArgs = {
    where?: ProfileWhereInput
    orderBy?: Enumerable<ProfileOrderByWithAggregationInput>
    by: Array<ProfileScalarFieldEnum>
    having?: ProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProfileCountAggregateInputType | true
    _avg?: ProfileAvgAggregateInputType
    _sum?: ProfileSumAggregateInputType
    _min?: ProfileMinAggregateInputType
    _max?: ProfileMaxAggregateInputType
  }


  export type ProfileGroupByOutputType = {
    id: string
    update: boolean
    lastUpdate: Date
    kills: number | null
    deaths: number | null
    assists: number | null
    kda: string
    winRate: string
    csPerMinute: string
    damagePerMinute: string
    killsPerMinute: string
    goldPerMinute: string
    averageGameTime: string
    averageTimeSpentDead: string
    totalGameTime: string
    _count: ProfileCountAggregateOutputType | null
    _avg: ProfileAvgAggregateOutputType | null
    _sum: ProfileSumAggregateOutputType | null
    _min: ProfileMinAggregateOutputType | null
    _max: ProfileMaxAggregateOutputType | null
  }

  type GetProfileGroupByPayload<T extends ProfileGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProfileGroupByOutputType[P]>
            : GetScalarType<T[P], ProfileGroupByOutputType[P]>
        }
      >
    >


  export type ProfileSelect = {
    id?: boolean
    update?: boolean
    player?: boolean | PlayerArgs
    lastUpdate?: boolean
    kills?: boolean
    deaths?: boolean
    assists?: boolean
    kda?: boolean
    winRate?: boolean
    csPerMinute?: boolean
    damagePerMinute?: boolean
    killsPerMinute?: boolean
    goldPerMinute?: boolean
    averageGameTime?: boolean
    averageTimeSpentDead?: boolean
    totalGameTime?: boolean
    activity?: boolean | ActivityFindManyArgs
    championWinrate?: boolean | ChampionWinrateFindManyArgs
    duos?: boolean | DuoFindManyArgs
    _count?: boolean | ProfileCountOutputTypeArgs
  }

  export type ProfileInclude = {
    player?: boolean | PlayerArgs
    activity?: boolean | ActivityFindManyArgs
    championWinrate?: boolean | ChampionWinrateFindManyArgs
    duos?: boolean | DuoFindManyArgs
    _count?: boolean | ProfileCountOutputTypeArgs
  }

  export type ProfileGetPayload<
    S extends boolean | null | undefined | ProfileArgs,
    U = keyof S
      > = S extends true
        ? Profile
    : S extends undefined
    ? never
    : S extends ProfileArgs | ProfileFindManyArgs
    ?'include' extends U
    ? Profile  & {
    [P in TrueKeys<S['include']>]:
        P extends 'player' ? PlayerGetPayload<S['include'][P]> | null :
        P extends 'activity' ? Array < ActivityGetPayload<S['include'][P]>>  :
        P extends 'championWinrate' ? Array < ChampionWinrateGetPayload<S['include'][P]>>  :
        P extends 'duos' ? Array < DuoGetPayload<S['include'][P]>>  :
        P extends '_count' ? ProfileCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'player' ? PlayerGetPayload<S['select'][P]> | null :
        P extends 'activity' ? Array < ActivityGetPayload<S['select'][P]>>  :
        P extends 'championWinrate' ? Array < ChampionWinrateGetPayload<S['select'][P]>>  :
        P extends 'duos' ? Array < DuoGetPayload<S['select'][P]>>  :
        P extends '_count' ? ProfileCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Profile ? Profile[P] : never
  } 
    : Profile
  : Profile


  type ProfileCountArgs = Merge<
    Omit<ProfileFindManyArgs, 'select' | 'include'> & {
      select?: ProfileCountAggregateInputType | true
    }
  >

  export interface ProfileDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Profile that matches the filter.
     * @param {ProfileFindUniqueArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProfileFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProfileFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Profile'> extends True ? CheckSelect<T, Prisma__ProfileClient<Profile>, Prisma__ProfileClient<ProfileGetPayload<T>>> : CheckSelect<T, Prisma__ProfileClient<Profile | null >, Prisma__ProfileClient<ProfileGetPayload<T> | null >>

    /**
     * Find the first Profile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindFirstArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProfileFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProfileFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Profile'> extends True ? CheckSelect<T, Prisma__ProfileClient<Profile>, Prisma__ProfileClient<ProfileGetPayload<T>>> : CheckSelect<T, Prisma__ProfileClient<Profile | null >, Prisma__ProfileClient<ProfileGetPayload<T> | null >>

    /**
     * Find zero or more Profiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Profiles
     * const profiles = await prisma.profile.findMany()
     * 
     * // Get first 10 Profiles
     * const profiles = await prisma.profile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const profileWithIdOnly = await prisma.profile.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProfileFindManyArgs>(
      args?: SelectSubset<T, ProfileFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Profile>>, PrismaPromise<Array<ProfileGetPayload<T>>>>

    /**
     * Create a Profile.
     * @param {ProfileCreateArgs} args - Arguments to create a Profile.
     * @example
     * // Create one Profile
     * const Profile = await prisma.profile.create({
     *   data: {
     *     // ... data to create a Profile
     *   }
     * })
     * 
    **/
    create<T extends ProfileCreateArgs>(
      args: SelectSubset<T, ProfileCreateArgs>
    ): CheckSelect<T, Prisma__ProfileClient<Profile>, Prisma__ProfileClient<ProfileGetPayload<T>>>

    /**
     * Create many Profiles.
     *     @param {ProfileCreateManyArgs} args - Arguments to create many Profiles.
     *     @example
     *     // Create many Profiles
     *     const profile = await prisma.profile.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProfileCreateManyArgs>(
      args?: SelectSubset<T, ProfileCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Profile.
     * @param {ProfileDeleteArgs} args - Arguments to delete one Profile.
     * @example
     * // Delete one Profile
     * const Profile = await prisma.profile.delete({
     *   where: {
     *     // ... filter to delete one Profile
     *   }
     * })
     * 
    **/
    delete<T extends ProfileDeleteArgs>(
      args: SelectSubset<T, ProfileDeleteArgs>
    ): CheckSelect<T, Prisma__ProfileClient<Profile>, Prisma__ProfileClient<ProfileGetPayload<T>>>

    /**
     * Update one Profile.
     * @param {ProfileUpdateArgs} args - Arguments to update one Profile.
     * @example
     * // Update one Profile
     * const profile = await prisma.profile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProfileUpdateArgs>(
      args: SelectSubset<T, ProfileUpdateArgs>
    ): CheckSelect<T, Prisma__ProfileClient<Profile>, Prisma__ProfileClient<ProfileGetPayload<T>>>

    /**
     * Delete zero or more Profiles.
     * @param {ProfileDeleteManyArgs} args - Arguments to filter Profiles to delete.
     * @example
     * // Delete a few Profiles
     * const { count } = await prisma.profile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProfileDeleteManyArgs>(
      args?: SelectSubset<T, ProfileDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Profiles
     * const profile = await prisma.profile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProfileUpdateManyArgs>(
      args: SelectSubset<T, ProfileUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Profile.
     * @param {ProfileUpsertArgs} args - Arguments to update or create a Profile.
     * @example
     * // Update or create a Profile
     * const profile = await prisma.profile.upsert({
     *   create: {
     *     // ... data to create a Profile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Profile we want to update
     *   }
     * })
    **/
    upsert<T extends ProfileUpsertArgs>(
      args: SelectSubset<T, ProfileUpsertArgs>
    ): CheckSelect<T, Prisma__ProfileClient<Profile>, Prisma__ProfileClient<ProfileGetPayload<T>>>

    /**
     * Count the number of Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileCountArgs} args - Arguments to filter Profiles to count.
     * @example
     * // Count the number of Profiles
     * const count = await prisma.profile.count({
     *   where: {
     *     // ... the filter for the Profiles we want to count
     *   }
     * })
    **/
    count<T extends ProfileCountArgs>(
      args?: Subset<T, ProfileCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProfileAggregateArgs>(args: Subset<T, ProfileAggregateArgs>): PrismaPromise<GetProfileAggregateType<T>>

    /**
     * Group by Profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProfileGroupByArgs['orderBy'] }
        : { orderBy?: ProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProfileGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Profile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProfileClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    player<T extends PlayerArgs = {}>(args?: Subset<T, PlayerArgs>): CheckSelect<T, Prisma__PlayerClient<Player | null >, Prisma__PlayerClient<PlayerGetPayload<T> | null >>;

    activity<T extends ActivityFindManyArgs = {}>(args?: Subset<T, ActivityFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Activity>>, PrismaPromise<Array<ActivityGetPayload<T>>>>;

    championWinrate<T extends ChampionWinrateFindManyArgs = {}>(args?: Subset<T, ChampionWinrateFindManyArgs>): CheckSelect<T, PrismaPromise<Array<ChampionWinrate>>, PrismaPromise<Array<ChampionWinrateGetPayload<T>>>>;

    duos<T extends DuoFindManyArgs = {}>(args?: Subset<T, DuoFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Duo>>, PrismaPromise<Array<DuoGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Profile findUnique
   */
  export type ProfileFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Profile
     * 
    **/
    select?: ProfileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProfileInclude | null
    /**
     * Throw an Error if a Profile can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Profile to fetch.
     * 
    **/
    where: ProfileWhereUniqueInput
  }


  /**
   * Profile findFirst
   */
  export type ProfileFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Profile
     * 
    **/
    select?: ProfileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProfileInclude | null
    /**
     * Throw an Error if a Profile can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Profile to fetch.
     * 
    **/
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     * 
    **/
    orderBy?: Enumerable<ProfileOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Profiles.
     * 
    **/
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Profiles.
     * 
    **/
    distinct?: Enumerable<ProfileScalarFieldEnum>
  }


  /**
   * Profile findMany
   */
  export type ProfileFindManyArgs = {
    /**
     * Select specific fields to fetch from the Profile
     * 
    **/
    select?: ProfileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProfileInclude | null
    /**
     * Filter, which Profiles to fetch.
     * 
    **/
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     * 
    **/
    orderBy?: Enumerable<ProfileOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Profiles.
     * 
    **/
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ProfileScalarFieldEnum>
  }


  /**
   * Profile create
   */
  export type ProfileCreateArgs = {
    /**
     * Select specific fields to fetch from the Profile
     * 
    **/
    select?: ProfileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProfileInclude | null
    /**
     * The data needed to create a Profile.
     * 
    **/
    data: XOR<ProfileCreateInput, ProfileUncheckedCreateInput>
  }


  /**
   * Profile createMany
   */
  export type ProfileCreateManyArgs = {
    /**
     * The data used to create many Profiles.
     * 
    **/
    data: Enumerable<ProfileCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Profile update
   */
  export type ProfileUpdateArgs = {
    /**
     * Select specific fields to fetch from the Profile
     * 
    **/
    select?: ProfileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProfileInclude | null
    /**
     * The data needed to update a Profile.
     * 
    **/
    data: XOR<ProfileUpdateInput, ProfileUncheckedUpdateInput>
    /**
     * Choose, which Profile to update.
     * 
    **/
    where: ProfileWhereUniqueInput
  }


  /**
   * Profile updateMany
   */
  export type ProfileUpdateManyArgs = {
    /**
     * The data used to update Profiles.
     * 
    **/
    data: XOR<ProfileUpdateManyMutationInput, ProfileUncheckedUpdateManyInput>
    /**
     * Filter which Profiles to update
     * 
    **/
    where?: ProfileWhereInput
  }


  /**
   * Profile upsert
   */
  export type ProfileUpsertArgs = {
    /**
     * Select specific fields to fetch from the Profile
     * 
    **/
    select?: ProfileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProfileInclude | null
    /**
     * The filter to search for the Profile to update in case it exists.
     * 
    **/
    where: ProfileWhereUniqueInput
    /**
     * In case the Profile found by the `where` argument doesn't exist, create a new Profile with this data.
     * 
    **/
    create: XOR<ProfileCreateInput, ProfileUncheckedCreateInput>
    /**
     * In case the Profile was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ProfileUpdateInput, ProfileUncheckedUpdateInput>
  }


  /**
   * Profile delete
   */
  export type ProfileDeleteArgs = {
    /**
     * Select specific fields to fetch from the Profile
     * 
    **/
    select?: ProfileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProfileInclude | null
    /**
     * Filter which Profile to delete.
     * 
    **/
    where: ProfileWhereUniqueInput
  }


  /**
   * Profile deleteMany
   */
  export type ProfileDeleteManyArgs = {
    /**
     * Filter which Profiles to delete
     * 
    **/
    where?: ProfileWhereInput
  }


  /**
   * Profile without action
   */
  export type ProfileArgs = {
    /**
     * Select specific fields to fetch from the Profile
     * 
    **/
    select?: ProfileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProfileInclude | null
  }



  /**
   * Model SeedIdentifier
   */


  export type AggregateSeedIdentifier = {
    _count: SeedIdentifierCountAggregateOutputType | null
    _min: SeedIdentifierMinAggregateOutputType | null
    _max: SeedIdentifierMaxAggregateOutputType | null
  }

  export type SeedIdentifierMinAggregateOutputType = {
    id: string | null
    identifier: string | null
    type: string | null
    timestamp: Date | null
    priority: boolean | null
    retrieved: boolean | null
  }

  export type SeedIdentifierMaxAggregateOutputType = {
    id: string | null
    identifier: string | null
    type: string | null
    timestamp: Date | null
    priority: boolean | null
    retrieved: boolean | null
  }

  export type SeedIdentifierCountAggregateOutputType = {
    id: number
    identifier: number
    type: number
    timestamp: number
    priority: number
    retrieved: number
    _all: number
  }


  export type SeedIdentifierMinAggregateInputType = {
    id?: true
    identifier?: true
    type?: true
    timestamp?: true
    priority?: true
    retrieved?: true
  }

  export type SeedIdentifierMaxAggregateInputType = {
    id?: true
    identifier?: true
    type?: true
    timestamp?: true
    priority?: true
    retrieved?: true
  }

  export type SeedIdentifierCountAggregateInputType = {
    id?: true
    identifier?: true
    type?: true
    timestamp?: true
    priority?: true
    retrieved?: true
    _all?: true
  }

  export type SeedIdentifierAggregateArgs = {
    /**
     * Filter which SeedIdentifier to aggregate.
     * 
    **/
    where?: SeedIdentifierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SeedIdentifiers to fetch.
     * 
    **/
    orderBy?: Enumerable<SeedIdentifierOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: SeedIdentifierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SeedIdentifiers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SeedIdentifiers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SeedIdentifiers
    **/
    _count?: true | SeedIdentifierCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SeedIdentifierMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SeedIdentifierMaxAggregateInputType
  }

  export type GetSeedIdentifierAggregateType<T extends SeedIdentifierAggregateArgs> = {
        [P in keyof T & keyof AggregateSeedIdentifier]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSeedIdentifier[P]>
      : GetScalarType<T[P], AggregateSeedIdentifier[P]>
  }




  export type SeedIdentifierGroupByArgs = {
    where?: SeedIdentifierWhereInput
    orderBy?: Enumerable<SeedIdentifierOrderByWithAggregationInput>
    by: Array<SeedIdentifierScalarFieldEnum>
    having?: SeedIdentifierScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SeedIdentifierCountAggregateInputType | true
    _min?: SeedIdentifierMinAggregateInputType
    _max?: SeedIdentifierMaxAggregateInputType
  }


  export type SeedIdentifierGroupByOutputType = {
    id: string
    identifier: string
    type: string
    timestamp: Date
    priority: boolean
    retrieved: boolean
    _count: SeedIdentifierCountAggregateOutputType | null
    _min: SeedIdentifierMinAggregateOutputType | null
    _max: SeedIdentifierMaxAggregateOutputType | null
  }

  type GetSeedIdentifierGroupByPayload<T extends SeedIdentifierGroupByArgs> = PrismaPromise<
    Array<
      PickArray<SeedIdentifierGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SeedIdentifierGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SeedIdentifierGroupByOutputType[P]>
            : GetScalarType<T[P], SeedIdentifierGroupByOutputType[P]>
        }
      >
    >


  export type SeedIdentifierSelect = {
    id?: boolean
    identifier?: boolean
    type?: boolean
    timestamp?: boolean
    priority?: boolean
    retrieved?: boolean
  }

  export type SeedIdentifierGetPayload<
    S extends boolean | null | undefined | SeedIdentifierArgs,
    U = keyof S
      > = S extends true
        ? SeedIdentifier
    : S extends undefined
    ? never
    : S extends SeedIdentifierArgs | SeedIdentifierFindManyArgs
    ?'include' extends U
    ? SeedIdentifier 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof SeedIdentifier ? SeedIdentifier[P] : never
  } 
    : SeedIdentifier
  : SeedIdentifier


  type SeedIdentifierCountArgs = Merge<
    Omit<SeedIdentifierFindManyArgs, 'select' | 'include'> & {
      select?: SeedIdentifierCountAggregateInputType | true
    }
  >

  export interface SeedIdentifierDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one SeedIdentifier that matches the filter.
     * @param {SeedIdentifierFindUniqueArgs} args - Arguments to find a SeedIdentifier
     * @example
     * // Get one SeedIdentifier
     * const seedIdentifier = await prisma.seedIdentifier.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SeedIdentifierFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SeedIdentifierFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'SeedIdentifier'> extends True ? CheckSelect<T, Prisma__SeedIdentifierClient<SeedIdentifier>, Prisma__SeedIdentifierClient<SeedIdentifierGetPayload<T>>> : CheckSelect<T, Prisma__SeedIdentifierClient<SeedIdentifier | null >, Prisma__SeedIdentifierClient<SeedIdentifierGetPayload<T> | null >>

    /**
     * Find the first SeedIdentifier that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeedIdentifierFindFirstArgs} args - Arguments to find a SeedIdentifier
     * @example
     * // Get one SeedIdentifier
     * const seedIdentifier = await prisma.seedIdentifier.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SeedIdentifierFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SeedIdentifierFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'SeedIdentifier'> extends True ? CheckSelect<T, Prisma__SeedIdentifierClient<SeedIdentifier>, Prisma__SeedIdentifierClient<SeedIdentifierGetPayload<T>>> : CheckSelect<T, Prisma__SeedIdentifierClient<SeedIdentifier | null >, Prisma__SeedIdentifierClient<SeedIdentifierGetPayload<T> | null >>

    /**
     * Find zero or more SeedIdentifiers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeedIdentifierFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SeedIdentifiers
     * const seedIdentifiers = await prisma.seedIdentifier.findMany()
     * 
     * // Get first 10 SeedIdentifiers
     * const seedIdentifiers = await prisma.seedIdentifier.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const seedIdentifierWithIdOnly = await prisma.seedIdentifier.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SeedIdentifierFindManyArgs>(
      args?: SelectSubset<T, SeedIdentifierFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<SeedIdentifier>>, PrismaPromise<Array<SeedIdentifierGetPayload<T>>>>

    /**
     * Create a SeedIdentifier.
     * @param {SeedIdentifierCreateArgs} args - Arguments to create a SeedIdentifier.
     * @example
     * // Create one SeedIdentifier
     * const SeedIdentifier = await prisma.seedIdentifier.create({
     *   data: {
     *     // ... data to create a SeedIdentifier
     *   }
     * })
     * 
    **/
    create<T extends SeedIdentifierCreateArgs>(
      args: SelectSubset<T, SeedIdentifierCreateArgs>
    ): CheckSelect<T, Prisma__SeedIdentifierClient<SeedIdentifier>, Prisma__SeedIdentifierClient<SeedIdentifierGetPayload<T>>>

    /**
     * Create many SeedIdentifiers.
     *     @param {SeedIdentifierCreateManyArgs} args - Arguments to create many SeedIdentifiers.
     *     @example
     *     // Create many SeedIdentifiers
     *     const seedIdentifier = await prisma.seedIdentifier.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SeedIdentifierCreateManyArgs>(
      args?: SelectSubset<T, SeedIdentifierCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a SeedIdentifier.
     * @param {SeedIdentifierDeleteArgs} args - Arguments to delete one SeedIdentifier.
     * @example
     * // Delete one SeedIdentifier
     * const SeedIdentifier = await prisma.seedIdentifier.delete({
     *   where: {
     *     // ... filter to delete one SeedIdentifier
     *   }
     * })
     * 
    **/
    delete<T extends SeedIdentifierDeleteArgs>(
      args: SelectSubset<T, SeedIdentifierDeleteArgs>
    ): CheckSelect<T, Prisma__SeedIdentifierClient<SeedIdentifier>, Prisma__SeedIdentifierClient<SeedIdentifierGetPayload<T>>>

    /**
     * Update one SeedIdentifier.
     * @param {SeedIdentifierUpdateArgs} args - Arguments to update one SeedIdentifier.
     * @example
     * // Update one SeedIdentifier
     * const seedIdentifier = await prisma.seedIdentifier.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SeedIdentifierUpdateArgs>(
      args: SelectSubset<T, SeedIdentifierUpdateArgs>
    ): CheckSelect<T, Prisma__SeedIdentifierClient<SeedIdentifier>, Prisma__SeedIdentifierClient<SeedIdentifierGetPayload<T>>>

    /**
     * Delete zero or more SeedIdentifiers.
     * @param {SeedIdentifierDeleteManyArgs} args - Arguments to filter SeedIdentifiers to delete.
     * @example
     * // Delete a few SeedIdentifiers
     * const { count } = await prisma.seedIdentifier.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SeedIdentifierDeleteManyArgs>(
      args?: SelectSubset<T, SeedIdentifierDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more SeedIdentifiers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeedIdentifierUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SeedIdentifiers
     * const seedIdentifier = await prisma.seedIdentifier.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SeedIdentifierUpdateManyArgs>(
      args: SelectSubset<T, SeedIdentifierUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one SeedIdentifier.
     * @param {SeedIdentifierUpsertArgs} args - Arguments to update or create a SeedIdentifier.
     * @example
     * // Update or create a SeedIdentifier
     * const seedIdentifier = await prisma.seedIdentifier.upsert({
     *   create: {
     *     // ... data to create a SeedIdentifier
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SeedIdentifier we want to update
     *   }
     * })
    **/
    upsert<T extends SeedIdentifierUpsertArgs>(
      args: SelectSubset<T, SeedIdentifierUpsertArgs>
    ): CheckSelect<T, Prisma__SeedIdentifierClient<SeedIdentifier>, Prisma__SeedIdentifierClient<SeedIdentifierGetPayload<T>>>

    /**
     * Count the number of SeedIdentifiers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeedIdentifierCountArgs} args - Arguments to filter SeedIdentifiers to count.
     * @example
     * // Count the number of SeedIdentifiers
     * const count = await prisma.seedIdentifier.count({
     *   where: {
     *     // ... the filter for the SeedIdentifiers we want to count
     *   }
     * })
    **/
    count<T extends SeedIdentifierCountArgs>(
      args?: Subset<T, SeedIdentifierCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SeedIdentifierCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SeedIdentifier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeedIdentifierAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SeedIdentifierAggregateArgs>(args: Subset<T, SeedIdentifierAggregateArgs>): PrismaPromise<GetSeedIdentifierAggregateType<T>>

    /**
     * Group by SeedIdentifier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeedIdentifierGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SeedIdentifierGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SeedIdentifierGroupByArgs['orderBy'] }
        : { orderBy?: SeedIdentifierGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SeedIdentifierGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSeedIdentifierGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for SeedIdentifier.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SeedIdentifierClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * SeedIdentifier findUnique
   */
  export type SeedIdentifierFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the SeedIdentifier
     * 
    **/
    select?: SeedIdentifierSelect | null
    /**
     * Throw an Error if a SeedIdentifier can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which SeedIdentifier to fetch.
     * 
    **/
    where: SeedIdentifierWhereUniqueInput
  }


  /**
   * SeedIdentifier findFirst
   */
  export type SeedIdentifierFindFirstArgs = {
    /**
     * Select specific fields to fetch from the SeedIdentifier
     * 
    **/
    select?: SeedIdentifierSelect | null
    /**
     * Throw an Error if a SeedIdentifier can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which SeedIdentifier to fetch.
     * 
    **/
    where?: SeedIdentifierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SeedIdentifiers to fetch.
     * 
    **/
    orderBy?: Enumerable<SeedIdentifierOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SeedIdentifiers.
     * 
    **/
    cursor?: SeedIdentifierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SeedIdentifiers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SeedIdentifiers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SeedIdentifiers.
     * 
    **/
    distinct?: Enumerable<SeedIdentifierScalarFieldEnum>
  }


  /**
   * SeedIdentifier findMany
   */
  export type SeedIdentifierFindManyArgs = {
    /**
     * Select specific fields to fetch from the SeedIdentifier
     * 
    **/
    select?: SeedIdentifierSelect | null
    /**
     * Filter, which SeedIdentifiers to fetch.
     * 
    **/
    where?: SeedIdentifierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SeedIdentifiers to fetch.
     * 
    **/
    orderBy?: Enumerable<SeedIdentifierOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SeedIdentifiers.
     * 
    **/
    cursor?: SeedIdentifierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SeedIdentifiers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SeedIdentifiers.
     * 
    **/
    skip?: number
    distinct?: Enumerable<SeedIdentifierScalarFieldEnum>
  }


  /**
   * SeedIdentifier create
   */
  export type SeedIdentifierCreateArgs = {
    /**
     * Select specific fields to fetch from the SeedIdentifier
     * 
    **/
    select?: SeedIdentifierSelect | null
    /**
     * The data needed to create a SeedIdentifier.
     * 
    **/
    data: XOR<SeedIdentifierCreateInput, SeedIdentifierUncheckedCreateInput>
  }


  /**
   * SeedIdentifier createMany
   */
  export type SeedIdentifierCreateManyArgs = {
    /**
     * The data used to create many SeedIdentifiers.
     * 
    **/
    data: Enumerable<SeedIdentifierCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * SeedIdentifier update
   */
  export type SeedIdentifierUpdateArgs = {
    /**
     * Select specific fields to fetch from the SeedIdentifier
     * 
    **/
    select?: SeedIdentifierSelect | null
    /**
     * The data needed to update a SeedIdentifier.
     * 
    **/
    data: XOR<SeedIdentifierUpdateInput, SeedIdentifierUncheckedUpdateInput>
    /**
     * Choose, which SeedIdentifier to update.
     * 
    **/
    where: SeedIdentifierWhereUniqueInput
  }


  /**
   * SeedIdentifier updateMany
   */
  export type SeedIdentifierUpdateManyArgs = {
    /**
     * The data used to update SeedIdentifiers.
     * 
    **/
    data: XOR<SeedIdentifierUpdateManyMutationInput, SeedIdentifierUncheckedUpdateManyInput>
    /**
     * Filter which SeedIdentifiers to update
     * 
    **/
    where?: SeedIdentifierWhereInput
  }


  /**
   * SeedIdentifier upsert
   */
  export type SeedIdentifierUpsertArgs = {
    /**
     * Select specific fields to fetch from the SeedIdentifier
     * 
    **/
    select?: SeedIdentifierSelect | null
    /**
     * The filter to search for the SeedIdentifier to update in case it exists.
     * 
    **/
    where: SeedIdentifierWhereUniqueInput
    /**
     * In case the SeedIdentifier found by the `where` argument doesn't exist, create a new SeedIdentifier with this data.
     * 
    **/
    create: XOR<SeedIdentifierCreateInput, SeedIdentifierUncheckedCreateInput>
    /**
     * In case the SeedIdentifier was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<SeedIdentifierUpdateInput, SeedIdentifierUncheckedUpdateInput>
  }


  /**
   * SeedIdentifier delete
   */
  export type SeedIdentifierDeleteArgs = {
    /**
     * Select specific fields to fetch from the SeedIdentifier
     * 
    **/
    select?: SeedIdentifierSelect | null
    /**
     * Filter which SeedIdentifier to delete.
     * 
    **/
    where: SeedIdentifierWhereUniqueInput
  }


  /**
   * SeedIdentifier deleteMany
   */
  export type SeedIdentifierDeleteManyArgs = {
    /**
     * Filter which SeedIdentifiers to delete
     * 
    **/
    where?: SeedIdentifierWhereInput
  }


  /**
   * SeedIdentifier without action
   */
  export type SeedIdentifierArgs = {
    /**
     * Select specific fields to fetch from the SeedIdentifier
     * 
    **/
    select?: SeedIdentifierSelect | null
  }



  /**
   * Model Source
   */


  export type AggregateSource = {
    _count: SourceCountAggregateOutputType | null
    _min: SourceMinAggregateOutputType | null
    _max: SourceMaxAggregateOutputType | null
  }

  export type SourceMinAggregateOutputType = {
    id: string | null
    api: string | null
  }

  export type SourceMaxAggregateOutputType = {
    id: string | null
    api: string | null
  }

  export type SourceCountAggregateOutputType = {
    id: number
    api: number
    _all: number
  }


  export type SourceMinAggregateInputType = {
    id?: true
    api?: true
  }

  export type SourceMaxAggregateInputType = {
    id?: true
    api?: true
  }

  export type SourceCountAggregateInputType = {
    id?: true
    api?: true
    _all?: true
  }

  export type SourceAggregateArgs = {
    /**
     * Filter which Source to aggregate.
     * 
    **/
    where?: SourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sources to fetch.
     * 
    **/
    orderBy?: Enumerable<SourceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: SourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sources from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sources.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sources
    **/
    _count?: true | SourceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SourceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SourceMaxAggregateInputType
  }

  export type GetSourceAggregateType<T extends SourceAggregateArgs> = {
        [P in keyof T & keyof AggregateSource]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSource[P]>
      : GetScalarType<T[P], AggregateSource[P]>
  }




  export type SourceGroupByArgs = {
    where?: SourceWhereInput
    orderBy?: Enumerable<SourceOrderByWithAggregationInput>
    by: Array<SourceScalarFieldEnum>
    having?: SourceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SourceCountAggregateInputType | true
    _min?: SourceMinAggregateInputType
    _max?: SourceMaxAggregateInputType
  }


  export type SourceGroupByOutputType = {
    id: string
    api: string
    _count: SourceCountAggregateOutputType | null
    _min: SourceMinAggregateOutputType | null
    _max: SourceMaxAggregateOutputType | null
  }

  type GetSourceGroupByPayload<T extends SourceGroupByArgs> = PrismaPromise<
    Array<
      PickArray<SourceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SourceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SourceGroupByOutputType[P]>
            : GetScalarType<T[P], SourceGroupByOutputType[P]>
        }
      >
    >


  export type SourceSelect = {
    id?: boolean
    game?: boolean | GameFindManyArgs
    api?: boolean
    _count?: boolean | SourceCountOutputTypeArgs
  }

  export type SourceInclude = {
    game?: boolean | GameFindManyArgs
    _count?: boolean | SourceCountOutputTypeArgs
  }

  export type SourceGetPayload<
    S extends boolean | null | undefined | SourceArgs,
    U = keyof S
      > = S extends true
        ? Source
    : S extends undefined
    ? never
    : S extends SourceArgs | SourceFindManyArgs
    ?'include' extends U
    ? Source  & {
    [P in TrueKeys<S['include']>]:
        P extends 'game' ? Array < GameGetPayload<S['include'][P]>>  :
        P extends '_count' ? SourceCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'game' ? Array < GameGetPayload<S['select'][P]>>  :
        P extends '_count' ? SourceCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Source ? Source[P] : never
  } 
    : Source
  : Source


  type SourceCountArgs = Merge<
    Omit<SourceFindManyArgs, 'select' | 'include'> & {
      select?: SourceCountAggregateInputType | true
    }
  >

  export interface SourceDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Source that matches the filter.
     * @param {SourceFindUniqueArgs} args - Arguments to find a Source
     * @example
     * // Get one Source
     * const source = await prisma.source.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SourceFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SourceFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Source'> extends True ? CheckSelect<T, Prisma__SourceClient<Source>, Prisma__SourceClient<SourceGetPayload<T>>> : CheckSelect<T, Prisma__SourceClient<Source | null >, Prisma__SourceClient<SourceGetPayload<T> | null >>

    /**
     * Find the first Source that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceFindFirstArgs} args - Arguments to find a Source
     * @example
     * // Get one Source
     * const source = await prisma.source.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SourceFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SourceFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Source'> extends True ? CheckSelect<T, Prisma__SourceClient<Source>, Prisma__SourceClient<SourceGetPayload<T>>> : CheckSelect<T, Prisma__SourceClient<Source | null >, Prisma__SourceClient<SourceGetPayload<T> | null >>

    /**
     * Find zero or more Sources that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sources
     * const sources = await prisma.source.findMany()
     * 
     * // Get first 10 Sources
     * const sources = await prisma.source.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sourceWithIdOnly = await prisma.source.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SourceFindManyArgs>(
      args?: SelectSubset<T, SourceFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Source>>, PrismaPromise<Array<SourceGetPayload<T>>>>

    /**
     * Create a Source.
     * @param {SourceCreateArgs} args - Arguments to create a Source.
     * @example
     * // Create one Source
     * const Source = await prisma.source.create({
     *   data: {
     *     // ... data to create a Source
     *   }
     * })
     * 
    **/
    create<T extends SourceCreateArgs>(
      args: SelectSubset<T, SourceCreateArgs>
    ): CheckSelect<T, Prisma__SourceClient<Source>, Prisma__SourceClient<SourceGetPayload<T>>>

    /**
     * Create many Sources.
     *     @param {SourceCreateManyArgs} args - Arguments to create many Sources.
     *     @example
     *     // Create many Sources
     *     const source = await prisma.source.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SourceCreateManyArgs>(
      args?: SelectSubset<T, SourceCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Source.
     * @param {SourceDeleteArgs} args - Arguments to delete one Source.
     * @example
     * // Delete one Source
     * const Source = await prisma.source.delete({
     *   where: {
     *     // ... filter to delete one Source
     *   }
     * })
     * 
    **/
    delete<T extends SourceDeleteArgs>(
      args: SelectSubset<T, SourceDeleteArgs>
    ): CheckSelect<T, Prisma__SourceClient<Source>, Prisma__SourceClient<SourceGetPayload<T>>>

    /**
     * Update one Source.
     * @param {SourceUpdateArgs} args - Arguments to update one Source.
     * @example
     * // Update one Source
     * const source = await prisma.source.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SourceUpdateArgs>(
      args: SelectSubset<T, SourceUpdateArgs>
    ): CheckSelect<T, Prisma__SourceClient<Source>, Prisma__SourceClient<SourceGetPayload<T>>>

    /**
     * Delete zero or more Sources.
     * @param {SourceDeleteManyArgs} args - Arguments to filter Sources to delete.
     * @example
     * // Delete a few Sources
     * const { count } = await prisma.source.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SourceDeleteManyArgs>(
      args?: SelectSubset<T, SourceDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sources
     * const source = await prisma.source.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SourceUpdateManyArgs>(
      args: SelectSubset<T, SourceUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Source.
     * @param {SourceUpsertArgs} args - Arguments to update or create a Source.
     * @example
     * // Update or create a Source
     * const source = await prisma.source.upsert({
     *   create: {
     *     // ... data to create a Source
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Source we want to update
     *   }
     * })
    **/
    upsert<T extends SourceUpsertArgs>(
      args: SelectSubset<T, SourceUpsertArgs>
    ): CheckSelect<T, Prisma__SourceClient<Source>, Prisma__SourceClient<SourceGetPayload<T>>>

    /**
     * Count the number of Sources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceCountArgs} args - Arguments to filter Sources to count.
     * @example
     * // Count the number of Sources
     * const count = await prisma.source.count({
     *   where: {
     *     // ... the filter for the Sources we want to count
     *   }
     * })
    **/
    count<T extends SourceCountArgs>(
      args?: Subset<T, SourceCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SourceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Source.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SourceAggregateArgs>(args: Subset<T, SourceAggregateArgs>): PrismaPromise<GetSourceAggregateType<T>>

    /**
     * Group by Source.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SourceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SourceGroupByArgs['orderBy'] }
        : { orderBy?: SourceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SourceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSourceGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Source.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SourceClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    game<T extends GameFindManyArgs = {}>(args?: Subset<T, GameFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Game>>, PrismaPromise<Array<GameGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Source findUnique
   */
  export type SourceFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Source
     * 
    **/
    select?: SourceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SourceInclude | null
    /**
     * Throw an Error if a Source can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Source to fetch.
     * 
    **/
    where: SourceWhereUniqueInput
  }


  /**
   * Source findFirst
   */
  export type SourceFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Source
     * 
    **/
    select?: SourceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SourceInclude | null
    /**
     * Throw an Error if a Source can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Source to fetch.
     * 
    **/
    where?: SourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sources to fetch.
     * 
    **/
    orderBy?: Enumerable<SourceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sources.
     * 
    **/
    cursor?: SourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sources from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sources.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sources.
     * 
    **/
    distinct?: Enumerable<SourceScalarFieldEnum>
  }


  /**
   * Source findMany
   */
  export type SourceFindManyArgs = {
    /**
     * Select specific fields to fetch from the Source
     * 
    **/
    select?: SourceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SourceInclude | null
    /**
     * Filter, which Sources to fetch.
     * 
    **/
    where?: SourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sources to fetch.
     * 
    **/
    orderBy?: Enumerable<SourceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sources.
     * 
    **/
    cursor?: SourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sources from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sources.
     * 
    **/
    skip?: number
    distinct?: Enumerable<SourceScalarFieldEnum>
  }


  /**
   * Source create
   */
  export type SourceCreateArgs = {
    /**
     * Select specific fields to fetch from the Source
     * 
    **/
    select?: SourceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SourceInclude | null
    /**
     * The data needed to create a Source.
     * 
    **/
    data: XOR<SourceCreateInput, SourceUncheckedCreateInput>
  }


  /**
   * Source createMany
   */
  export type SourceCreateManyArgs = {
    /**
     * The data used to create many Sources.
     * 
    **/
    data: Enumerable<SourceCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Source update
   */
  export type SourceUpdateArgs = {
    /**
     * Select specific fields to fetch from the Source
     * 
    **/
    select?: SourceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SourceInclude | null
    /**
     * The data needed to update a Source.
     * 
    **/
    data: XOR<SourceUpdateInput, SourceUncheckedUpdateInput>
    /**
     * Choose, which Source to update.
     * 
    **/
    where: SourceWhereUniqueInput
  }


  /**
   * Source updateMany
   */
  export type SourceUpdateManyArgs = {
    /**
     * The data used to update Sources.
     * 
    **/
    data: XOR<SourceUpdateManyMutationInput, SourceUncheckedUpdateManyInput>
    /**
     * Filter which Sources to update
     * 
    **/
    where?: SourceWhereInput
  }


  /**
   * Source upsert
   */
  export type SourceUpsertArgs = {
    /**
     * Select specific fields to fetch from the Source
     * 
    **/
    select?: SourceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SourceInclude | null
    /**
     * The filter to search for the Source to update in case it exists.
     * 
    **/
    where: SourceWhereUniqueInput
    /**
     * In case the Source found by the `where` argument doesn't exist, create a new Source with this data.
     * 
    **/
    create: XOR<SourceCreateInput, SourceUncheckedCreateInput>
    /**
     * In case the Source was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<SourceUpdateInput, SourceUncheckedUpdateInput>
  }


  /**
   * Source delete
   */
  export type SourceDeleteArgs = {
    /**
     * Select specific fields to fetch from the Source
     * 
    **/
    select?: SourceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SourceInclude | null
    /**
     * Filter which Source to delete.
     * 
    **/
    where: SourceWhereUniqueInput
  }


  /**
   * Source deleteMany
   */
  export type SourceDeleteManyArgs = {
    /**
     * Filter which Sources to delete
     * 
    **/
    where?: SourceWhereInput
  }


  /**
   * Source without action
   */
  export type SourceArgs = {
    /**
     * Select specific fields to fetch from the Source
     * 
    **/
    select?: SourceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SourceInclude | null
  }



  /**
   * Model Team
   */


  export type AggregateTeam = {
    _count: TeamCountAggregateOutputType | null
    _avg: TeamAvgAggregateOutputType | null
    _sum: TeamSumAggregateOutputType | null
    _min: TeamMinAggregateOutputType | null
    _max: TeamMaxAggregateOutputType | null
  }

  export type TeamAvgAggregateOutputType = {
    teamId: number | null
  }

  export type TeamSumAggregateOutputType = {
    teamId: number | null
  }

  export type TeamMinAggregateOutputType = {
    id: string | null
    gameId: string | null
    teamId: number | null
    teamMatchId: string | null
    win: boolean | null
  }

  export type TeamMaxAggregateOutputType = {
    id: string | null
    gameId: string | null
    teamId: number | null
    teamMatchId: string | null
    win: boolean | null
  }

  export type TeamCountAggregateOutputType = {
    id: number
    gameId: number
    teamId: number
    teamMatchId: number
    win: number
    _all: number
  }


  export type TeamAvgAggregateInputType = {
    teamId?: true
  }

  export type TeamSumAggregateInputType = {
    teamId?: true
  }

  export type TeamMinAggregateInputType = {
    id?: true
    gameId?: true
    teamId?: true
    teamMatchId?: true
    win?: true
  }

  export type TeamMaxAggregateInputType = {
    id?: true
    gameId?: true
    teamId?: true
    teamMatchId?: true
    win?: true
  }

  export type TeamCountAggregateInputType = {
    id?: true
    gameId?: true
    teamId?: true
    teamMatchId?: true
    win?: true
    _all?: true
  }

  export type TeamAggregateArgs = {
    /**
     * Filter which Team to aggregate.
     * 
    **/
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     * 
    **/
    orderBy?: Enumerable<TeamOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Teams
    **/
    _count?: true | TeamCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TeamAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TeamSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeamMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeamMaxAggregateInputType
  }

  export type GetTeamAggregateType<T extends TeamAggregateArgs> = {
        [P in keyof T & keyof AggregateTeam]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeam[P]>
      : GetScalarType<T[P], AggregateTeam[P]>
  }




  export type TeamGroupByArgs = {
    where?: TeamWhereInput
    orderBy?: Enumerable<TeamOrderByWithAggregationInput>
    by: Array<TeamScalarFieldEnum>
    having?: TeamScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeamCountAggregateInputType | true
    _avg?: TeamAvgAggregateInputType
    _sum?: TeamSumAggregateInputType
    _min?: TeamMinAggregateInputType
    _max?: TeamMaxAggregateInputType
  }


  export type TeamGroupByOutputType = {
    id: string
    gameId: string | null
    teamId: number | null
    teamMatchId: string
    win: boolean
    _count: TeamCountAggregateOutputType | null
    _avg: TeamAvgAggregateOutputType | null
    _sum: TeamSumAggregateOutputType | null
    _min: TeamMinAggregateOutputType | null
    _max: TeamMaxAggregateOutputType | null
  }

  type GetTeamGroupByPayload<T extends TeamGroupByArgs> = PrismaPromise<
    Array<
      PickArray<TeamGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeamGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeamGroupByOutputType[P]>
            : GetScalarType<T[P], TeamGroupByOutputType[P]>
        }
      >
    >


  export type TeamSelect = {
    id?: boolean
    pickBan?: boolean | PickBanFindManyArgs
    game?: boolean | GameArgs
    gameId?: boolean
    players?: boolean | PlayerFindManyArgs
    objectives?: boolean | ObjectiveFindManyArgs
    teamId?: boolean
    teamMatchId?: boolean
    win?: boolean
    from_Game_blueTeam?: boolean | GameFindManyArgs
    from_Game_redTeam?: boolean | GameFindManyArgs
    _count?: boolean | TeamCountOutputTypeArgs
  }

  export type TeamInclude = {
    pickBan?: boolean | PickBanFindManyArgs
    game?: boolean | GameArgs
    players?: boolean | PlayerFindManyArgs
    objectives?: boolean | ObjectiveFindManyArgs
    from_Game_blueTeam?: boolean | GameFindManyArgs
    from_Game_redTeam?: boolean | GameFindManyArgs
    _count?: boolean | TeamCountOutputTypeArgs
  }

  export type TeamGetPayload<
    S extends boolean | null | undefined | TeamArgs,
    U = keyof S
      > = S extends true
        ? Team
    : S extends undefined
    ? never
    : S extends TeamArgs | TeamFindManyArgs
    ?'include' extends U
    ? Team  & {
    [P in TrueKeys<S['include']>]:
        P extends 'pickBan' ? Array < PickBanGetPayload<S['include'][P]>>  :
        P extends 'game' ? GameGetPayload<S['include'][P]> | null :
        P extends 'players' ? Array < PlayerGetPayload<S['include'][P]>>  :
        P extends 'objectives' ? Array < ObjectiveGetPayload<S['include'][P]>>  :
        P extends 'from_Game_blueTeam' ? Array < GameGetPayload<S['include'][P]>>  :
        P extends 'from_Game_redTeam' ? Array < GameGetPayload<S['include'][P]>>  :
        P extends '_count' ? TeamCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'pickBan' ? Array < PickBanGetPayload<S['select'][P]>>  :
        P extends 'game' ? GameGetPayload<S['select'][P]> | null :
        P extends 'players' ? Array < PlayerGetPayload<S['select'][P]>>  :
        P extends 'objectives' ? Array < ObjectiveGetPayload<S['select'][P]>>  :
        P extends 'from_Game_blueTeam' ? Array < GameGetPayload<S['select'][P]>>  :
        P extends 'from_Game_redTeam' ? Array < GameGetPayload<S['select'][P]>>  :
        P extends '_count' ? TeamCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Team ? Team[P] : never
  } 
    : Team
  : Team


  type TeamCountArgs = Merge<
    Omit<TeamFindManyArgs, 'select' | 'include'> & {
      select?: TeamCountAggregateInputType | true
    }
  >

  export interface TeamDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Team that matches the filter.
     * @param {TeamFindUniqueArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TeamFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TeamFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Team'> extends True ? CheckSelect<T, Prisma__TeamClient<Team>, Prisma__TeamClient<TeamGetPayload<T>>> : CheckSelect<T, Prisma__TeamClient<Team | null >, Prisma__TeamClient<TeamGetPayload<T> | null >>

    /**
     * Find the first Team that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindFirstArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TeamFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TeamFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Team'> extends True ? CheckSelect<T, Prisma__TeamClient<Team>, Prisma__TeamClient<TeamGetPayload<T>>> : CheckSelect<T, Prisma__TeamClient<Team | null >, Prisma__TeamClient<TeamGetPayload<T> | null >>

    /**
     * Find zero or more Teams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Teams
     * const teams = await prisma.team.findMany()
     * 
     * // Get first 10 Teams
     * const teams = await prisma.team.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teamWithIdOnly = await prisma.team.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TeamFindManyArgs>(
      args?: SelectSubset<T, TeamFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Team>>, PrismaPromise<Array<TeamGetPayload<T>>>>

    /**
     * Create a Team.
     * @param {TeamCreateArgs} args - Arguments to create a Team.
     * @example
     * // Create one Team
     * const Team = await prisma.team.create({
     *   data: {
     *     // ... data to create a Team
     *   }
     * })
     * 
    **/
    create<T extends TeamCreateArgs>(
      args: SelectSubset<T, TeamCreateArgs>
    ): CheckSelect<T, Prisma__TeamClient<Team>, Prisma__TeamClient<TeamGetPayload<T>>>

    /**
     * Create many Teams.
     *     @param {TeamCreateManyArgs} args - Arguments to create many Teams.
     *     @example
     *     // Create many Teams
     *     const team = await prisma.team.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TeamCreateManyArgs>(
      args?: SelectSubset<T, TeamCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Team.
     * @param {TeamDeleteArgs} args - Arguments to delete one Team.
     * @example
     * // Delete one Team
     * const Team = await prisma.team.delete({
     *   where: {
     *     // ... filter to delete one Team
     *   }
     * })
     * 
    **/
    delete<T extends TeamDeleteArgs>(
      args: SelectSubset<T, TeamDeleteArgs>
    ): CheckSelect<T, Prisma__TeamClient<Team>, Prisma__TeamClient<TeamGetPayload<T>>>

    /**
     * Update one Team.
     * @param {TeamUpdateArgs} args - Arguments to update one Team.
     * @example
     * // Update one Team
     * const team = await prisma.team.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TeamUpdateArgs>(
      args: SelectSubset<T, TeamUpdateArgs>
    ): CheckSelect<T, Prisma__TeamClient<Team>, Prisma__TeamClient<TeamGetPayload<T>>>

    /**
     * Delete zero or more Teams.
     * @param {TeamDeleteManyArgs} args - Arguments to filter Teams to delete.
     * @example
     * // Delete a few Teams
     * const { count } = await prisma.team.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TeamDeleteManyArgs>(
      args?: SelectSubset<T, TeamDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Teams
     * const team = await prisma.team.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TeamUpdateManyArgs>(
      args: SelectSubset<T, TeamUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Team.
     * @param {TeamUpsertArgs} args - Arguments to update or create a Team.
     * @example
     * // Update or create a Team
     * const team = await prisma.team.upsert({
     *   create: {
     *     // ... data to create a Team
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Team we want to update
     *   }
     * })
    **/
    upsert<T extends TeamUpsertArgs>(
      args: SelectSubset<T, TeamUpsertArgs>
    ): CheckSelect<T, Prisma__TeamClient<Team>, Prisma__TeamClient<TeamGetPayload<T>>>

    /**
     * Count the number of Teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamCountArgs} args - Arguments to filter Teams to count.
     * @example
     * // Count the number of Teams
     * const count = await prisma.team.count({
     *   where: {
     *     // ... the filter for the Teams we want to count
     *   }
     * })
    **/
    count<T extends TeamCountArgs>(
      args?: Subset<T, TeamCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeamCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Team.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeamAggregateArgs>(args: Subset<T, TeamAggregateArgs>): PrismaPromise<GetTeamAggregateType<T>>

    /**
     * Group by Team.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeamGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeamGroupByArgs['orderBy'] }
        : { orderBy?: TeamGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeamGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeamGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Team.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TeamClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    pickBan<T extends PickBanFindManyArgs = {}>(args?: Subset<T, PickBanFindManyArgs>): CheckSelect<T, PrismaPromise<Array<PickBan>>, PrismaPromise<Array<PickBanGetPayload<T>>>>;

    game<T extends GameArgs = {}>(args?: Subset<T, GameArgs>): CheckSelect<T, Prisma__GameClient<Game | null >, Prisma__GameClient<GameGetPayload<T> | null >>;

    players<T extends PlayerFindManyArgs = {}>(args?: Subset<T, PlayerFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Player>>, PrismaPromise<Array<PlayerGetPayload<T>>>>;

    objectives<T extends ObjectiveFindManyArgs = {}>(args?: Subset<T, ObjectiveFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Objective>>, PrismaPromise<Array<ObjectiveGetPayload<T>>>>;

    from_Game_blueTeam<T extends GameFindManyArgs = {}>(args?: Subset<T, GameFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Game>>, PrismaPromise<Array<GameGetPayload<T>>>>;

    from_Game_redTeam<T extends GameFindManyArgs = {}>(args?: Subset<T, GameFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Game>>, PrismaPromise<Array<GameGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Team findUnique
   */
  export type TeamFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Team
     * 
    **/
    select?: TeamSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TeamInclude | null
    /**
     * Throw an Error if a Team can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Team to fetch.
     * 
    **/
    where: TeamWhereUniqueInput
  }


  /**
   * Team findFirst
   */
  export type TeamFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Team
     * 
    **/
    select?: TeamSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TeamInclude | null
    /**
     * Throw an Error if a Team can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Team to fetch.
     * 
    **/
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     * 
    **/
    orderBy?: Enumerable<TeamOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teams.
     * 
    **/
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teams.
     * 
    **/
    distinct?: Enumerable<TeamScalarFieldEnum>
  }


  /**
   * Team findMany
   */
  export type TeamFindManyArgs = {
    /**
     * Select specific fields to fetch from the Team
     * 
    **/
    select?: TeamSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TeamInclude | null
    /**
     * Filter, which Teams to fetch.
     * 
    **/
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     * 
    **/
    orderBy?: Enumerable<TeamOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Teams.
     * 
    **/
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     * 
    **/
    skip?: number
    distinct?: Enumerable<TeamScalarFieldEnum>
  }


  /**
   * Team create
   */
  export type TeamCreateArgs = {
    /**
     * Select specific fields to fetch from the Team
     * 
    **/
    select?: TeamSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TeamInclude | null
    /**
     * The data needed to create a Team.
     * 
    **/
    data: XOR<TeamCreateInput, TeamUncheckedCreateInput>
  }


  /**
   * Team createMany
   */
  export type TeamCreateManyArgs = {
    /**
     * The data used to create many Teams.
     * 
    **/
    data: Enumerable<TeamCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Team update
   */
  export type TeamUpdateArgs = {
    /**
     * Select specific fields to fetch from the Team
     * 
    **/
    select?: TeamSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TeamInclude | null
    /**
     * The data needed to update a Team.
     * 
    **/
    data: XOR<TeamUpdateInput, TeamUncheckedUpdateInput>
    /**
     * Choose, which Team to update.
     * 
    **/
    where: TeamWhereUniqueInput
  }


  /**
   * Team updateMany
   */
  export type TeamUpdateManyArgs = {
    /**
     * The data used to update Teams.
     * 
    **/
    data: XOR<TeamUpdateManyMutationInput, TeamUncheckedUpdateManyInput>
    /**
     * Filter which Teams to update
     * 
    **/
    where?: TeamWhereInput
  }


  /**
   * Team upsert
   */
  export type TeamUpsertArgs = {
    /**
     * Select specific fields to fetch from the Team
     * 
    **/
    select?: TeamSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TeamInclude | null
    /**
     * The filter to search for the Team to update in case it exists.
     * 
    **/
    where: TeamWhereUniqueInput
    /**
     * In case the Team found by the `where` argument doesn't exist, create a new Team with this data.
     * 
    **/
    create: XOR<TeamCreateInput, TeamUncheckedCreateInput>
    /**
     * In case the Team was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<TeamUpdateInput, TeamUncheckedUpdateInput>
  }


  /**
   * Team delete
   */
  export type TeamDeleteArgs = {
    /**
     * Select specific fields to fetch from the Team
     * 
    **/
    select?: TeamSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TeamInclude | null
    /**
     * Filter which Team to delete.
     * 
    **/
    where: TeamWhereUniqueInput
  }


  /**
   * Team deleteMany
   */
  export type TeamDeleteManyArgs = {
    /**
     * Filter which Teams to delete
     * 
    **/
    where?: TeamWhereInput
  }


  /**
   * Team without action
   */
  export type TeamArgs = {
    /**
     * Select specific fields to fetch from the Team
     * 
    **/
    select?: TeamSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TeamInclude | null
  }



  /**
   * Model TeamBuildingKill
   */


  export type AggregateTeamBuildingKill = {
    _count: TeamBuildingKillCountAggregateOutputType | null
    _min: TeamBuildingKillMinAggregateOutputType | null
    _max: TeamBuildingKillMaxAggregateOutputType | null
  }

  export type TeamBuildingKillMinAggregateOutputType = {
    id: string | null
    type: string | null
    lane: string | null
    side: string | null
    towerLocation: string | null
  }

  export type TeamBuildingKillMaxAggregateOutputType = {
    id: string | null
    type: string | null
    lane: string | null
    side: string | null
    towerLocation: string | null
  }

  export type TeamBuildingKillCountAggregateOutputType = {
    id: number
    type: number
    lane: number
    side: number
    towerLocation: number
    _all: number
  }


  export type TeamBuildingKillMinAggregateInputType = {
    id?: true
    type?: true
    lane?: true
    side?: true
    towerLocation?: true
  }

  export type TeamBuildingKillMaxAggregateInputType = {
    id?: true
    type?: true
    lane?: true
    side?: true
    towerLocation?: true
  }

  export type TeamBuildingKillCountAggregateInputType = {
    id?: true
    type?: true
    lane?: true
    side?: true
    towerLocation?: true
    _all?: true
  }

  export type TeamBuildingKillAggregateArgs = {
    /**
     * Filter which TeamBuildingKill to aggregate.
     * 
    **/
    where?: TeamBuildingKillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamBuildingKills to fetch.
     * 
    **/
    orderBy?: Enumerable<TeamBuildingKillOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: TeamBuildingKillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamBuildingKills from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamBuildingKills.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TeamBuildingKills
    **/
    _count?: true | TeamBuildingKillCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeamBuildingKillMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeamBuildingKillMaxAggregateInputType
  }

  export type GetTeamBuildingKillAggregateType<T extends TeamBuildingKillAggregateArgs> = {
        [P in keyof T & keyof AggregateTeamBuildingKill]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeamBuildingKill[P]>
      : GetScalarType<T[P], AggregateTeamBuildingKill[P]>
  }




  export type TeamBuildingKillGroupByArgs = {
    where?: TeamBuildingKillWhereInput
    orderBy?: Enumerable<TeamBuildingKillOrderByWithAggregationInput>
    by: Array<TeamBuildingKillScalarFieldEnum>
    having?: TeamBuildingKillScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeamBuildingKillCountAggregateInputType | true
    _min?: TeamBuildingKillMinAggregateInputType
    _max?: TeamBuildingKillMaxAggregateInputType
  }


  export type TeamBuildingKillGroupByOutputType = {
    id: string
    type: string
    lane: string
    side: string
    towerLocation: string
    _count: TeamBuildingKillCountAggregateOutputType | null
    _min: TeamBuildingKillMinAggregateOutputType | null
    _max: TeamBuildingKillMaxAggregateOutputType | null
  }

  type GetTeamBuildingKillGroupByPayload<T extends TeamBuildingKillGroupByArgs> = PrismaPromise<
    Array<
      PickArray<TeamBuildingKillGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeamBuildingKillGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeamBuildingKillGroupByOutputType[P]>
            : GetScalarType<T[P], TeamBuildingKillGroupByOutputType[P]>
        }
      >
    >


  export type TeamBuildingKillSelect = {
    id?: boolean
    killer?: boolean | PlayerFindManyArgs
    type?: boolean
    lane?: boolean
    side?: boolean
    towerLocation?: boolean
    _count?: boolean | TeamBuildingKillCountOutputTypeArgs
  }

  export type TeamBuildingKillInclude = {
    killer?: boolean | PlayerFindManyArgs
    _count?: boolean | TeamBuildingKillCountOutputTypeArgs
  }

  export type TeamBuildingKillGetPayload<
    S extends boolean | null | undefined | TeamBuildingKillArgs,
    U = keyof S
      > = S extends true
        ? TeamBuildingKill
    : S extends undefined
    ? never
    : S extends TeamBuildingKillArgs | TeamBuildingKillFindManyArgs
    ?'include' extends U
    ? TeamBuildingKill  & {
    [P in TrueKeys<S['include']>]:
        P extends 'killer' ? Array < PlayerGetPayload<S['include'][P]>>  :
        P extends '_count' ? TeamBuildingKillCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'killer' ? Array < PlayerGetPayload<S['select'][P]>>  :
        P extends '_count' ? TeamBuildingKillCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof TeamBuildingKill ? TeamBuildingKill[P] : never
  } 
    : TeamBuildingKill
  : TeamBuildingKill


  type TeamBuildingKillCountArgs = Merge<
    Omit<TeamBuildingKillFindManyArgs, 'select' | 'include'> & {
      select?: TeamBuildingKillCountAggregateInputType | true
    }
  >

  export interface TeamBuildingKillDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one TeamBuildingKill that matches the filter.
     * @param {TeamBuildingKillFindUniqueArgs} args - Arguments to find a TeamBuildingKill
     * @example
     * // Get one TeamBuildingKill
     * const teamBuildingKill = await prisma.teamBuildingKill.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TeamBuildingKillFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TeamBuildingKillFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TeamBuildingKill'> extends True ? CheckSelect<T, Prisma__TeamBuildingKillClient<TeamBuildingKill>, Prisma__TeamBuildingKillClient<TeamBuildingKillGetPayload<T>>> : CheckSelect<T, Prisma__TeamBuildingKillClient<TeamBuildingKill | null >, Prisma__TeamBuildingKillClient<TeamBuildingKillGetPayload<T> | null >>

    /**
     * Find the first TeamBuildingKill that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamBuildingKillFindFirstArgs} args - Arguments to find a TeamBuildingKill
     * @example
     * // Get one TeamBuildingKill
     * const teamBuildingKill = await prisma.teamBuildingKill.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TeamBuildingKillFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TeamBuildingKillFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TeamBuildingKill'> extends True ? CheckSelect<T, Prisma__TeamBuildingKillClient<TeamBuildingKill>, Prisma__TeamBuildingKillClient<TeamBuildingKillGetPayload<T>>> : CheckSelect<T, Prisma__TeamBuildingKillClient<TeamBuildingKill | null >, Prisma__TeamBuildingKillClient<TeamBuildingKillGetPayload<T> | null >>

    /**
     * Find zero or more TeamBuildingKills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamBuildingKillFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TeamBuildingKills
     * const teamBuildingKills = await prisma.teamBuildingKill.findMany()
     * 
     * // Get first 10 TeamBuildingKills
     * const teamBuildingKills = await prisma.teamBuildingKill.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teamBuildingKillWithIdOnly = await prisma.teamBuildingKill.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TeamBuildingKillFindManyArgs>(
      args?: SelectSubset<T, TeamBuildingKillFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<TeamBuildingKill>>, PrismaPromise<Array<TeamBuildingKillGetPayload<T>>>>

    /**
     * Create a TeamBuildingKill.
     * @param {TeamBuildingKillCreateArgs} args - Arguments to create a TeamBuildingKill.
     * @example
     * // Create one TeamBuildingKill
     * const TeamBuildingKill = await prisma.teamBuildingKill.create({
     *   data: {
     *     // ... data to create a TeamBuildingKill
     *   }
     * })
     * 
    **/
    create<T extends TeamBuildingKillCreateArgs>(
      args: SelectSubset<T, TeamBuildingKillCreateArgs>
    ): CheckSelect<T, Prisma__TeamBuildingKillClient<TeamBuildingKill>, Prisma__TeamBuildingKillClient<TeamBuildingKillGetPayload<T>>>

    /**
     * Create many TeamBuildingKills.
     *     @param {TeamBuildingKillCreateManyArgs} args - Arguments to create many TeamBuildingKills.
     *     @example
     *     // Create many TeamBuildingKills
     *     const teamBuildingKill = await prisma.teamBuildingKill.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TeamBuildingKillCreateManyArgs>(
      args?: SelectSubset<T, TeamBuildingKillCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a TeamBuildingKill.
     * @param {TeamBuildingKillDeleteArgs} args - Arguments to delete one TeamBuildingKill.
     * @example
     * // Delete one TeamBuildingKill
     * const TeamBuildingKill = await prisma.teamBuildingKill.delete({
     *   where: {
     *     // ... filter to delete one TeamBuildingKill
     *   }
     * })
     * 
    **/
    delete<T extends TeamBuildingKillDeleteArgs>(
      args: SelectSubset<T, TeamBuildingKillDeleteArgs>
    ): CheckSelect<T, Prisma__TeamBuildingKillClient<TeamBuildingKill>, Prisma__TeamBuildingKillClient<TeamBuildingKillGetPayload<T>>>

    /**
     * Update one TeamBuildingKill.
     * @param {TeamBuildingKillUpdateArgs} args - Arguments to update one TeamBuildingKill.
     * @example
     * // Update one TeamBuildingKill
     * const teamBuildingKill = await prisma.teamBuildingKill.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TeamBuildingKillUpdateArgs>(
      args: SelectSubset<T, TeamBuildingKillUpdateArgs>
    ): CheckSelect<T, Prisma__TeamBuildingKillClient<TeamBuildingKill>, Prisma__TeamBuildingKillClient<TeamBuildingKillGetPayload<T>>>

    /**
     * Delete zero or more TeamBuildingKills.
     * @param {TeamBuildingKillDeleteManyArgs} args - Arguments to filter TeamBuildingKills to delete.
     * @example
     * // Delete a few TeamBuildingKills
     * const { count } = await prisma.teamBuildingKill.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TeamBuildingKillDeleteManyArgs>(
      args?: SelectSubset<T, TeamBuildingKillDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeamBuildingKills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamBuildingKillUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TeamBuildingKills
     * const teamBuildingKill = await prisma.teamBuildingKill.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TeamBuildingKillUpdateManyArgs>(
      args: SelectSubset<T, TeamBuildingKillUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one TeamBuildingKill.
     * @param {TeamBuildingKillUpsertArgs} args - Arguments to update or create a TeamBuildingKill.
     * @example
     * // Update or create a TeamBuildingKill
     * const teamBuildingKill = await prisma.teamBuildingKill.upsert({
     *   create: {
     *     // ... data to create a TeamBuildingKill
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TeamBuildingKill we want to update
     *   }
     * })
    **/
    upsert<T extends TeamBuildingKillUpsertArgs>(
      args: SelectSubset<T, TeamBuildingKillUpsertArgs>
    ): CheckSelect<T, Prisma__TeamBuildingKillClient<TeamBuildingKill>, Prisma__TeamBuildingKillClient<TeamBuildingKillGetPayload<T>>>

    /**
     * Count the number of TeamBuildingKills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamBuildingKillCountArgs} args - Arguments to filter TeamBuildingKills to count.
     * @example
     * // Count the number of TeamBuildingKills
     * const count = await prisma.teamBuildingKill.count({
     *   where: {
     *     // ... the filter for the TeamBuildingKills we want to count
     *   }
     * })
    **/
    count<T extends TeamBuildingKillCountArgs>(
      args?: Subset<T, TeamBuildingKillCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeamBuildingKillCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TeamBuildingKill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamBuildingKillAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeamBuildingKillAggregateArgs>(args: Subset<T, TeamBuildingKillAggregateArgs>): PrismaPromise<GetTeamBuildingKillAggregateType<T>>

    /**
     * Group by TeamBuildingKill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamBuildingKillGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeamBuildingKillGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeamBuildingKillGroupByArgs['orderBy'] }
        : { orderBy?: TeamBuildingKillGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeamBuildingKillGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeamBuildingKillGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for TeamBuildingKill.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TeamBuildingKillClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    killer<T extends PlayerFindManyArgs = {}>(args?: Subset<T, PlayerFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Player>>, PrismaPromise<Array<PlayerGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * TeamBuildingKill findUnique
   */
  export type TeamBuildingKillFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the TeamBuildingKill
     * 
    **/
    select?: TeamBuildingKillSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TeamBuildingKillInclude | null
    /**
     * Throw an Error if a TeamBuildingKill can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which TeamBuildingKill to fetch.
     * 
    **/
    where: TeamBuildingKillWhereUniqueInput
  }


  /**
   * TeamBuildingKill findFirst
   */
  export type TeamBuildingKillFindFirstArgs = {
    /**
     * Select specific fields to fetch from the TeamBuildingKill
     * 
    **/
    select?: TeamBuildingKillSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TeamBuildingKillInclude | null
    /**
     * Throw an Error if a TeamBuildingKill can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which TeamBuildingKill to fetch.
     * 
    **/
    where?: TeamBuildingKillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamBuildingKills to fetch.
     * 
    **/
    orderBy?: Enumerable<TeamBuildingKillOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeamBuildingKills.
     * 
    **/
    cursor?: TeamBuildingKillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamBuildingKills from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamBuildingKills.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeamBuildingKills.
     * 
    **/
    distinct?: Enumerable<TeamBuildingKillScalarFieldEnum>
  }


  /**
   * TeamBuildingKill findMany
   */
  export type TeamBuildingKillFindManyArgs = {
    /**
     * Select specific fields to fetch from the TeamBuildingKill
     * 
    **/
    select?: TeamBuildingKillSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TeamBuildingKillInclude | null
    /**
     * Filter, which TeamBuildingKills to fetch.
     * 
    **/
    where?: TeamBuildingKillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamBuildingKills to fetch.
     * 
    **/
    orderBy?: Enumerable<TeamBuildingKillOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TeamBuildingKills.
     * 
    **/
    cursor?: TeamBuildingKillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamBuildingKills from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamBuildingKills.
     * 
    **/
    skip?: number
    distinct?: Enumerable<TeamBuildingKillScalarFieldEnum>
  }


  /**
   * TeamBuildingKill create
   */
  export type TeamBuildingKillCreateArgs = {
    /**
     * Select specific fields to fetch from the TeamBuildingKill
     * 
    **/
    select?: TeamBuildingKillSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TeamBuildingKillInclude | null
    /**
     * The data needed to create a TeamBuildingKill.
     * 
    **/
    data: XOR<TeamBuildingKillCreateInput, TeamBuildingKillUncheckedCreateInput>
  }


  /**
   * TeamBuildingKill createMany
   */
  export type TeamBuildingKillCreateManyArgs = {
    /**
     * The data used to create many TeamBuildingKills.
     * 
    **/
    data: Enumerable<TeamBuildingKillCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * TeamBuildingKill update
   */
  export type TeamBuildingKillUpdateArgs = {
    /**
     * Select specific fields to fetch from the TeamBuildingKill
     * 
    **/
    select?: TeamBuildingKillSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TeamBuildingKillInclude | null
    /**
     * The data needed to update a TeamBuildingKill.
     * 
    **/
    data: XOR<TeamBuildingKillUpdateInput, TeamBuildingKillUncheckedUpdateInput>
    /**
     * Choose, which TeamBuildingKill to update.
     * 
    **/
    where: TeamBuildingKillWhereUniqueInput
  }


  /**
   * TeamBuildingKill updateMany
   */
  export type TeamBuildingKillUpdateManyArgs = {
    /**
     * The data used to update TeamBuildingKills.
     * 
    **/
    data: XOR<TeamBuildingKillUpdateManyMutationInput, TeamBuildingKillUncheckedUpdateManyInput>
    /**
     * Filter which TeamBuildingKills to update
     * 
    **/
    where?: TeamBuildingKillWhereInput
  }


  /**
   * TeamBuildingKill upsert
   */
  export type TeamBuildingKillUpsertArgs = {
    /**
     * Select specific fields to fetch from the TeamBuildingKill
     * 
    **/
    select?: TeamBuildingKillSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TeamBuildingKillInclude | null
    /**
     * The filter to search for the TeamBuildingKill to update in case it exists.
     * 
    **/
    where: TeamBuildingKillWhereUniqueInput
    /**
     * In case the TeamBuildingKill found by the `where` argument doesn't exist, create a new TeamBuildingKill with this data.
     * 
    **/
    create: XOR<TeamBuildingKillCreateInput, TeamBuildingKillUncheckedCreateInput>
    /**
     * In case the TeamBuildingKill was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<TeamBuildingKillUpdateInput, TeamBuildingKillUncheckedUpdateInput>
  }


  /**
   * TeamBuildingKill delete
   */
  export type TeamBuildingKillDeleteArgs = {
    /**
     * Select specific fields to fetch from the TeamBuildingKill
     * 
    **/
    select?: TeamBuildingKillSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TeamBuildingKillInclude | null
    /**
     * Filter which TeamBuildingKill to delete.
     * 
    **/
    where: TeamBuildingKillWhereUniqueInput
  }


  /**
   * TeamBuildingKill deleteMany
   */
  export type TeamBuildingKillDeleteManyArgs = {
    /**
     * Filter which TeamBuildingKills to delete
     * 
    **/
    where?: TeamBuildingKillWhereInput
  }


  /**
   * TeamBuildingKill without action
   */
  export type TeamBuildingKillArgs = {
    /**
     * Select specific fields to fetch from the TeamBuildingKill
     * 
    **/
    select?: TeamBuildingKillSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TeamBuildingKillInclude | null
  }



  /**
   * Model TeamMonsterKill
   */


  export type AggregateTeamMonsterKill = {
    _count: TeamMonsterKillCountAggregateOutputType | null
    _min: TeamMonsterKillMinAggregateOutputType | null
    _max: TeamMonsterKillMaxAggregateOutputType | null
  }

  export type TeamMonsterKillMinAggregateOutputType = {
    id: string | null
    type: string | null
    subType: string | null
  }

  export type TeamMonsterKillMaxAggregateOutputType = {
    id: string | null
    type: string | null
    subType: string | null
  }

  export type TeamMonsterKillCountAggregateOutputType = {
    id: number
    type: number
    subType: number
    _all: number
  }


  export type TeamMonsterKillMinAggregateInputType = {
    id?: true
    type?: true
    subType?: true
  }

  export type TeamMonsterKillMaxAggregateInputType = {
    id?: true
    type?: true
    subType?: true
  }

  export type TeamMonsterKillCountAggregateInputType = {
    id?: true
    type?: true
    subType?: true
    _all?: true
  }

  export type TeamMonsterKillAggregateArgs = {
    /**
     * Filter which TeamMonsterKill to aggregate.
     * 
    **/
    where?: TeamMonsterKillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamMonsterKills to fetch.
     * 
    **/
    orderBy?: Enumerable<TeamMonsterKillOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: TeamMonsterKillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamMonsterKills from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamMonsterKills.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TeamMonsterKills
    **/
    _count?: true | TeamMonsterKillCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeamMonsterKillMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeamMonsterKillMaxAggregateInputType
  }

  export type GetTeamMonsterKillAggregateType<T extends TeamMonsterKillAggregateArgs> = {
        [P in keyof T & keyof AggregateTeamMonsterKill]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeamMonsterKill[P]>
      : GetScalarType<T[P], AggregateTeamMonsterKill[P]>
  }




  export type TeamMonsterKillGroupByArgs = {
    where?: TeamMonsterKillWhereInput
    orderBy?: Enumerable<TeamMonsterKillOrderByWithAggregationInput>
    by: Array<TeamMonsterKillScalarFieldEnum>
    having?: TeamMonsterKillScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeamMonsterKillCountAggregateInputType | true
    _min?: TeamMonsterKillMinAggregateInputType
    _max?: TeamMonsterKillMaxAggregateInputType
  }


  export type TeamMonsterKillGroupByOutputType = {
    id: string
    type: string
    subType: string
    _count: TeamMonsterKillCountAggregateOutputType | null
    _min: TeamMonsterKillMinAggregateOutputType | null
    _max: TeamMonsterKillMaxAggregateOutputType | null
  }

  type GetTeamMonsterKillGroupByPayload<T extends TeamMonsterKillGroupByArgs> = PrismaPromise<
    Array<
      PickArray<TeamMonsterKillGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeamMonsterKillGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeamMonsterKillGroupByOutputType[P]>
            : GetScalarType<T[P], TeamMonsterKillGroupByOutputType[P]>
        }
      >
    >


  export type TeamMonsterKillSelect = {
    id?: boolean
    killer?: boolean | PlayerFindManyArgs
    type?: boolean
    subType?: boolean
    _count?: boolean | TeamMonsterKillCountOutputTypeArgs
  }

  export type TeamMonsterKillInclude = {
    killer?: boolean | PlayerFindManyArgs
    _count?: boolean | TeamMonsterKillCountOutputTypeArgs
  }

  export type TeamMonsterKillGetPayload<
    S extends boolean | null | undefined | TeamMonsterKillArgs,
    U = keyof S
      > = S extends true
        ? TeamMonsterKill
    : S extends undefined
    ? never
    : S extends TeamMonsterKillArgs | TeamMonsterKillFindManyArgs
    ?'include' extends U
    ? TeamMonsterKill  & {
    [P in TrueKeys<S['include']>]:
        P extends 'killer' ? Array < PlayerGetPayload<S['include'][P]>>  :
        P extends '_count' ? TeamMonsterKillCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'killer' ? Array < PlayerGetPayload<S['select'][P]>>  :
        P extends '_count' ? TeamMonsterKillCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof TeamMonsterKill ? TeamMonsterKill[P] : never
  } 
    : TeamMonsterKill
  : TeamMonsterKill


  type TeamMonsterKillCountArgs = Merge<
    Omit<TeamMonsterKillFindManyArgs, 'select' | 'include'> & {
      select?: TeamMonsterKillCountAggregateInputType | true
    }
  >

  export interface TeamMonsterKillDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one TeamMonsterKill that matches the filter.
     * @param {TeamMonsterKillFindUniqueArgs} args - Arguments to find a TeamMonsterKill
     * @example
     * // Get one TeamMonsterKill
     * const teamMonsterKill = await prisma.teamMonsterKill.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TeamMonsterKillFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TeamMonsterKillFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TeamMonsterKill'> extends True ? CheckSelect<T, Prisma__TeamMonsterKillClient<TeamMonsterKill>, Prisma__TeamMonsterKillClient<TeamMonsterKillGetPayload<T>>> : CheckSelect<T, Prisma__TeamMonsterKillClient<TeamMonsterKill | null >, Prisma__TeamMonsterKillClient<TeamMonsterKillGetPayload<T> | null >>

    /**
     * Find the first TeamMonsterKill that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMonsterKillFindFirstArgs} args - Arguments to find a TeamMonsterKill
     * @example
     * // Get one TeamMonsterKill
     * const teamMonsterKill = await prisma.teamMonsterKill.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TeamMonsterKillFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TeamMonsterKillFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TeamMonsterKill'> extends True ? CheckSelect<T, Prisma__TeamMonsterKillClient<TeamMonsterKill>, Prisma__TeamMonsterKillClient<TeamMonsterKillGetPayload<T>>> : CheckSelect<T, Prisma__TeamMonsterKillClient<TeamMonsterKill | null >, Prisma__TeamMonsterKillClient<TeamMonsterKillGetPayload<T> | null >>

    /**
     * Find zero or more TeamMonsterKills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMonsterKillFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TeamMonsterKills
     * const teamMonsterKills = await prisma.teamMonsterKill.findMany()
     * 
     * // Get first 10 TeamMonsterKills
     * const teamMonsterKills = await prisma.teamMonsterKill.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teamMonsterKillWithIdOnly = await prisma.teamMonsterKill.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TeamMonsterKillFindManyArgs>(
      args?: SelectSubset<T, TeamMonsterKillFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<TeamMonsterKill>>, PrismaPromise<Array<TeamMonsterKillGetPayload<T>>>>

    /**
     * Create a TeamMonsterKill.
     * @param {TeamMonsterKillCreateArgs} args - Arguments to create a TeamMonsterKill.
     * @example
     * // Create one TeamMonsterKill
     * const TeamMonsterKill = await prisma.teamMonsterKill.create({
     *   data: {
     *     // ... data to create a TeamMonsterKill
     *   }
     * })
     * 
    **/
    create<T extends TeamMonsterKillCreateArgs>(
      args: SelectSubset<T, TeamMonsterKillCreateArgs>
    ): CheckSelect<T, Prisma__TeamMonsterKillClient<TeamMonsterKill>, Prisma__TeamMonsterKillClient<TeamMonsterKillGetPayload<T>>>

    /**
     * Create many TeamMonsterKills.
     *     @param {TeamMonsterKillCreateManyArgs} args - Arguments to create many TeamMonsterKills.
     *     @example
     *     // Create many TeamMonsterKills
     *     const teamMonsterKill = await prisma.teamMonsterKill.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TeamMonsterKillCreateManyArgs>(
      args?: SelectSubset<T, TeamMonsterKillCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a TeamMonsterKill.
     * @param {TeamMonsterKillDeleteArgs} args - Arguments to delete one TeamMonsterKill.
     * @example
     * // Delete one TeamMonsterKill
     * const TeamMonsterKill = await prisma.teamMonsterKill.delete({
     *   where: {
     *     // ... filter to delete one TeamMonsterKill
     *   }
     * })
     * 
    **/
    delete<T extends TeamMonsterKillDeleteArgs>(
      args: SelectSubset<T, TeamMonsterKillDeleteArgs>
    ): CheckSelect<T, Prisma__TeamMonsterKillClient<TeamMonsterKill>, Prisma__TeamMonsterKillClient<TeamMonsterKillGetPayload<T>>>

    /**
     * Update one TeamMonsterKill.
     * @param {TeamMonsterKillUpdateArgs} args - Arguments to update one TeamMonsterKill.
     * @example
     * // Update one TeamMonsterKill
     * const teamMonsterKill = await prisma.teamMonsterKill.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TeamMonsterKillUpdateArgs>(
      args: SelectSubset<T, TeamMonsterKillUpdateArgs>
    ): CheckSelect<T, Prisma__TeamMonsterKillClient<TeamMonsterKill>, Prisma__TeamMonsterKillClient<TeamMonsterKillGetPayload<T>>>

    /**
     * Delete zero or more TeamMonsterKills.
     * @param {TeamMonsterKillDeleteManyArgs} args - Arguments to filter TeamMonsterKills to delete.
     * @example
     * // Delete a few TeamMonsterKills
     * const { count } = await prisma.teamMonsterKill.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TeamMonsterKillDeleteManyArgs>(
      args?: SelectSubset<T, TeamMonsterKillDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeamMonsterKills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMonsterKillUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TeamMonsterKills
     * const teamMonsterKill = await prisma.teamMonsterKill.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TeamMonsterKillUpdateManyArgs>(
      args: SelectSubset<T, TeamMonsterKillUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one TeamMonsterKill.
     * @param {TeamMonsterKillUpsertArgs} args - Arguments to update or create a TeamMonsterKill.
     * @example
     * // Update or create a TeamMonsterKill
     * const teamMonsterKill = await prisma.teamMonsterKill.upsert({
     *   create: {
     *     // ... data to create a TeamMonsterKill
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TeamMonsterKill we want to update
     *   }
     * })
    **/
    upsert<T extends TeamMonsterKillUpsertArgs>(
      args: SelectSubset<T, TeamMonsterKillUpsertArgs>
    ): CheckSelect<T, Prisma__TeamMonsterKillClient<TeamMonsterKill>, Prisma__TeamMonsterKillClient<TeamMonsterKillGetPayload<T>>>

    /**
     * Count the number of TeamMonsterKills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMonsterKillCountArgs} args - Arguments to filter TeamMonsterKills to count.
     * @example
     * // Count the number of TeamMonsterKills
     * const count = await prisma.teamMonsterKill.count({
     *   where: {
     *     // ... the filter for the TeamMonsterKills we want to count
     *   }
     * })
    **/
    count<T extends TeamMonsterKillCountArgs>(
      args?: Subset<T, TeamMonsterKillCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeamMonsterKillCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TeamMonsterKill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMonsterKillAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeamMonsterKillAggregateArgs>(args: Subset<T, TeamMonsterKillAggregateArgs>): PrismaPromise<GetTeamMonsterKillAggregateType<T>>

    /**
     * Group by TeamMonsterKill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMonsterKillGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeamMonsterKillGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeamMonsterKillGroupByArgs['orderBy'] }
        : { orderBy?: TeamMonsterKillGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeamMonsterKillGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeamMonsterKillGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for TeamMonsterKill.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TeamMonsterKillClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    killer<T extends PlayerFindManyArgs = {}>(args?: Subset<T, PlayerFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Player>>, PrismaPromise<Array<PlayerGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * TeamMonsterKill findUnique
   */
  export type TeamMonsterKillFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the TeamMonsterKill
     * 
    **/
    select?: TeamMonsterKillSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TeamMonsterKillInclude | null
    /**
     * Throw an Error if a TeamMonsterKill can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which TeamMonsterKill to fetch.
     * 
    **/
    where: TeamMonsterKillWhereUniqueInput
  }


  /**
   * TeamMonsterKill findFirst
   */
  export type TeamMonsterKillFindFirstArgs = {
    /**
     * Select specific fields to fetch from the TeamMonsterKill
     * 
    **/
    select?: TeamMonsterKillSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TeamMonsterKillInclude | null
    /**
     * Throw an Error if a TeamMonsterKill can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which TeamMonsterKill to fetch.
     * 
    **/
    where?: TeamMonsterKillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamMonsterKills to fetch.
     * 
    **/
    orderBy?: Enumerable<TeamMonsterKillOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeamMonsterKills.
     * 
    **/
    cursor?: TeamMonsterKillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamMonsterKills from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamMonsterKills.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeamMonsterKills.
     * 
    **/
    distinct?: Enumerable<TeamMonsterKillScalarFieldEnum>
  }


  /**
   * TeamMonsterKill findMany
   */
  export type TeamMonsterKillFindManyArgs = {
    /**
     * Select specific fields to fetch from the TeamMonsterKill
     * 
    **/
    select?: TeamMonsterKillSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TeamMonsterKillInclude | null
    /**
     * Filter, which TeamMonsterKills to fetch.
     * 
    **/
    where?: TeamMonsterKillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamMonsterKills to fetch.
     * 
    **/
    orderBy?: Enumerable<TeamMonsterKillOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TeamMonsterKills.
     * 
    **/
    cursor?: TeamMonsterKillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamMonsterKills from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamMonsterKills.
     * 
    **/
    skip?: number
    distinct?: Enumerable<TeamMonsterKillScalarFieldEnum>
  }


  /**
   * TeamMonsterKill create
   */
  export type TeamMonsterKillCreateArgs = {
    /**
     * Select specific fields to fetch from the TeamMonsterKill
     * 
    **/
    select?: TeamMonsterKillSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TeamMonsterKillInclude | null
    /**
     * The data needed to create a TeamMonsterKill.
     * 
    **/
    data: XOR<TeamMonsterKillCreateInput, TeamMonsterKillUncheckedCreateInput>
  }


  /**
   * TeamMonsterKill createMany
   */
  export type TeamMonsterKillCreateManyArgs = {
    /**
     * The data used to create many TeamMonsterKills.
     * 
    **/
    data: Enumerable<TeamMonsterKillCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * TeamMonsterKill update
   */
  export type TeamMonsterKillUpdateArgs = {
    /**
     * Select specific fields to fetch from the TeamMonsterKill
     * 
    **/
    select?: TeamMonsterKillSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TeamMonsterKillInclude | null
    /**
     * The data needed to update a TeamMonsterKill.
     * 
    **/
    data: XOR<TeamMonsterKillUpdateInput, TeamMonsterKillUncheckedUpdateInput>
    /**
     * Choose, which TeamMonsterKill to update.
     * 
    **/
    where: TeamMonsterKillWhereUniqueInput
  }


  /**
   * TeamMonsterKill updateMany
   */
  export type TeamMonsterKillUpdateManyArgs = {
    /**
     * The data used to update TeamMonsterKills.
     * 
    **/
    data: XOR<TeamMonsterKillUpdateManyMutationInput, TeamMonsterKillUncheckedUpdateManyInput>
    /**
     * Filter which TeamMonsterKills to update
     * 
    **/
    where?: TeamMonsterKillWhereInput
  }


  /**
   * TeamMonsterKill upsert
   */
  export type TeamMonsterKillUpsertArgs = {
    /**
     * Select specific fields to fetch from the TeamMonsterKill
     * 
    **/
    select?: TeamMonsterKillSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TeamMonsterKillInclude | null
    /**
     * The filter to search for the TeamMonsterKill to update in case it exists.
     * 
    **/
    where: TeamMonsterKillWhereUniqueInput
    /**
     * In case the TeamMonsterKill found by the `where` argument doesn't exist, create a new TeamMonsterKill with this data.
     * 
    **/
    create: XOR<TeamMonsterKillCreateInput, TeamMonsterKillUncheckedCreateInput>
    /**
     * In case the TeamMonsterKill was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<TeamMonsterKillUpdateInput, TeamMonsterKillUncheckedUpdateInput>
  }


  /**
   * TeamMonsterKill delete
   */
  export type TeamMonsterKillDeleteArgs = {
    /**
     * Select specific fields to fetch from the TeamMonsterKill
     * 
    **/
    select?: TeamMonsterKillSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TeamMonsterKillInclude | null
    /**
     * Filter which TeamMonsterKill to delete.
     * 
    **/
    where: TeamMonsterKillWhereUniqueInput
  }


  /**
   * TeamMonsterKill deleteMany
   */
  export type TeamMonsterKillDeleteManyArgs = {
    /**
     * Filter which TeamMonsterKills to delete
     * 
    **/
    where?: TeamMonsterKillWhereInput
  }


  /**
   * TeamMonsterKill without action
   */
  export type TeamMonsterKillArgs = {
    /**
     * Select specific fields to fetch from the TeamMonsterKill
     * 
    **/
    select?: TeamMonsterKillSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TeamMonsterKillInclude | null
  }



  /**
   * Model RuneSelection
   */


  export type AggregateRuneSelection = {
    _count: RuneSelectionCountAggregateOutputType | null
    _avg: RuneSelectionAvgAggregateOutputType | null
    _sum: RuneSelectionSumAggregateOutputType | null
    _min: RuneSelectionMinAggregateOutputType | null
    _max: RuneSelectionMaxAggregateOutputType | null
  }

  export type RuneSelectionAvgAggregateOutputType = {
    perk: number | null
    var1: number | null
    var2: number | null
    var3: number | null
  }

  export type RuneSelectionSumAggregateOutputType = {
    perk: number | null
    var1: number | null
    var2: number | null
    var3: number | null
  }

  export type RuneSelectionMinAggregateOutputType = {
    id: string | null
    runeStyleId: string | null
    perk: number | null
    var1: number | null
    var2: number | null
    var3: number | null
  }

  export type RuneSelectionMaxAggregateOutputType = {
    id: string | null
    runeStyleId: string | null
    perk: number | null
    var1: number | null
    var2: number | null
    var3: number | null
  }

  export type RuneSelectionCountAggregateOutputType = {
    id: number
    runeStyleId: number
    perk: number
    var1: number
    var2: number
    var3: number
    _all: number
  }


  export type RuneSelectionAvgAggregateInputType = {
    perk?: true
    var1?: true
    var2?: true
    var3?: true
  }

  export type RuneSelectionSumAggregateInputType = {
    perk?: true
    var1?: true
    var2?: true
    var3?: true
  }

  export type RuneSelectionMinAggregateInputType = {
    id?: true
    runeStyleId?: true
    perk?: true
    var1?: true
    var2?: true
    var3?: true
  }

  export type RuneSelectionMaxAggregateInputType = {
    id?: true
    runeStyleId?: true
    perk?: true
    var1?: true
    var2?: true
    var3?: true
  }

  export type RuneSelectionCountAggregateInputType = {
    id?: true
    runeStyleId?: true
    perk?: true
    var1?: true
    var2?: true
    var3?: true
    _all?: true
  }

  export type RuneSelectionAggregateArgs = {
    /**
     * Filter which RuneSelection to aggregate.
     * 
    **/
    where?: RuneSelectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RuneSelections to fetch.
     * 
    **/
    orderBy?: Enumerable<RuneSelectionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: RuneSelectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RuneSelections from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RuneSelections.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RuneSelections
    **/
    _count?: true | RuneSelectionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RuneSelectionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RuneSelectionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RuneSelectionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RuneSelectionMaxAggregateInputType
  }

  export type GetRuneSelectionAggregateType<T extends RuneSelectionAggregateArgs> = {
        [P in keyof T & keyof AggregateRuneSelection]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRuneSelection[P]>
      : GetScalarType<T[P], AggregateRuneSelection[P]>
  }




  export type RuneSelectionGroupByArgs = {
    where?: RuneSelectionWhereInput
    orderBy?: Enumerable<RuneSelectionOrderByWithAggregationInput>
    by: Array<RuneSelectionScalarFieldEnum>
    having?: RuneSelectionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RuneSelectionCountAggregateInputType | true
    _avg?: RuneSelectionAvgAggregateInputType
    _sum?: RuneSelectionSumAggregateInputType
    _min?: RuneSelectionMinAggregateInputType
    _max?: RuneSelectionMaxAggregateInputType
  }


  export type RuneSelectionGroupByOutputType = {
    id: string
    runeStyleId: string | null
    perk: number | null
    var1: number | null
    var2: number | null
    var3: number | null
    _count: RuneSelectionCountAggregateOutputType | null
    _avg: RuneSelectionAvgAggregateOutputType | null
    _sum: RuneSelectionSumAggregateOutputType | null
    _min: RuneSelectionMinAggregateOutputType | null
    _max: RuneSelectionMaxAggregateOutputType | null
  }

  type GetRuneSelectionGroupByPayload<T extends RuneSelectionGroupByArgs> = PrismaPromise<
    Array<
      PickArray<RuneSelectionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RuneSelectionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RuneSelectionGroupByOutputType[P]>
            : GetScalarType<T[P], RuneSelectionGroupByOutputType[P]>
        }
      >
    >


  export type RuneSelectionSelect = {
    id?: boolean
    runeStyle?: boolean | RuneStyleArgs
    runeStyleId?: boolean
    perk?: boolean
    var1?: boolean
    var2?: boolean
    var3?: boolean
  }

  export type RuneSelectionInclude = {
    runeStyle?: boolean | RuneStyleArgs
  }

  export type RuneSelectionGetPayload<
    S extends boolean | null | undefined | RuneSelectionArgs,
    U = keyof S
      > = S extends true
        ? RuneSelection
    : S extends undefined
    ? never
    : S extends RuneSelectionArgs | RuneSelectionFindManyArgs
    ?'include' extends U
    ? RuneSelection  & {
    [P in TrueKeys<S['include']>]:
        P extends 'runeStyle' ? RuneStyleGetPayload<S['include'][P]> | null :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'runeStyle' ? RuneStyleGetPayload<S['select'][P]> | null :  P extends keyof RuneSelection ? RuneSelection[P] : never
  } 
    : RuneSelection
  : RuneSelection


  type RuneSelectionCountArgs = Merge<
    Omit<RuneSelectionFindManyArgs, 'select' | 'include'> & {
      select?: RuneSelectionCountAggregateInputType | true
    }
  >

  export interface RuneSelectionDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one RuneSelection that matches the filter.
     * @param {RuneSelectionFindUniqueArgs} args - Arguments to find a RuneSelection
     * @example
     * // Get one RuneSelection
     * const runeSelection = await prisma.runeSelection.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RuneSelectionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, RuneSelectionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'RuneSelection'> extends True ? CheckSelect<T, Prisma__RuneSelectionClient<RuneSelection>, Prisma__RuneSelectionClient<RuneSelectionGetPayload<T>>> : CheckSelect<T, Prisma__RuneSelectionClient<RuneSelection | null >, Prisma__RuneSelectionClient<RuneSelectionGetPayload<T> | null >>

    /**
     * Find the first RuneSelection that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RuneSelectionFindFirstArgs} args - Arguments to find a RuneSelection
     * @example
     * // Get one RuneSelection
     * const runeSelection = await prisma.runeSelection.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RuneSelectionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, RuneSelectionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'RuneSelection'> extends True ? CheckSelect<T, Prisma__RuneSelectionClient<RuneSelection>, Prisma__RuneSelectionClient<RuneSelectionGetPayload<T>>> : CheckSelect<T, Prisma__RuneSelectionClient<RuneSelection | null >, Prisma__RuneSelectionClient<RuneSelectionGetPayload<T> | null >>

    /**
     * Find zero or more RuneSelections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RuneSelectionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RuneSelections
     * const runeSelections = await prisma.runeSelection.findMany()
     * 
     * // Get first 10 RuneSelections
     * const runeSelections = await prisma.runeSelection.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const runeSelectionWithIdOnly = await prisma.runeSelection.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RuneSelectionFindManyArgs>(
      args?: SelectSubset<T, RuneSelectionFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<RuneSelection>>, PrismaPromise<Array<RuneSelectionGetPayload<T>>>>

    /**
     * Create a RuneSelection.
     * @param {RuneSelectionCreateArgs} args - Arguments to create a RuneSelection.
     * @example
     * // Create one RuneSelection
     * const RuneSelection = await prisma.runeSelection.create({
     *   data: {
     *     // ... data to create a RuneSelection
     *   }
     * })
     * 
    **/
    create<T extends RuneSelectionCreateArgs>(
      args: SelectSubset<T, RuneSelectionCreateArgs>
    ): CheckSelect<T, Prisma__RuneSelectionClient<RuneSelection>, Prisma__RuneSelectionClient<RuneSelectionGetPayload<T>>>

    /**
     * Create many RuneSelections.
     *     @param {RuneSelectionCreateManyArgs} args - Arguments to create many RuneSelections.
     *     @example
     *     // Create many RuneSelections
     *     const runeSelection = await prisma.runeSelection.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RuneSelectionCreateManyArgs>(
      args?: SelectSubset<T, RuneSelectionCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a RuneSelection.
     * @param {RuneSelectionDeleteArgs} args - Arguments to delete one RuneSelection.
     * @example
     * // Delete one RuneSelection
     * const RuneSelection = await prisma.runeSelection.delete({
     *   where: {
     *     // ... filter to delete one RuneSelection
     *   }
     * })
     * 
    **/
    delete<T extends RuneSelectionDeleteArgs>(
      args: SelectSubset<T, RuneSelectionDeleteArgs>
    ): CheckSelect<T, Prisma__RuneSelectionClient<RuneSelection>, Prisma__RuneSelectionClient<RuneSelectionGetPayload<T>>>

    /**
     * Update one RuneSelection.
     * @param {RuneSelectionUpdateArgs} args - Arguments to update one RuneSelection.
     * @example
     * // Update one RuneSelection
     * const runeSelection = await prisma.runeSelection.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RuneSelectionUpdateArgs>(
      args: SelectSubset<T, RuneSelectionUpdateArgs>
    ): CheckSelect<T, Prisma__RuneSelectionClient<RuneSelection>, Prisma__RuneSelectionClient<RuneSelectionGetPayload<T>>>

    /**
     * Delete zero or more RuneSelections.
     * @param {RuneSelectionDeleteManyArgs} args - Arguments to filter RuneSelections to delete.
     * @example
     * // Delete a few RuneSelections
     * const { count } = await prisma.runeSelection.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RuneSelectionDeleteManyArgs>(
      args?: SelectSubset<T, RuneSelectionDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more RuneSelections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RuneSelectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RuneSelections
     * const runeSelection = await prisma.runeSelection.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RuneSelectionUpdateManyArgs>(
      args: SelectSubset<T, RuneSelectionUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one RuneSelection.
     * @param {RuneSelectionUpsertArgs} args - Arguments to update or create a RuneSelection.
     * @example
     * // Update or create a RuneSelection
     * const runeSelection = await prisma.runeSelection.upsert({
     *   create: {
     *     // ... data to create a RuneSelection
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RuneSelection we want to update
     *   }
     * })
    **/
    upsert<T extends RuneSelectionUpsertArgs>(
      args: SelectSubset<T, RuneSelectionUpsertArgs>
    ): CheckSelect<T, Prisma__RuneSelectionClient<RuneSelection>, Prisma__RuneSelectionClient<RuneSelectionGetPayload<T>>>

    /**
     * Count the number of RuneSelections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RuneSelectionCountArgs} args - Arguments to filter RuneSelections to count.
     * @example
     * // Count the number of RuneSelections
     * const count = await prisma.runeSelection.count({
     *   where: {
     *     // ... the filter for the RuneSelections we want to count
     *   }
     * })
    **/
    count<T extends RuneSelectionCountArgs>(
      args?: Subset<T, RuneSelectionCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RuneSelectionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RuneSelection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RuneSelectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RuneSelectionAggregateArgs>(args: Subset<T, RuneSelectionAggregateArgs>): PrismaPromise<GetRuneSelectionAggregateType<T>>

    /**
     * Group by RuneSelection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RuneSelectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RuneSelectionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RuneSelectionGroupByArgs['orderBy'] }
        : { orderBy?: RuneSelectionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RuneSelectionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRuneSelectionGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for RuneSelection.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RuneSelectionClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    runeStyle<T extends RuneStyleArgs = {}>(args?: Subset<T, RuneStyleArgs>): CheckSelect<T, Prisma__RuneStyleClient<RuneStyle | null >, Prisma__RuneStyleClient<RuneStyleGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * RuneSelection findUnique
   */
  export type RuneSelectionFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the RuneSelection
     * 
    **/
    select?: RuneSelectionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RuneSelectionInclude | null
    /**
     * Throw an Error if a RuneSelection can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which RuneSelection to fetch.
     * 
    **/
    where: RuneSelectionWhereUniqueInput
  }


  /**
   * RuneSelection findFirst
   */
  export type RuneSelectionFindFirstArgs = {
    /**
     * Select specific fields to fetch from the RuneSelection
     * 
    **/
    select?: RuneSelectionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RuneSelectionInclude | null
    /**
     * Throw an Error if a RuneSelection can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which RuneSelection to fetch.
     * 
    **/
    where?: RuneSelectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RuneSelections to fetch.
     * 
    **/
    orderBy?: Enumerable<RuneSelectionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RuneSelections.
     * 
    **/
    cursor?: RuneSelectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RuneSelections from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RuneSelections.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RuneSelections.
     * 
    **/
    distinct?: Enumerable<RuneSelectionScalarFieldEnum>
  }


  /**
   * RuneSelection findMany
   */
  export type RuneSelectionFindManyArgs = {
    /**
     * Select specific fields to fetch from the RuneSelection
     * 
    **/
    select?: RuneSelectionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RuneSelectionInclude | null
    /**
     * Filter, which RuneSelections to fetch.
     * 
    **/
    where?: RuneSelectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RuneSelections to fetch.
     * 
    **/
    orderBy?: Enumerable<RuneSelectionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RuneSelections.
     * 
    **/
    cursor?: RuneSelectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RuneSelections from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RuneSelections.
     * 
    **/
    skip?: number
    distinct?: Enumerable<RuneSelectionScalarFieldEnum>
  }


  /**
   * RuneSelection create
   */
  export type RuneSelectionCreateArgs = {
    /**
     * Select specific fields to fetch from the RuneSelection
     * 
    **/
    select?: RuneSelectionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RuneSelectionInclude | null
    /**
     * The data needed to create a RuneSelection.
     * 
    **/
    data: XOR<RuneSelectionCreateInput, RuneSelectionUncheckedCreateInput>
  }


  /**
   * RuneSelection createMany
   */
  export type RuneSelectionCreateManyArgs = {
    /**
     * The data used to create many RuneSelections.
     * 
    **/
    data: Enumerable<RuneSelectionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * RuneSelection update
   */
  export type RuneSelectionUpdateArgs = {
    /**
     * Select specific fields to fetch from the RuneSelection
     * 
    **/
    select?: RuneSelectionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RuneSelectionInclude | null
    /**
     * The data needed to update a RuneSelection.
     * 
    **/
    data: XOR<RuneSelectionUpdateInput, RuneSelectionUncheckedUpdateInput>
    /**
     * Choose, which RuneSelection to update.
     * 
    **/
    where: RuneSelectionWhereUniqueInput
  }


  /**
   * RuneSelection updateMany
   */
  export type RuneSelectionUpdateManyArgs = {
    /**
     * The data used to update RuneSelections.
     * 
    **/
    data: XOR<RuneSelectionUpdateManyMutationInput, RuneSelectionUncheckedUpdateManyInput>
    /**
     * Filter which RuneSelections to update
     * 
    **/
    where?: RuneSelectionWhereInput
  }


  /**
   * RuneSelection upsert
   */
  export type RuneSelectionUpsertArgs = {
    /**
     * Select specific fields to fetch from the RuneSelection
     * 
    **/
    select?: RuneSelectionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RuneSelectionInclude | null
    /**
     * The filter to search for the RuneSelection to update in case it exists.
     * 
    **/
    where: RuneSelectionWhereUniqueInput
    /**
     * In case the RuneSelection found by the `where` argument doesn't exist, create a new RuneSelection with this data.
     * 
    **/
    create: XOR<RuneSelectionCreateInput, RuneSelectionUncheckedCreateInput>
    /**
     * In case the RuneSelection was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<RuneSelectionUpdateInput, RuneSelectionUncheckedUpdateInput>
  }


  /**
   * RuneSelection delete
   */
  export type RuneSelectionDeleteArgs = {
    /**
     * Select specific fields to fetch from the RuneSelection
     * 
    **/
    select?: RuneSelectionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RuneSelectionInclude | null
    /**
     * Filter which RuneSelection to delete.
     * 
    **/
    where: RuneSelectionWhereUniqueInput
  }


  /**
   * RuneSelection deleteMany
   */
  export type RuneSelectionDeleteManyArgs = {
    /**
     * Filter which RuneSelections to delete
     * 
    **/
    where?: RuneSelectionWhereInput
  }


  /**
   * RuneSelection without action
   */
  export type RuneSelectionArgs = {
    /**
     * Select specific fields to fetch from the RuneSelection
     * 
    **/
    select?: RuneSelectionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RuneSelectionInclude | null
  }



  /**
   * Model RuneStyle
   */


  export type AggregateRuneStyle = {
    _count: RuneStyleCountAggregateOutputType | null
    _avg: RuneStyleAvgAggregateOutputType | null
    _sum: RuneStyleSumAggregateOutputType | null
    _min: RuneStyleMinAggregateOutputType | null
    _max: RuneStyleMaxAggregateOutputType | null
  }

  export type RuneStyleAvgAggregateOutputType = {
    style: number | null
  }

  export type RuneStyleSumAggregateOutputType = {
    style: number | null
  }

  export type RuneStyleMinAggregateOutputType = {
    id: string | null
    playerRunesId: string | null
    description: string | null
    style: number | null
  }

  export type RuneStyleMaxAggregateOutputType = {
    id: string | null
    playerRunesId: string | null
    description: string | null
    style: number | null
  }

  export type RuneStyleCountAggregateOutputType = {
    id: number
    playerRunesId: number
    description: number
    style: number
    _all: number
  }


  export type RuneStyleAvgAggregateInputType = {
    style?: true
  }

  export type RuneStyleSumAggregateInputType = {
    style?: true
  }

  export type RuneStyleMinAggregateInputType = {
    id?: true
    playerRunesId?: true
    description?: true
    style?: true
  }

  export type RuneStyleMaxAggregateInputType = {
    id?: true
    playerRunesId?: true
    description?: true
    style?: true
  }

  export type RuneStyleCountAggregateInputType = {
    id?: true
    playerRunesId?: true
    description?: true
    style?: true
    _all?: true
  }

  export type RuneStyleAggregateArgs = {
    /**
     * Filter which RuneStyle to aggregate.
     * 
    **/
    where?: RuneStyleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RuneStyles to fetch.
     * 
    **/
    orderBy?: Enumerable<RuneStyleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: RuneStyleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RuneStyles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RuneStyles.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RuneStyles
    **/
    _count?: true | RuneStyleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RuneStyleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RuneStyleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RuneStyleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RuneStyleMaxAggregateInputType
  }

  export type GetRuneStyleAggregateType<T extends RuneStyleAggregateArgs> = {
        [P in keyof T & keyof AggregateRuneStyle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRuneStyle[P]>
      : GetScalarType<T[P], AggregateRuneStyle[P]>
  }




  export type RuneStyleGroupByArgs = {
    where?: RuneStyleWhereInput
    orderBy?: Enumerable<RuneStyleOrderByWithAggregationInput>
    by: Array<RuneStyleScalarFieldEnum>
    having?: RuneStyleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RuneStyleCountAggregateInputType | true
    _avg?: RuneStyleAvgAggregateInputType
    _sum?: RuneStyleSumAggregateInputType
    _min?: RuneStyleMinAggregateInputType
    _max?: RuneStyleMaxAggregateInputType
  }


  export type RuneStyleGroupByOutputType = {
    id: string
    playerRunesId: string | null
    description: string
    style: number | null
    _count: RuneStyleCountAggregateOutputType | null
    _avg: RuneStyleAvgAggregateOutputType | null
    _sum: RuneStyleSumAggregateOutputType | null
    _min: RuneStyleMinAggregateOutputType | null
    _max: RuneStyleMaxAggregateOutputType | null
  }

  type GetRuneStyleGroupByPayload<T extends RuneStyleGroupByArgs> = PrismaPromise<
    Array<
      PickArray<RuneStyleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RuneStyleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RuneStyleGroupByOutputType[P]>
            : GetScalarType<T[P], RuneStyleGroupByOutputType[P]>
        }
      >
    >


  export type RuneStyleSelect = {
    id?: boolean
    playerRunes?: boolean | PlayerRuneArgs
    playerRunesId?: boolean
    selection?: boolean | RuneSelectionFindManyArgs
    description?: boolean
    style?: boolean
    _count?: boolean | RuneStyleCountOutputTypeArgs
  }

  export type RuneStyleInclude = {
    playerRunes?: boolean | PlayerRuneArgs
    selection?: boolean | RuneSelectionFindManyArgs
    _count?: boolean | RuneStyleCountOutputTypeArgs
  }

  export type RuneStyleGetPayload<
    S extends boolean | null | undefined | RuneStyleArgs,
    U = keyof S
      > = S extends true
        ? RuneStyle
    : S extends undefined
    ? never
    : S extends RuneStyleArgs | RuneStyleFindManyArgs
    ?'include' extends U
    ? RuneStyle  & {
    [P in TrueKeys<S['include']>]:
        P extends 'playerRunes' ? PlayerRuneGetPayload<S['include'][P]> | null :
        P extends 'selection' ? Array < RuneSelectionGetPayload<S['include'][P]>>  :
        P extends '_count' ? RuneStyleCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'playerRunes' ? PlayerRuneGetPayload<S['select'][P]> | null :
        P extends 'selection' ? Array < RuneSelectionGetPayload<S['select'][P]>>  :
        P extends '_count' ? RuneStyleCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof RuneStyle ? RuneStyle[P] : never
  } 
    : RuneStyle
  : RuneStyle


  type RuneStyleCountArgs = Merge<
    Omit<RuneStyleFindManyArgs, 'select' | 'include'> & {
      select?: RuneStyleCountAggregateInputType | true
    }
  >

  export interface RuneStyleDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one RuneStyle that matches the filter.
     * @param {RuneStyleFindUniqueArgs} args - Arguments to find a RuneStyle
     * @example
     * // Get one RuneStyle
     * const runeStyle = await prisma.runeStyle.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RuneStyleFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, RuneStyleFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'RuneStyle'> extends True ? CheckSelect<T, Prisma__RuneStyleClient<RuneStyle>, Prisma__RuneStyleClient<RuneStyleGetPayload<T>>> : CheckSelect<T, Prisma__RuneStyleClient<RuneStyle | null >, Prisma__RuneStyleClient<RuneStyleGetPayload<T> | null >>

    /**
     * Find the first RuneStyle that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RuneStyleFindFirstArgs} args - Arguments to find a RuneStyle
     * @example
     * // Get one RuneStyle
     * const runeStyle = await prisma.runeStyle.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RuneStyleFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, RuneStyleFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'RuneStyle'> extends True ? CheckSelect<T, Prisma__RuneStyleClient<RuneStyle>, Prisma__RuneStyleClient<RuneStyleGetPayload<T>>> : CheckSelect<T, Prisma__RuneStyleClient<RuneStyle | null >, Prisma__RuneStyleClient<RuneStyleGetPayload<T> | null >>

    /**
     * Find zero or more RuneStyles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RuneStyleFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RuneStyles
     * const runeStyles = await prisma.runeStyle.findMany()
     * 
     * // Get first 10 RuneStyles
     * const runeStyles = await prisma.runeStyle.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const runeStyleWithIdOnly = await prisma.runeStyle.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RuneStyleFindManyArgs>(
      args?: SelectSubset<T, RuneStyleFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<RuneStyle>>, PrismaPromise<Array<RuneStyleGetPayload<T>>>>

    /**
     * Create a RuneStyle.
     * @param {RuneStyleCreateArgs} args - Arguments to create a RuneStyle.
     * @example
     * // Create one RuneStyle
     * const RuneStyle = await prisma.runeStyle.create({
     *   data: {
     *     // ... data to create a RuneStyle
     *   }
     * })
     * 
    **/
    create<T extends RuneStyleCreateArgs>(
      args: SelectSubset<T, RuneStyleCreateArgs>
    ): CheckSelect<T, Prisma__RuneStyleClient<RuneStyle>, Prisma__RuneStyleClient<RuneStyleGetPayload<T>>>

    /**
     * Create many RuneStyles.
     *     @param {RuneStyleCreateManyArgs} args - Arguments to create many RuneStyles.
     *     @example
     *     // Create many RuneStyles
     *     const runeStyle = await prisma.runeStyle.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RuneStyleCreateManyArgs>(
      args?: SelectSubset<T, RuneStyleCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a RuneStyle.
     * @param {RuneStyleDeleteArgs} args - Arguments to delete one RuneStyle.
     * @example
     * // Delete one RuneStyle
     * const RuneStyle = await prisma.runeStyle.delete({
     *   where: {
     *     // ... filter to delete one RuneStyle
     *   }
     * })
     * 
    **/
    delete<T extends RuneStyleDeleteArgs>(
      args: SelectSubset<T, RuneStyleDeleteArgs>
    ): CheckSelect<T, Prisma__RuneStyleClient<RuneStyle>, Prisma__RuneStyleClient<RuneStyleGetPayload<T>>>

    /**
     * Update one RuneStyle.
     * @param {RuneStyleUpdateArgs} args - Arguments to update one RuneStyle.
     * @example
     * // Update one RuneStyle
     * const runeStyle = await prisma.runeStyle.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RuneStyleUpdateArgs>(
      args: SelectSubset<T, RuneStyleUpdateArgs>
    ): CheckSelect<T, Prisma__RuneStyleClient<RuneStyle>, Prisma__RuneStyleClient<RuneStyleGetPayload<T>>>

    /**
     * Delete zero or more RuneStyles.
     * @param {RuneStyleDeleteManyArgs} args - Arguments to filter RuneStyles to delete.
     * @example
     * // Delete a few RuneStyles
     * const { count } = await prisma.runeStyle.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RuneStyleDeleteManyArgs>(
      args?: SelectSubset<T, RuneStyleDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more RuneStyles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RuneStyleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RuneStyles
     * const runeStyle = await prisma.runeStyle.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RuneStyleUpdateManyArgs>(
      args: SelectSubset<T, RuneStyleUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one RuneStyle.
     * @param {RuneStyleUpsertArgs} args - Arguments to update or create a RuneStyle.
     * @example
     * // Update or create a RuneStyle
     * const runeStyle = await prisma.runeStyle.upsert({
     *   create: {
     *     // ... data to create a RuneStyle
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RuneStyle we want to update
     *   }
     * })
    **/
    upsert<T extends RuneStyleUpsertArgs>(
      args: SelectSubset<T, RuneStyleUpsertArgs>
    ): CheckSelect<T, Prisma__RuneStyleClient<RuneStyle>, Prisma__RuneStyleClient<RuneStyleGetPayload<T>>>

    /**
     * Count the number of RuneStyles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RuneStyleCountArgs} args - Arguments to filter RuneStyles to count.
     * @example
     * // Count the number of RuneStyles
     * const count = await prisma.runeStyle.count({
     *   where: {
     *     // ... the filter for the RuneStyles we want to count
     *   }
     * })
    **/
    count<T extends RuneStyleCountArgs>(
      args?: Subset<T, RuneStyleCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RuneStyleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RuneStyle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RuneStyleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RuneStyleAggregateArgs>(args: Subset<T, RuneStyleAggregateArgs>): PrismaPromise<GetRuneStyleAggregateType<T>>

    /**
     * Group by RuneStyle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RuneStyleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RuneStyleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RuneStyleGroupByArgs['orderBy'] }
        : { orderBy?: RuneStyleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RuneStyleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRuneStyleGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for RuneStyle.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RuneStyleClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    playerRunes<T extends PlayerRuneArgs = {}>(args?: Subset<T, PlayerRuneArgs>): CheckSelect<T, Prisma__PlayerRuneClient<PlayerRune | null >, Prisma__PlayerRuneClient<PlayerRuneGetPayload<T> | null >>;

    selection<T extends RuneSelectionFindManyArgs = {}>(args?: Subset<T, RuneSelectionFindManyArgs>): CheckSelect<T, PrismaPromise<Array<RuneSelection>>, PrismaPromise<Array<RuneSelectionGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * RuneStyle findUnique
   */
  export type RuneStyleFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the RuneStyle
     * 
    **/
    select?: RuneStyleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RuneStyleInclude | null
    /**
     * Throw an Error if a RuneStyle can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which RuneStyle to fetch.
     * 
    **/
    where: RuneStyleWhereUniqueInput
  }


  /**
   * RuneStyle findFirst
   */
  export type RuneStyleFindFirstArgs = {
    /**
     * Select specific fields to fetch from the RuneStyle
     * 
    **/
    select?: RuneStyleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RuneStyleInclude | null
    /**
     * Throw an Error if a RuneStyle can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which RuneStyle to fetch.
     * 
    **/
    where?: RuneStyleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RuneStyles to fetch.
     * 
    **/
    orderBy?: Enumerable<RuneStyleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RuneStyles.
     * 
    **/
    cursor?: RuneStyleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RuneStyles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RuneStyles.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RuneStyles.
     * 
    **/
    distinct?: Enumerable<RuneStyleScalarFieldEnum>
  }


  /**
   * RuneStyle findMany
   */
  export type RuneStyleFindManyArgs = {
    /**
     * Select specific fields to fetch from the RuneStyle
     * 
    **/
    select?: RuneStyleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RuneStyleInclude | null
    /**
     * Filter, which RuneStyles to fetch.
     * 
    **/
    where?: RuneStyleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RuneStyles to fetch.
     * 
    **/
    orderBy?: Enumerable<RuneStyleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RuneStyles.
     * 
    **/
    cursor?: RuneStyleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RuneStyles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RuneStyles.
     * 
    **/
    skip?: number
    distinct?: Enumerable<RuneStyleScalarFieldEnum>
  }


  /**
   * RuneStyle create
   */
  export type RuneStyleCreateArgs = {
    /**
     * Select specific fields to fetch from the RuneStyle
     * 
    **/
    select?: RuneStyleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RuneStyleInclude | null
    /**
     * The data needed to create a RuneStyle.
     * 
    **/
    data: XOR<RuneStyleCreateInput, RuneStyleUncheckedCreateInput>
  }


  /**
   * RuneStyle createMany
   */
  export type RuneStyleCreateManyArgs = {
    /**
     * The data used to create many RuneStyles.
     * 
    **/
    data: Enumerable<RuneStyleCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * RuneStyle update
   */
  export type RuneStyleUpdateArgs = {
    /**
     * Select specific fields to fetch from the RuneStyle
     * 
    **/
    select?: RuneStyleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RuneStyleInclude | null
    /**
     * The data needed to update a RuneStyle.
     * 
    **/
    data: XOR<RuneStyleUpdateInput, RuneStyleUncheckedUpdateInput>
    /**
     * Choose, which RuneStyle to update.
     * 
    **/
    where: RuneStyleWhereUniqueInput
  }


  /**
   * RuneStyle updateMany
   */
  export type RuneStyleUpdateManyArgs = {
    /**
     * The data used to update RuneStyles.
     * 
    **/
    data: XOR<RuneStyleUpdateManyMutationInput, RuneStyleUncheckedUpdateManyInput>
    /**
     * Filter which RuneStyles to update
     * 
    **/
    where?: RuneStyleWhereInput
  }


  /**
   * RuneStyle upsert
   */
  export type RuneStyleUpsertArgs = {
    /**
     * Select specific fields to fetch from the RuneStyle
     * 
    **/
    select?: RuneStyleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RuneStyleInclude | null
    /**
     * The filter to search for the RuneStyle to update in case it exists.
     * 
    **/
    where: RuneStyleWhereUniqueInput
    /**
     * In case the RuneStyle found by the `where` argument doesn't exist, create a new RuneStyle with this data.
     * 
    **/
    create: XOR<RuneStyleCreateInput, RuneStyleUncheckedCreateInput>
    /**
     * In case the RuneStyle was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<RuneStyleUpdateInput, RuneStyleUncheckedUpdateInput>
  }


  /**
   * RuneStyle delete
   */
  export type RuneStyleDeleteArgs = {
    /**
     * Select specific fields to fetch from the RuneStyle
     * 
    **/
    select?: RuneStyleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RuneStyleInclude | null
    /**
     * Filter which RuneStyle to delete.
     * 
    **/
    where: RuneStyleWhereUniqueInput
  }


  /**
   * RuneStyle deleteMany
   */
  export type RuneStyleDeleteManyArgs = {
    /**
     * Filter which RuneStyles to delete
     * 
    **/
    where?: RuneStyleWhereInput
  }


  /**
   * RuneStyle without action
   */
  export type RuneStyleArgs = {
    /**
     * Select specific fields to fetch from the RuneStyle
     * 
    **/
    select?: RuneStyleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RuneStyleInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const ActivityScalarFieldEnum: {
    id: 'id',
    profileId: 'profileId',
    month: 'month',
    year: 'year',
    day: 'day',
    gamesPlayed: 'gamesPlayed'
  };

  export type ActivityScalarFieldEnum = (typeof ActivityScalarFieldEnum)[keyof typeof ActivityScalarFieldEnum]


  export const ChampionWinrateScalarFieldEnum: {
    id: 'id',
    profileId: 'profileId',
    champion: 'champion',
    wins: 'wins',
    games: 'games',
    spell1Casts: 'spell1Casts',
    spell2Casts: 'spell2Casts',
    spell3Casts: 'spell3Casts',
    spell4Casts: 'spell4Casts'
  };

  export type ChampionWinrateScalarFieldEnum = (typeof ChampionWinrateScalarFieldEnum)[keyof typeof ChampionWinrateScalarFieldEnum]


  export const DuoScalarFieldEnum: {
    id: 'id',
    profileId: 'profileId',
    name: 'name',
    wins: 'wins',
    losses: 'losses',
    winrate: 'winrate'
  };

  export type DuoScalarFieldEnum = (typeof DuoScalarFieldEnum)[keyof typeof DuoScalarFieldEnum]


  export const ConstantScalarFieldEnum: {
    id: 'id',
    startTime: 'startTime',
    currentSeason: 'currentSeason',
    seeding: 'seeding'
  };

  export type ConstantScalarFieldEnum = (typeof ConstantScalarFieldEnum)[keyof typeof ConstantScalarFieldEnum]


  export const EventScalarFieldEnum: {
    id: 'id',
    timestamp: 'timestamp'
  };

  export type EventScalarFieldEnum = (typeof EventScalarFieldEnum)[keyof typeof EventScalarFieldEnum]


  export const GameScalarFieldEnum: {
    id: 'id',
    matchId: 'matchId',
    gameId: 'gameId',
    gameCreation: 'gameCreation',
    gameStartTimestamp: 'gameStartTimestamp',
    gameEndTimestamp: 'gameEndTimestamp',
    duration: 'duration',
    start: 'start',
    gameVersion: 'gameVersion',
    blueTeamId: 'blueTeamId',
    redTeamId: 'redTeamId',
    tournament: 'tournament',
    gameInSeries: 'gameInSeries',
    vod: 'vod',
    platformId: 'platformId'
  };

  export type GameScalarFieldEnum = (typeof GameScalarFieldEnum)[keyof typeof GameScalarFieldEnum]


  export const ObjectiveScalarFieldEnum: {
    id: 'id',
    teamId: 'teamId',
    first: 'first',
    kills: 'kills',
    type: 'type'
  };

  export type ObjectiveScalarFieldEnum = (typeof ObjectiveScalarFieldEnum)[keyof typeof ObjectiveScalarFieldEnum]


  export const PickBanScalarFieldEnum: {
    id: 'id',
    teamId: 'teamId',
    championId: 'championId',
    pickTurn: 'pickTurn'
  };

  export type PickBanScalarFieldEnum = (typeof PickBanScalarFieldEnum)[keyof typeof PickBanScalarFieldEnum]


  export const PlayerScalarFieldEnum: {
    id: 'id',
    puuid: 'puuid',
    accountId: 'accountId',
    platformId: 'platformId',
    summonerId: 'summonerId',
    summonerName: 'summonerName',
    summonerLevel: 'summonerLevel',
    profileIconId: 'profileIconId',
    revisionDate: 'revisionDate',
    profileId: 'profileId'
  };

  export type PlayerScalarFieldEnum = (typeof PlayerScalarFieldEnum)[keyof typeof PlayerScalarFieldEnum]


  export const PlayerEndOfGameStatScalarFieldEnum: {
    id: 'id',
    playerId: 'playerId',
    gameId: 'gameId',
    perksId: 'perksId',
    itemsId: 'itemsId',
    assists: 'assists',
    baronKills: 'baronKills',
    bountyLevel: 'bountyLevel',
    championExperience: 'championExperience',
    championLevel: 'championLevel',
    championId: 'championId',
    championName: 'championName',
    championTransform: 'championTransform',
    consumablesPurchased: 'consumablesPurchased',
    damageDealtToBuildings: 'damageDealtToBuildings',
    damageDealtToObjectives: 'damageDealtToObjectives',
    damageDealtToTurrets: 'damageDealtToTurrets',
    damageSelfMitigated: 'damageSelfMitigated',
    deaths: 'deaths',
    detectorWardsPlaced: 'detectorWardsPlaced',
    doubleKills: 'doubleKills',
    dragonKills: 'dragonKills',
    firstBlood: 'firstBlood',
    firstBloodAssist: 'firstBloodAssist',
    firstTowerKill: 'firstTowerKill',
    firstTowerAssist: 'firstTowerAssist',
    gameEndedInEarlySurrender: 'gameEndedInEarlySurrender',
    gameEndedInSurrender: 'gameEndedInSurrender',
    goldEarned: 'goldEarned',
    goldSpent: 'goldSpent',
    individualPosition: 'individualPosition',
    inhibitorKills: 'inhibitorKills',
    inhibitorTakedowns: 'inhibitorTakedowns',
    inhibitorsLost: 'inhibitorsLost',
    item0: 'item0',
    item1: 'item1',
    item2: 'item2',
    item3: 'item3',
    item4: 'item4',
    item5: 'item5',
    item6: 'item6',
    itemsPurchased: 'itemsPurchased',
    killingSprees: 'killingSprees',
    kills: 'kills',
    lane: 'lane',
    largestCriticalStrike: 'largestCriticalStrike',
    largestKillingSpree: 'largestKillingSpree',
    largestMultiKill: 'largestMultiKill',
    longestTimeSpentLiving: 'longestTimeSpentLiving',
    magicDamageDealt: 'magicDamageDealt',
    magicDamageDealtToChampions: 'magicDamageDealtToChampions',
    magicDamageTaken: 'magicDamageTaken',
    neutralMinionsKilled: 'neutralMinionsKilled',
    nexusKills: 'nexusKills',
    nexusLost: 'nexusLost',
    nexusTakedowns: 'nexusTakedowns',
    objectivesStolen: 'objectivesStolen',
    objectivesStolenAssists: 'objectivesStolenAssists',
    participantId: 'participantId',
    pentaKills: 'pentaKills',
    physicalDamageDealt: 'physicalDamageDealt',
    physicalDamageDealtToChampions: 'physicalDamageDealtToChampions',
    physicalDamageTaken: 'physicalDamageTaken',
    quadraKills: 'quadraKills',
    riotIdName: 'riotIdName',
    riotIdTagline: 'riotIdTagline',
    role: 'role',
    sightWardsBoughtInGame: 'sightWardsBoughtInGame',
    spell1Casts: 'spell1Casts',
    spell2Casts: 'spell2Casts',
    spell3Casts: 'spell3Casts',
    spell4Casts: 'spell4Casts',
    summoner1Casts: 'summoner1Casts',
    summoner1Id: 'summoner1Id',
    summoner2Casts: 'summoner2Casts',
    summoner2Id: 'summoner2Id',
    summonerLevel: 'summonerLevel',
    summonerName: 'summonerName',
    teamEarlySurrendered: 'teamEarlySurrendered',
    teamId: 'teamId',
    teamPosition: 'teamPosition',
    timeCCingOthers: 'timeCCingOthers',
    timePlayed: 'timePlayed',
    totalDamageDealt: 'totalDamageDealt',
    totalDamageDealtToChampions: 'totalDamageDealtToChampions',
    totalDamageShieldedOnTeammates: 'totalDamageShieldedOnTeammates',
    totalDamageTaken: 'totalDamageTaken',
    totalHeal: 'totalHeal',
    totalHealsOnTeammates: 'totalHealsOnTeammates',
    totalMinionsKilled: 'totalMinionsKilled',
    totalTimeCCDealt: 'totalTimeCCDealt',
    totalTimeSpentDead: 'totalTimeSpentDead',
    totalUnitsHealed: 'totalUnitsHealed',
    tripleKills: 'tripleKills',
    trueDamageDealt: 'trueDamageDealt',
    trueDamageDealtToChampions: 'trueDamageDealtToChampions',
    trueDamageTaken: 'trueDamageTaken',
    turretsKilled: 'turretsKilled',
    turretTakedowns: 'turretTakedowns',
    turretsLost: 'turretsLost',
    unrealKills: 'unrealKills',
    visionScore: 'visionScore',
    visionWardsBoughtInGame: 'visionWardsBoughtInGame',
    wardsKilled: 'wardsKilled',
    wardsPlaced: 'wardsPlaced',
    win: 'win'
  };

  export type PlayerEndOfGameStatScalarFieldEnum = (typeof PlayerEndOfGameStatScalarFieldEnum)[keyof typeof PlayerEndOfGameStatScalarFieldEnum]


  export const PlayerItemScalarFieldEnum: {
    id: 'id',
    slot: 'slot',
    itemId: 'itemId',
    name: 'name'
  };

  export type PlayerItemScalarFieldEnum = (typeof PlayerItemScalarFieldEnum)[keyof typeof PlayerItemScalarFieldEnum]


  export const PlayerItemEventScalarFieldEnum: {
    id: 'id',
    type: 'type',
    itemId: 'itemId',
    name: 'name',
    undoId: 'undoId'
  };

  export type PlayerItemEventScalarFieldEnum = (typeof PlayerItemEventScalarFieldEnum)[keyof typeof PlayerItemEventScalarFieldEnum]


  export const PlayerKillScalarFieldEnum: {
    id: 'id'
  };

  export type PlayerKillScalarFieldEnum = (typeof PlayerKillScalarFieldEnum)[keyof typeof PlayerKillScalarFieldEnum]


  export const PlayerRuneScalarFieldEnum: {
    id: 'id',
    defense: 'defense',
    flex: 'flex',
    offense: 'offense'
  };

  export type PlayerRuneScalarFieldEnum = (typeof PlayerRuneScalarFieldEnum)[keyof typeof PlayerRuneScalarFieldEnum]


  export const PlayerSkillLevelUpEventScalarFieldEnum: {
    id: 'id',
    type: 'type',
    slot: 'slot'
  };

  export type PlayerSkillLevelUpEventScalarFieldEnum = (typeof PlayerSkillLevelUpEventScalarFieldEnum)[keyof typeof PlayerSkillLevelUpEventScalarFieldEnum]


  export const PlayerSnapshotScalarFieldEnum: {
    id: 'id',
    timestamp: 'timestamp',
    currentGold: 'currentGold',
    totalGold: 'totalGold',
    totalGoldDiff: 'totalGoldDiff',
    xp: 'xp',
    xpDiff: 'xpDiff',
    level: 'level',
    cs: 'cs',
    csDiff: 'csDiff',
    monstersKilled: 'monstersKilled',
    monstersKilledDiff: 'monstersKilledDiff'
  };

  export type PlayerSnapshotScalarFieldEnum = (typeof PlayerSnapshotScalarFieldEnum)[keyof typeof PlayerSnapshotScalarFieldEnum]


  export const PlayerWardEventScalarFieldEnum: {
    id: 'id',
    type: 'type',
    wardType: 'wardType'
  };

  export type PlayerWardEventScalarFieldEnum = (typeof PlayerWardEventScalarFieldEnum)[keyof typeof PlayerWardEventScalarFieldEnum]


  export const PositionScalarFieldEnum: {
    id: 'id',
    x: 'x',
    y: 'y'
  };

  export type PositionScalarFieldEnum = (typeof PositionScalarFieldEnum)[keyof typeof PositionScalarFieldEnum]


  export const ProfileScalarFieldEnum: {
    id: 'id',
    update: 'update',
    lastUpdate: 'lastUpdate',
    kills: 'kills',
    deaths: 'deaths',
    assists: 'assists',
    kda: 'kda',
    winRate: 'winRate',
    csPerMinute: 'csPerMinute',
    damagePerMinute: 'damagePerMinute',
    killsPerMinute: 'killsPerMinute',
    goldPerMinute: 'goldPerMinute',
    averageGameTime: 'averageGameTime',
    averageTimeSpentDead: 'averageTimeSpentDead',
    totalGameTime: 'totalGameTime'
  };

  export type ProfileScalarFieldEnum = (typeof ProfileScalarFieldEnum)[keyof typeof ProfileScalarFieldEnum]


  export const SeedIdentifierScalarFieldEnum: {
    id: 'id',
    identifier: 'identifier',
    type: 'type',
    timestamp: 'timestamp',
    priority: 'priority',
    retrieved: 'retrieved'
  };

  export type SeedIdentifierScalarFieldEnum = (typeof SeedIdentifierScalarFieldEnum)[keyof typeof SeedIdentifierScalarFieldEnum]


  export const SourceScalarFieldEnum: {
    id: 'id',
    api: 'api'
  };

  export type SourceScalarFieldEnum = (typeof SourceScalarFieldEnum)[keyof typeof SourceScalarFieldEnum]


  export const TeamScalarFieldEnum: {
    id: 'id',
    gameId: 'gameId',
    teamId: 'teamId',
    teamMatchId: 'teamMatchId',
    win: 'win'
  };

  export type TeamScalarFieldEnum = (typeof TeamScalarFieldEnum)[keyof typeof TeamScalarFieldEnum]


  export const TeamBuildingKillScalarFieldEnum: {
    id: 'id',
    type: 'type',
    lane: 'lane',
    side: 'side',
    towerLocation: 'towerLocation'
  };

  export type TeamBuildingKillScalarFieldEnum = (typeof TeamBuildingKillScalarFieldEnum)[keyof typeof TeamBuildingKillScalarFieldEnum]


  export const TeamMonsterKillScalarFieldEnum: {
    id: 'id',
    type: 'type',
    subType: 'subType'
  };

  export type TeamMonsterKillScalarFieldEnum = (typeof TeamMonsterKillScalarFieldEnum)[keyof typeof TeamMonsterKillScalarFieldEnum]


  export const RuneSelectionScalarFieldEnum: {
    id: 'id',
    runeStyleId: 'runeStyleId',
    perk: 'perk',
    var1: 'var1',
    var2: 'var2',
    var3: 'var3'
  };

  export type RuneSelectionScalarFieldEnum = (typeof RuneSelectionScalarFieldEnum)[keyof typeof RuneSelectionScalarFieldEnum]


  export const RuneStyleScalarFieldEnum: {
    id: 'id',
    playerRunesId: 'playerRunesId',
    description: 'description',
    style: 'style'
  };

  export type RuneStyleScalarFieldEnum = (typeof RuneStyleScalarFieldEnum)[keyof typeof RuneStyleScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  /**
   * Deep Input Types
   */


  export type ActivityWhereInput = {
    AND?: Enumerable<ActivityWhereInput>
    OR?: Enumerable<ActivityWhereInput>
    NOT?: Enumerable<ActivityWhereInput>
    id?: StringFilter | string
    profile?: XOR<ProfileRelationFilter, ProfileWhereInput> | null
    profileId?: StringNullableFilter | string | null
    month?: IntNullableFilter | number | null
    year?: IntNullableFilter | number | null
    day?: IntNullableFilter | number | null
    gamesPlayed?: IntNullableFilter | number | null
  }

  export type ActivityOrderByWithRelationInput = {
    id?: SortOrder
    profile?: ProfileOrderByWithRelationInput
    profileId?: SortOrder
    month?: SortOrder
    year?: SortOrder
    day?: SortOrder
    gamesPlayed?: SortOrder
  }

  export type ActivityWhereUniqueInput = {
    id?: string
  }

  export type ActivityOrderByWithAggregationInput = {
    id?: SortOrder
    profileId?: SortOrder
    month?: SortOrder
    year?: SortOrder
    day?: SortOrder
    gamesPlayed?: SortOrder
    _count?: ActivityCountOrderByAggregateInput
    _avg?: ActivityAvgOrderByAggregateInput
    _max?: ActivityMaxOrderByAggregateInput
    _min?: ActivityMinOrderByAggregateInput
    _sum?: ActivitySumOrderByAggregateInput
  }

  export type ActivityScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ActivityScalarWhereWithAggregatesInput>
    OR?: Enumerable<ActivityScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ActivityScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    profileId?: StringNullableWithAggregatesFilter | string | null
    month?: IntNullableWithAggregatesFilter | number | null
    year?: IntNullableWithAggregatesFilter | number | null
    day?: IntNullableWithAggregatesFilter | number | null
    gamesPlayed?: IntNullableWithAggregatesFilter | number | null
  }

  export type ChampionWinrateWhereInput = {
    AND?: Enumerable<ChampionWinrateWhereInput>
    OR?: Enumerable<ChampionWinrateWhereInput>
    NOT?: Enumerable<ChampionWinrateWhereInput>
    id?: StringFilter | string
    profile?: XOR<ProfileRelationFilter, ProfileWhereInput> | null
    profileId?: StringNullableFilter | string | null
    champion?: StringFilter | string
    wins?: IntNullableFilter | number | null
    games?: IntNullableFilter | number | null
    spell1Casts?: IntNullableFilter | number | null
    spell2Casts?: IntNullableFilter | number | null
    spell3Casts?: IntNullableFilter | number | null
    spell4Casts?: IntNullableFilter | number | null
  }

  export type ChampionWinrateOrderByWithRelationInput = {
    id?: SortOrder
    profile?: ProfileOrderByWithRelationInput
    profileId?: SortOrder
    champion?: SortOrder
    wins?: SortOrder
    games?: SortOrder
    spell1Casts?: SortOrder
    spell2Casts?: SortOrder
    spell3Casts?: SortOrder
    spell4Casts?: SortOrder
  }

  export type ChampionWinrateWhereUniqueInput = {
    id?: string
  }

  export type ChampionWinrateOrderByWithAggregationInput = {
    id?: SortOrder
    profileId?: SortOrder
    champion?: SortOrder
    wins?: SortOrder
    games?: SortOrder
    spell1Casts?: SortOrder
    spell2Casts?: SortOrder
    spell3Casts?: SortOrder
    spell4Casts?: SortOrder
    _count?: ChampionWinrateCountOrderByAggregateInput
    _avg?: ChampionWinrateAvgOrderByAggregateInput
    _max?: ChampionWinrateMaxOrderByAggregateInput
    _min?: ChampionWinrateMinOrderByAggregateInput
    _sum?: ChampionWinrateSumOrderByAggregateInput
  }

  export type ChampionWinrateScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ChampionWinrateScalarWhereWithAggregatesInput>
    OR?: Enumerable<ChampionWinrateScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ChampionWinrateScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    profileId?: StringNullableWithAggregatesFilter | string | null
    champion?: StringWithAggregatesFilter | string
    wins?: IntNullableWithAggregatesFilter | number | null
    games?: IntNullableWithAggregatesFilter | number | null
    spell1Casts?: IntNullableWithAggregatesFilter | number | null
    spell2Casts?: IntNullableWithAggregatesFilter | number | null
    spell3Casts?: IntNullableWithAggregatesFilter | number | null
    spell4Casts?: IntNullableWithAggregatesFilter | number | null
  }

  export type DuoWhereInput = {
    AND?: Enumerable<DuoWhereInput>
    OR?: Enumerable<DuoWhereInput>
    NOT?: Enumerable<DuoWhereInput>
    id?: StringFilter | string
    profile?: XOR<ProfileRelationFilter, ProfileWhereInput> | null
    profileId?: StringNullableFilter | string | null
    name?: StringFilter | string
    wins?: IntNullableFilter | number | null
    losses?: IntNullableFilter | number | null
    winrate?: StringFilter | string
  }

  export type DuoOrderByWithRelationInput = {
    id?: SortOrder
    profile?: ProfileOrderByWithRelationInput
    profileId?: SortOrder
    name?: SortOrder
    wins?: SortOrder
    losses?: SortOrder
    winrate?: SortOrder
  }

  export type DuoWhereUniqueInput = {
    id?: string
  }

  export type DuoOrderByWithAggregationInput = {
    id?: SortOrder
    profileId?: SortOrder
    name?: SortOrder
    wins?: SortOrder
    losses?: SortOrder
    winrate?: SortOrder
    _count?: DuoCountOrderByAggregateInput
    _avg?: DuoAvgOrderByAggregateInput
    _max?: DuoMaxOrderByAggregateInput
    _min?: DuoMinOrderByAggregateInput
    _sum?: DuoSumOrderByAggregateInput
  }

  export type DuoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DuoScalarWhereWithAggregatesInput>
    OR?: Enumerable<DuoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DuoScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    profileId?: StringNullableWithAggregatesFilter | string | null
    name?: StringWithAggregatesFilter | string
    wins?: IntNullableWithAggregatesFilter | number | null
    losses?: IntNullableWithAggregatesFilter | number | null
    winrate?: StringWithAggregatesFilter | string
  }

  export type ConstantWhereInput = {
    AND?: Enumerable<ConstantWhereInput>
    OR?: Enumerable<ConstantWhereInput>
    NOT?: Enumerable<ConstantWhereInput>
    id?: StringFilter | string
    startTime?: StringFilter | string
    currentSeason?: StringFilter | string
    seeding?: BoolFilter | boolean
  }

  export type ConstantOrderByWithRelationInput = {
    id?: SortOrder
    startTime?: SortOrder
    currentSeason?: SortOrder
    seeding?: SortOrder
  }

  export type ConstantWhereUniqueInput = {
    id?: string
  }

  export type ConstantOrderByWithAggregationInput = {
    id?: SortOrder
    startTime?: SortOrder
    currentSeason?: SortOrder
    seeding?: SortOrder
    _count?: ConstantCountOrderByAggregateInput
    _max?: ConstantMaxOrderByAggregateInput
    _min?: ConstantMinOrderByAggregateInput
  }

  export type ConstantScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ConstantScalarWhereWithAggregatesInput>
    OR?: Enumerable<ConstantScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ConstantScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    startTime?: StringWithAggregatesFilter | string
    currentSeason?: StringWithAggregatesFilter | string
    seeding?: BoolWithAggregatesFilter | boolean
  }

  export type EventWhereInput = {
    AND?: Enumerable<EventWhereInput>
    OR?: Enumerable<EventWhereInput>
    NOT?: Enumerable<EventWhereInput>
    id?: StringFilter | string
    timestamp?: IntNullableFilter | number | null
    position?: PositionListRelationFilter
  }

  export type EventOrderByWithRelationInput = {
    id?: SortOrder
    timestamp?: SortOrder
    position?: PositionOrderByRelationAggregateInput
  }

  export type EventWhereUniqueInput = {
    id?: string
  }

  export type EventOrderByWithAggregationInput = {
    id?: SortOrder
    timestamp?: SortOrder
    _count?: EventCountOrderByAggregateInput
    _avg?: EventAvgOrderByAggregateInput
    _max?: EventMaxOrderByAggregateInput
    _min?: EventMinOrderByAggregateInput
    _sum?: EventSumOrderByAggregateInput
  }

  export type EventScalarWhereWithAggregatesInput = {
    AND?: Enumerable<EventScalarWhereWithAggregatesInput>
    OR?: Enumerable<EventScalarWhereWithAggregatesInput>
    NOT?: Enumerable<EventScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    timestamp?: IntNullableWithAggregatesFilter | number | null
  }

  export type GameWhereInput = {
    AND?: Enumerable<GameWhereInput>
    OR?: Enumerable<GameWhereInput>
    NOT?: Enumerable<GameWhereInput>
    id?: StringFilter | string
    matchId?: StringFilter | string
    gameId?: StringFilter | string
    gameCreation?: StringFilter | string
    gameStartTimestamp?: StringFilter | string
    gameEndTimestamp?: StringFilter | string
    duration?: IntNullableFilter | number | null
    start?: StringFilter | string
    gameVersion?: StringFilter | string
    blueTeam?: XOR<TeamRelationFilter, TeamWhereInput> | null
    blueTeamId?: StringNullableFilter | string | null
    redTeam?: XOR<TeamRelationFilter, TeamWhereInput> | null
    redTeamId?: StringNullableFilter | string | null
    source?: SourceListRelationFilter
    tournament?: StringFilter | string
    gameInSeries?: IntNullableFilter | number | null
    vod?: StringFilter | string
    platformId?: StringFilter | string
    from_PlayerEndOfGameStat_game?: PlayerEndOfGameStatListRelationFilter
    from_Team_game?: TeamListRelationFilter
  }

  export type GameOrderByWithRelationInput = {
    id?: SortOrder
    matchId?: SortOrder
    gameId?: SortOrder
    gameCreation?: SortOrder
    gameStartTimestamp?: SortOrder
    gameEndTimestamp?: SortOrder
    duration?: SortOrder
    start?: SortOrder
    gameVersion?: SortOrder
    blueTeam?: TeamOrderByWithRelationInput
    blueTeamId?: SortOrder
    redTeam?: TeamOrderByWithRelationInput
    redTeamId?: SortOrder
    source?: SourceOrderByRelationAggregateInput
    tournament?: SortOrder
    gameInSeries?: SortOrder
    vod?: SortOrder
    platformId?: SortOrder
    from_PlayerEndOfGameStat_game?: PlayerEndOfGameStatOrderByRelationAggregateInput
    from_Team_game?: TeamOrderByRelationAggregateInput
  }

  export type GameWhereUniqueInput = {
    id?: string
    matchId?: string
  }

  export type GameOrderByWithAggregationInput = {
    id?: SortOrder
    matchId?: SortOrder
    gameId?: SortOrder
    gameCreation?: SortOrder
    gameStartTimestamp?: SortOrder
    gameEndTimestamp?: SortOrder
    duration?: SortOrder
    start?: SortOrder
    gameVersion?: SortOrder
    blueTeamId?: SortOrder
    redTeamId?: SortOrder
    tournament?: SortOrder
    gameInSeries?: SortOrder
    vod?: SortOrder
    platformId?: SortOrder
    _count?: GameCountOrderByAggregateInput
    _avg?: GameAvgOrderByAggregateInput
    _max?: GameMaxOrderByAggregateInput
    _min?: GameMinOrderByAggregateInput
    _sum?: GameSumOrderByAggregateInput
  }

  export type GameScalarWhereWithAggregatesInput = {
    AND?: Enumerable<GameScalarWhereWithAggregatesInput>
    OR?: Enumerable<GameScalarWhereWithAggregatesInput>
    NOT?: Enumerable<GameScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    matchId?: StringWithAggregatesFilter | string
    gameId?: StringWithAggregatesFilter | string
    gameCreation?: StringWithAggregatesFilter | string
    gameStartTimestamp?: StringWithAggregatesFilter | string
    gameEndTimestamp?: StringWithAggregatesFilter | string
    duration?: IntNullableWithAggregatesFilter | number | null
    start?: StringWithAggregatesFilter | string
    gameVersion?: StringWithAggregatesFilter | string
    blueTeamId?: StringNullableWithAggregatesFilter | string | null
    redTeamId?: StringNullableWithAggregatesFilter | string | null
    tournament?: StringWithAggregatesFilter | string
    gameInSeries?: IntNullableWithAggregatesFilter | number | null
    vod?: StringWithAggregatesFilter | string
    platformId?: StringWithAggregatesFilter | string
  }

  export type ObjectiveWhereInput = {
    AND?: Enumerable<ObjectiveWhereInput>
    OR?: Enumerable<ObjectiveWhereInput>
    NOT?: Enumerable<ObjectiveWhereInput>
    id?: StringFilter | string
    team?: XOR<TeamRelationFilter, TeamWhereInput> | null
    teamId?: StringNullableFilter | string | null
    first?: BoolFilter | boolean
    kills?: IntNullableFilter | number | null
    type?: StringFilter | string
  }

  export type ObjectiveOrderByWithRelationInput = {
    id?: SortOrder
    team?: TeamOrderByWithRelationInput
    teamId?: SortOrder
    first?: SortOrder
    kills?: SortOrder
    type?: SortOrder
  }

  export type ObjectiveWhereUniqueInput = {
    id?: string
  }

  export type ObjectiveOrderByWithAggregationInput = {
    id?: SortOrder
    teamId?: SortOrder
    first?: SortOrder
    kills?: SortOrder
    type?: SortOrder
    _count?: ObjectiveCountOrderByAggregateInput
    _avg?: ObjectiveAvgOrderByAggregateInput
    _max?: ObjectiveMaxOrderByAggregateInput
    _min?: ObjectiveMinOrderByAggregateInput
    _sum?: ObjectiveSumOrderByAggregateInput
  }

  export type ObjectiveScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ObjectiveScalarWhereWithAggregatesInput>
    OR?: Enumerable<ObjectiveScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ObjectiveScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    teamId?: StringNullableWithAggregatesFilter | string | null
    first?: BoolWithAggregatesFilter | boolean
    kills?: IntNullableWithAggregatesFilter | number | null
    type?: StringWithAggregatesFilter | string
  }

  export type PickBanWhereInput = {
    AND?: Enumerable<PickBanWhereInput>
    OR?: Enumerable<PickBanWhereInput>
    NOT?: Enumerable<PickBanWhereInput>
    id?: StringFilter | string
    team?: XOR<TeamRelationFilter, TeamWhereInput> | null
    teamId?: StringNullableFilter | string | null
    championId?: IntNullableFilter | number | null
    pickTurn?: IntNullableFilter | number | null
  }

  export type PickBanOrderByWithRelationInput = {
    id?: SortOrder
    team?: TeamOrderByWithRelationInput
    teamId?: SortOrder
    championId?: SortOrder
    pickTurn?: SortOrder
  }

  export type PickBanWhereUniqueInput = {
    id?: string
  }

  export type PickBanOrderByWithAggregationInput = {
    id?: SortOrder
    teamId?: SortOrder
    championId?: SortOrder
    pickTurn?: SortOrder
    _count?: PickBanCountOrderByAggregateInput
    _avg?: PickBanAvgOrderByAggregateInput
    _max?: PickBanMaxOrderByAggregateInput
    _min?: PickBanMinOrderByAggregateInput
    _sum?: PickBanSumOrderByAggregateInput
  }

  export type PickBanScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PickBanScalarWhereWithAggregatesInput>
    OR?: Enumerable<PickBanScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PickBanScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    teamId?: StringNullableWithAggregatesFilter | string | null
    championId?: IntNullableWithAggregatesFilter | number | null
    pickTurn?: IntNullableWithAggregatesFilter | number | null
  }

  export type PlayerWhereInput = {
    AND?: Enumerable<PlayerWhereInput>
    OR?: Enumerable<PlayerWhereInput>
    NOT?: Enumerable<PlayerWhereInput>
    id?: StringFilter | string
    puuid?: StringFilter | string
    accountId?: StringFilter | string
    platformId?: StringFilter | string
    summonerId?: StringFilter | string
    summonerName?: StringFilter | string
    summonerLevel?: IntNullableFilter | number | null
    profileIconId?: IntNullableFilter | number | null
    revisionDate?: StringFilter | string
    kills?: PlayerKillListRelationFilter
    deaths?: PlayerKillListRelationFilter
    teams?: TeamListRelationFilter
    profile?: XOR<ProfileRelationFilter, ProfileWhereInput> | null
    profileId?: StringNullableFilter | string | null
    monsterKills?: TeamMonsterKillListRelationFilter
    buildingKills?: TeamBuildingKillListRelationFilter
    itemEvent?: PlayerItemEventListRelationFilter
    endOfGameStats?: PlayerEndOfGameStatListRelationFilter
    snapshots?: PlayerSnapshotListRelationFilter
    wardEvents?: PlayerWardEventListRelationFilter
    skillLevelUpEvents?: PlayerSkillLevelUpEventListRelationFilter
  }

  export type PlayerOrderByWithRelationInput = {
    id?: SortOrder
    puuid?: SortOrder
    accountId?: SortOrder
    platformId?: SortOrder
    summonerId?: SortOrder
    summonerName?: SortOrder
    summonerLevel?: SortOrder
    profileIconId?: SortOrder
    revisionDate?: SortOrder
    kills?: PlayerKillOrderByRelationAggregateInput
    deaths?: PlayerKillOrderByRelationAggregateInput
    teams?: TeamOrderByRelationAggregateInput
    profile?: ProfileOrderByWithRelationInput
    profileId?: SortOrder
    monsterKills?: TeamMonsterKillOrderByRelationAggregateInput
    buildingKills?: TeamBuildingKillOrderByRelationAggregateInput
    itemEvent?: PlayerItemEventOrderByRelationAggregateInput
    endOfGameStats?: PlayerEndOfGameStatOrderByRelationAggregateInput
    snapshots?: PlayerSnapshotOrderByRelationAggregateInput
    wardEvents?: PlayerWardEventOrderByRelationAggregateInput
    skillLevelUpEvents?: PlayerSkillLevelUpEventOrderByRelationAggregateInput
  }

  export type PlayerWhereUniqueInput = {
    id?: string
    puuid?: string
    accountId?: string
    summonerId?: string
    profileId?: string
  }

  export type PlayerOrderByWithAggregationInput = {
    id?: SortOrder
    puuid?: SortOrder
    accountId?: SortOrder
    platformId?: SortOrder
    summonerId?: SortOrder
    summonerName?: SortOrder
    summonerLevel?: SortOrder
    profileIconId?: SortOrder
    revisionDate?: SortOrder
    profileId?: SortOrder
    _count?: PlayerCountOrderByAggregateInput
    _avg?: PlayerAvgOrderByAggregateInput
    _max?: PlayerMaxOrderByAggregateInput
    _min?: PlayerMinOrderByAggregateInput
    _sum?: PlayerSumOrderByAggregateInput
  }

  export type PlayerScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PlayerScalarWhereWithAggregatesInput>
    OR?: Enumerable<PlayerScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PlayerScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    puuid?: StringWithAggregatesFilter | string
    accountId?: StringWithAggregatesFilter | string
    platformId?: StringWithAggregatesFilter | string
    summonerId?: StringWithAggregatesFilter | string
    summonerName?: StringWithAggregatesFilter | string
    summonerLevel?: IntNullableWithAggregatesFilter | number | null
    profileIconId?: IntNullableWithAggregatesFilter | number | null
    revisionDate?: StringWithAggregatesFilter | string
    profileId?: StringNullableWithAggregatesFilter | string | null
  }

  export type PlayerEndOfGameStatWhereInput = {
    AND?: Enumerable<PlayerEndOfGameStatWhereInput>
    OR?: Enumerable<PlayerEndOfGameStatWhereInput>
    NOT?: Enumerable<PlayerEndOfGameStatWhereInput>
    id?: StringFilter | string
    player?: XOR<PlayerRelationFilter, PlayerWhereInput> | null
    playerId?: StringNullableFilter | string | null
    game?: XOR<GameRelationFilter, GameWhereInput> | null
    gameId?: StringNullableFilter | string | null
    perks?: XOR<PlayerRuneRelationFilter, PlayerRuneWhereInput> | null
    perksId?: StringNullableFilter | string | null
    items?: XOR<PlayerItemRelationFilter, PlayerItemWhereInput> | null
    itemsId?: StringNullableFilter | string | null
    assists?: IntNullableFilter | number | null
    baronKills?: IntNullableFilter | number | null
    bountyLevel?: IntNullableFilter | number | null
    championExperience?: IntNullableFilter | number | null
    championLevel?: IntNullableFilter | number | null
    championId?: IntNullableFilter | number | null
    championName?: StringFilter | string
    championTransform?: IntNullableFilter | number | null
    consumablesPurchased?: IntNullableFilter | number | null
    damageDealtToBuildings?: IntNullableFilter | number | null
    damageDealtToObjectives?: IntNullableFilter | number | null
    damageDealtToTurrets?: IntNullableFilter | number | null
    damageSelfMitigated?: IntNullableFilter | number | null
    deaths?: IntNullableFilter | number | null
    detectorWardsPlaced?: IntNullableFilter | number | null
    doubleKills?: IntNullableFilter | number | null
    dragonKills?: IntNullableFilter | number | null
    firstBlood?: BoolFilter | boolean
    firstBloodAssist?: BoolFilter | boolean
    firstTowerKill?: BoolFilter | boolean
    firstTowerAssist?: BoolFilter | boolean
    gameEndedInEarlySurrender?: BoolFilter | boolean
    gameEndedInSurrender?: BoolFilter | boolean
    goldEarned?: IntNullableFilter | number | null
    goldSpent?: IntNullableFilter | number | null
    individualPosition?: StringFilter | string
    inhibitorKills?: IntNullableFilter | number | null
    inhibitorTakedowns?: IntNullableFilter | number | null
    inhibitorsLost?: IntNullableFilter | number | null
    item0?: IntNullableFilter | number | null
    item1?: IntNullableFilter | number | null
    item2?: IntNullableFilter | number | null
    item3?: IntNullableFilter | number | null
    item4?: IntNullableFilter | number | null
    item5?: IntNullableFilter | number | null
    item6?: IntNullableFilter | number | null
    itemsPurchased?: IntNullableFilter | number | null
    killingSprees?: IntNullableFilter | number | null
    kills?: IntNullableFilter | number | null
    lane?: StringFilter | string
    largestCriticalStrike?: IntNullableFilter | number | null
    largestKillingSpree?: IntNullableFilter | number | null
    largestMultiKill?: IntNullableFilter | number | null
    longestTimeSpentLiving?: IntNullableFilter | number | null
    magicDamageDealt?: IntNullableFilter | number | null
    magicDamageDealtToChampions?: IntNullableFilter | number | null
    magicDamageTaken?: IntNullableFilter | number | null
    neutralMinionsKilled?: IntNullableFilter | number | null
    nexusKills?: IntNullableFilter | number | null
    nexusLost?: IntNullableFilter | number | null
    nexusTakedowns?: IntNullableFilter | number | null
    objectivesStolen?: IntNullableFilter | number | null
    objectivesStolenAssists?: IntNullableFilter | number | null
    participantId?: IntNullableFilter | number | null
    pentaKills?: IntNullableFilter | number | null
    physicalDamageDealt?: IntNullableFilter | number | null
    physicalDamageDealtToChampions?: IntNullableFilter | number | null
    physicalDamageTaken?: IntNullableFilter | number | null
    quadraKills?: IntNullableFilter | number | null
    riotIdName?: StringFilter | string
    riotIdTagline?: StringFilter | string
    role?: StringFilter | string
    sightWardsBoughtInGame?: IntNullableFilter | number | null
    spell1Casts?: IntNullableFilter | number | null
    spell2Casts?: IntNullableFilter | number | null
    spell3Casts?: IntNullableFilter | number | null
    spell4Casts?: IntNullableFilter | number | null
    summoner1Casts?: IntNullableFilter | number | null
    summoner1Id?: IntNullableFilter | number | null
    summoner2Casts?: IntNullableFilter | number | null
    summoner2Id?: IntNullableFilter | number | null
    summonerLevel?: IntNullableFilter | number | null
    summonerName?: StringFilter | string
    teamEarlySurrendered?: BoolFilter | boolean
    teamId?: IntNullableFilter | number | null
    teamPosition?: StringFilter | string
    timeCCingOthers?: IntNullableFilter | number | null
    timePlayed?: IntNullableFilter | number | null
    totalDamageDealt?: IntNullableFilter | number | null
    totalDamageDealtToChampions?: IntNullableFilter | number | null
    totalDamageShieldedOnTeammates?: IntNullableFilter | number | null
    totalDamageTaken?: IntNullableFilter | number | null
    totalHeal?: IntNullableFilter | number | null
    totalHealsOnTeammates?: IntNullableFilter | number | null
    totalMinionsKilled?: IntNullableFilter | number | null
    totalTimeCCDealt?: IntNullableFilter | number | null
    totalTimeSpentDead?: IntNullableFilter | number | null
    totalUnitsHealed?: IntNullableFilter | number | null
    tripleKills?: IntNullableFilter | number | null
    trueDamageDealt?: IntNullableFilter | number | null
    trueDamageDealtToChampions?: IntNullableFilter | number | null
    trueDamageTaken?: IntNullableFilter | number | null
    turretsKilled?: IntNullableFilter | number | null
    turretTakedowns?: IntNullableFilter | number | null
    turretsLost?: IntNullableFilter | number | null
    unrealKills?: IntNullableFilter | number | null
    visionScore?: IntNullableFilter | number | null
    visionWardsBoughtInGame?: IntNullableFilter | number | null
    wardsKilled?: IntNullableFilter | number | null
    wardsPlaced?: IntNullableFilter | number | null
    win?: BoolFilter | boolean
  }

  export type PlayerEndOfGameStatOrderByWithRelationInput = {
    id?: SortOrder
    player?: PlayerOrderByWithRelationInput
    playerId?: SortOrder
    game?: GameOrderByWithRelationInput
    gameId?: SortOrder
    perks?: PlayerRuneOrderByWithRelationInput
    perksId?: SortOrder
    items?: PlayerItemOrderByWithRelationInput
    itemsId?: SortOrder
    assists?: SortOrder
    baronKills?: SortOrder
    bountyLevel?: SortOrder
    championExperience?: SortOrder
    championLevel?: SortOrder
    championId?: SortOrder
    championName?: SortOrder
    championTransform?: SortOrder
    consumablesPurchased?: SortOrder
    damageDealtToBuildings?: SortOrder
    damageDealtToObjectives?: SortOrder
    damageDealtToTurrets?: SortOrder
    damageSelfMitigated?: SortOrder
    deaths?: SortOrder
    detectorWardsPlaced?: SortOrder
    doubleKills?: SortOrder
    dragonKills?: SortOrder
    firstBlood?: SortOrder
    firstBloodAssist?: SortOrder
    firstTowerKill?: SortOrder
    firstTowerAssist?: SortOrder
    gameEndedInEarlySurrender?: SortOrder
    gameEndedInSurrender?: SortOrder
    goldEarned?: SortOrder
    goldSpent?: SortOrder
    individualPosition?: SortOrder
    inhibitorKills?: SortOrder
    inhibitorTakedowns?: SortOrder
    inhibitorsLost?: SortOrder
    item0?: SortOrder
    item1?: SortOrder
    item2?: SortOrder
    item3?: SortOrder
    item4?: SortOrder
    item5?: SortOrder
    item6?: SortOrder
    itemsPurchased?: SortOrder
    killingSprees?: SortOrder
    kills?: SortOrder
    lane?: SortOrder
    largestCriticalStrike?: SortOrder
    largestKillingSpree?: SortOrder
    largestMultiKill?: SortOrder
    longestTimeSpentLiving?: SortOrder
    magicDamageDealt?: SortOrder
    magicDamageDealtToChampions?: SortOrder
    magicDamageTaken?: SortOrder
    neutralMinionsKilled?: SortOrder
    nexusKills?: SortOrder
    nexusLost?: SortOrder
    nexusTakedowns?: SortOrder
    objectivesStolen?: SortOrder
    objectivesStolenAssists?: SortOrder
    participantId?: SortOrder
    pentaKills?: SortOrder
    physicalDamageDealt?: SortOrder
    physicalDamageDealtToChampions?: SortOrder
    physicalDamageTaken?: SortOrder
    quadraKills?: SortOrder
    riotIdName?: SortOrder
    riotIdTagline?: SortOrder
    role?: SortOrder
    sightWardsBoughtInGame?: SortOrder
    spell1Casts?: SortOrder
    spell2Casts?: SortOrder
    spell3Casts?: SortOrder
    spell4Casts?: SortOrder
    summoner1Casts?: SortOrder
    summoner1Id?: SortOrder
    summoner2Casts?: SortOrder
    summoner2Id?: SortOrder
    summonerLevel?: SortOrder
    summonerName?: SortOrder
    teamEarlySurrendered?: SortOrder
    teamId?: SortOrder
    teamPosition?: SortOrder
    timeCCingOthers?: SortOrder
    timePlayed?: SortOrder
    totalDamageDealt?: SortOrder
    totalDamageDealtToChampions?: SortOrder
    totalDamageShieldedOnTeammates?: SortOrder
    totalDamageTaken?: SortOrder
    totalHeal?: SortOrder
    totalHealsOnTeammates?: SortOrder
    totalMinionsKilled?: SortOrder
    totalTimeCCDealt?: SortOrder
    totalTimeSpentDead?: SortOrder
    totalUnitsHealed?: SortOrder
    tripleKills?: SortOrder
    trueDamageDealt?: SortOrder
    trueDamageDealtToChampions?: SortOrder
    trueDamageTaken?: SortOrder
    turretsKilled?: SortOrder
    turretTakedowns?: SortOrder
    turretsLost?: SortOrder
    unrealKills?: SortOrder
    visionScore?: SortOrder
    visionWardsBoughtInGame?: SortOrder
    wardsKilled?: SortOrder
    wardsPlaced?: SortOrder
    win?: SortOrder
  }

  export type PlayerEndOfGameStatWhereUniqueInput = {
    id?: string
    perksId?: string
  }

  export type PlayerEndOfGameStatOrderByWithAggregationInput = {
    id?: SortOrder
    playerId?: SortOrder
    gameId?: SortOrder
    perksId?: SortOrder
    itemsId?: SortOrder
    assists?: SortOrder
    baronKills?: SortOrder
    bountyLevel?: SortOrder
    championExperience?: SortOrder
    championLevel?: SortOrder
    championId?: SortOrder
    championName?: SortOrder
    championTransform?: SortOrder
    consumablesPurchased?: SortOrder
    damageDealtToBuildings?: SortOrder
    damageDealtToObjectives?: SortOrder
    damageDealtToTurrets?: SortOrder
    damageSelfMitigated?: SortOrder
    deaths?: SortOrder
    detectorWardsPlaced?: SortOrder
    doubleKills?: SortOrder
    dragonKills?: SortOrder
    firstBlood?: SortOrder
    firstBloodAssist?: SortOrder
    firstTowerKill?: SortOrder
    firstTowerAssist?: SortOrder
    gameEndedInEarlySurrender?: SortOrder
    gameEndedInSurrender?: SortOrder
    goldEarned?: SortOrder
    goldSpent?: SortOrder
    individualPosition?: SortOrder
    inhibitorKills?: SortOrder
    inhibitorTakedowns?: SortOrder
    inhibitorsLost?: SortOrder
    item0?: SortOrder
    item1?: SortOrder
    item2?: SortOrder
    item3?: SortOrder
    item4?: SortOrder
    item5?: SortOrder
    item6?: SortOrder
    itemsPurchased?: SortOrder
    killingSprees?: SortOrder
    kills?: SortOrder
    lane?: SortOrder
    largestCriticalStrike?: SortOrder
    largestKillingSpree?: SortOrder
    largestMultiKill?: SortOrder
    longestTimeSpentLiving?: SortOrder
    magicDamageDealt?: SortOrder
    magicDamageDealtToChampions?: SortOrder
    magicDamageTaken?: SortOrder
    neutralMinionsKilled?: SortOrder
    nexusKills?: SortOrder
    nexusLost?: SortOrder
    nexusTakedowns?: SortOrder
    objectivesStolen?: SortOrder
    objectivesStolenAssists?: SortOrder
    participantId?: SortOrder
    pentaKills?: SortOrder
    physicalDamageDealt?: SortOrder
    physicalDamageDealtToChampions?: SortOrder
    physicalDamageTaken?: SortOrder
    quadraKills?: SortOrder
    riotIdName?: SortOrder
    riotIdTagline?: SortOrder
    role?: SortOrder
    sightWardsBoughtInGame?: SortOrder
    spell1Casts?: SortOrder
    spell2Casts?: SortOrder
    spell3Casts?: SortOrder
    spell4Casts?: SortOrder
    summoner1Casts?: SortOrder
    summoner1Id?: SortOrder
    summoner2Casts?: SortOrder
    summoner2Id?: SortOrder
    summonerLevel?: SortOrder
    summonerName?: SortOrder
    teamEarlySurrendered?: SortOrder
    teamId?: SortOrder
    teamPosition?: SortOrder
    timeCCingOthers?: SortOrder
    timePlayed?: SortOrder
    totalDamageDealt?: SortOrder
    totalDamageDealtToChampions?: SortOrder
    totalDamageShieldedOnTeammates?: SortOrder
    totalDamageTaken?: SortOrder
    totalHeal?: SortOrder
    totalHealsOnTeammates?: SortOrder
    totalMinionsKilled?: SortOrder
    totalTimeCCDealt?: SortOrder
    totalTimeSpentDead?: SortOrder
    totalUnitsHealed?: SortOrder
    tripleKills?: SortOrder
    trueDamageDealt?: SortOrder
    trueDamageDealtToChampions?: SortOrder
    trueDamageTaken?: SortOrder
    turretsKilled?: SortOrder
    turretTakedowns?: SortOrder
    turretsLost?: SortOrder
    unrealKills?: SortOrder
    visionScore?: SortOrder
    visionWardsBoughtInGame?: SortOrder
    wardsKilled?: SortOrder
    wardsPlaced?: SortOrder
    win?: SortOrder
    _count?: PlayerEndOfGameStatCountOrderByAggregateInput
    _avg?: PlayerEndOfGameStatAvgOrderByAggregateInput
    _max?: PlayerEndOfGameStatMaxOrderByAggregateInput
    _min?: PlayerEndOfGameStatMinOrderByAggregateInput
    _sum?: PlayerEndOfGameStatSumOrderByAggregateInput
  }

  export type PlayerEndOfGameStatScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PlayerEndOfGameStatScalarWhereWithAggregatesInput>
    OR?: Enumerable<PlayerEndOfGameStatScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PlayerEndOfGameStatScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    playerId?: StringNullableWithAggregatesFilter | string | null
    gameId?: StringNullableWithAggregatesFilter | string | null
    perksId?: StringNullableWithAggregatesFilter | string | null
    itemsId?: StringNullableWithAggregatesFilter | string | null
    assists?: IntNullableWithAggregatesFilter | number | null
    baronKills?: IntNullableWithAggregatesFilter | number | null
    bountyLevel?: IntNullableWithAggregatesFilter | number | null
    championExperience?: IntNullableWithAggregatesFilter | number | null
    championLevel?: IntNullableWithAggregatesFilter | number | null
    championId?: IntNullableWithAggregatesFilter | number | null
    championName?: StringWithAggregatesFilter | string
    championTransform?: IntNullableWithAggregatesFilter | number | null
    consumablesPurchased?: IntNullableWithAggregatesFilter | number | null
    damageDealtToBuildings?: IntNullableWithAggregatesFilter | number | null
    damageDealtToObjectives?: IntNullableWithAggregatesFilter | number | null
    damageDealtToTurrets?: IntNullableWithAggregatesFilter | number | null
    damageSelfMitigated?: IntNullableWithAggregatesFilter | number | null
    deaths?: IntNullableWithAggregatesFilter | number | null
    detectorWardsPlaced?: IntNullableWithAggregatesFilter | number | null
    doubleKills?: IntNullableWithAggregatesFilter | number | null
    dragonKills?: IntNullableWithAggregatesFilter | number | null
    firstBlood?: BoolWithAggregatesFilter | boolean
    firstBloodAssist?: BoolWithAggregatesFilter | boolean
    firstTowerKill?: BoolWithAggregatesFilter | boolean
    firstTowerAssist?: BoolWithAggregatesFilter | boolean
    gameEndedInEarlySurrender?: BoolWithAggregatesFilter | boolean
    gameEndedInSurrender?: BoolWithAggregatesFilter | boolean
    goldEarned?: IntNullableWithAggregatesFilter | number | null
    goldSpent?: IntNullableWithAggregatesFilter | number | null
    individualPosition?: StringWithAggregatesFilter | string
    inhibitorKills?: IntNullableWithAggregatesFilter | number | null
    inhibitorTakedowns?: IntNullableWithAggregatesFilter | number | null
    inhibitorsLost?: IntNullableWithAggregatesFilter | number | null
    item0?: IntNullableWithAggregatesFilter | number | null
    item1?: IntNullableWithAggregatesFilter | number | null
    item2?: IntNullableWithAggregatesFilter | number | null
    item3?: IntNullableWithAggregatesFilter | number | null
    item4?: IntNullableWithAggregatesFilter | number | null
    item5?: IntNullableWithAggregatesFilter | number | null
    item6?: IntNullableWithAggregatesFilter | number | null
    itemsPurchased?: IntNullableWithAggregatesFilter | number | null
    killingSprees?: IntNullableWithAggregatesFilter | number | null
    kills?: IntNullableWithAggregatesFilter | number | null
    lane?: StringWithAggregatesFilter | string
    largestCriticalStrike?: IntNullableWithAggregatesFilter | number | null
    largestKillingSpree?: IntNullableWithAggregatesFilter | number | null
    largestMultiKill?: IntNullableWithAggregatesFilter | number | null
    longestTimeSpentLiving?: IntNullableWithAggregatesFilter | number | null
    magicDamageDealt?: IntNullableWithAggregatesFilter | number | null
    magicDamageDealtToChampions?: IntNullableWithAggregatesFilter | number | null
    magicDamageTaken?: IntNullableWithAggregatesFilter | number | null
    neutralMinionsKilled?: IntNullableWithAggregatesFilter | number | null
    nexusKills?: IntNullableWithAggregatesFilter | number | null
    nexusLost?: IntNullableWithAggregatesFilter | number | null
    nexusTakedowns?: IntNullableWithAggregatesFilter | number | null
    objectivesStolen?: IntNullableWithAggregatesFilter | number | null
    objectivesStolenAssists?: IntNullableWithAggregatesFilter | number | null
    participantId?: IntNullableWithAggregatesFilter | number | null
    pentaKills?: IntNullableWithAggregatesFilter | number | null
    physicalDamageDealt?: IntNullableWithAggregatesFilter | number | null
    physicalDamageDealtToChampions?: IntNullableWithAggregatesFilter | number | null
    physicalDamageTaken?: IntNullableWithAggregatesFilter | number | null
    quadraKills?: IntNullableWithAggregatesFilter | number | null
    riotIdName?: StringWithAggregatesFilter | string
    riotIdTagline?: StringWithAggregatesFilter | string
    role?: StringWithAggregatesFilter | string
    sightWardsBoughtInGame?: IntNullableWithAggregatesFilter | number | null
    spell1Casts?: IntNullableWithAggregatesFilter | number | null
    spell2Casts?: IntNullableWithAggregatesFilter | number | null
    spell3Casts?: IntNullableWithAggregatesFilter | number | null
    spell4Casts?: IntNullableWithAggregatesFilter | number | null
    summoner1Casts?: IntNullableWithAggregatesFilter | number | null
    summoner1Id?: IntNullableWithAggregatesFilter | number | null
    summoner2Casts?: IntNullableWithAggregatesFilter | number | null
    summoner2Id?: IntNullableWithAggregatesFilter | number | null
    summonerLevel?: IntNullableWithAggregatesFilter | number | null
    summonerName?: StringWithAggregatesFilter | string
    teamEarlySurrendered?: BoolWithAggregatesFilter | boolean
    teamId?: IntNullableWithAggregatesFilter | number | null
    teamPosition?: StringWithAggregatesFilter | string
    timeCCingOthers?: IntNullableWithAggregatesFilter | number | null
    timePlayed?: IntNullableWithAggregatesFilter | number | null
    totalDamageDealt?: IntNullableWithAggregatesFilter | number | null
    totalDamageDealtToChampions?: IntNullableWithAggregatesFilter | number | null
    totalDamageShieldedOnTeammates?: IntNullableWithAggregatesFilter | number | null
    totalDamageTaken?: IntNullableWithAggregatesFilter | number | null
    totalHeal?: IntNullableWithAggregatesFilter | number | null
    totalHealsOnTeammates?: IntNullableWithAggregatesFilter | number | null
    totalMinionsKilled?: IntNullableWithAggregatesFilter | number | null
    totalTimeCCDealt?: IntNullableWithAggregatesFilter | number | null
    totalTimeSpentDead?: IntNullableWithAggregatesFilter | number | null
    totalUnitsHealed?: IntNullableWithAggregatesFilter | number | null
    tripleKills?: IntNullableWithAggregatesFilter | number | null
    trueDamageDealt?: IntNullableWithAggregatesFilter | number | null
    trueDamageDealtToChampions?: IntNullableWithAggregatesFilter | number | null
    trueDamageTaken?: IntNullableWithAggregatesFilter | number | null
    turretsKilled?: IntNullableWithAggregatesFilter | number | null
    turretTakedowns?: IntNullableWithAggregatesFilter | number | null
    turretsLost?: IntNullableWithAggregatesFilter | number | null
    unrealKills?: IntNullableWithAggregatesFilter | number | null
    visionScore?: IntNullableWithAggregatesFilter | number | null
    visionWardsBoughtInGame?: IntNullableWithAggregatesFilter | number | null
    wardsKilled?: IntNullableWithAggregatesFilter | number | null
    wardsPlaced?: IntNullableWithAggregatesFilter | number | null
    win?: BoolWithAggregatesFilter | boolean
  }

  export type PlayerItemWhereInput = {
    AND?: Enumerable<PlayerItemWhereInput>
    OR?: Enumerable<PlayerItemWhereInput>
    NOT?: Enumerable<PlayerItemWhereInput>
    id?: StringFilter | string
    slot?: IntNullableFilter | number | null
    itemId?: IntNullableFilter | number | null
    name?: StringFilter | string
    playerEndOfGameStat?: PlayerEndOfGameStatListRelationFilter
  }

  export type PlayerItemOrderByWithRelationInput = {
    id?: SortOrder
    slot?: SortOrder
    itemId?: SortOrder
    name?: SortOrder
    playerEndOfGameStat?: PlayerEndOfGameStatOrderByRelationAggregateInput
  }

  export type PlayerItemWhereUniqueInput = {
    id?: string
  }

  export type PlayerItemOrderByWithAggregationInput = {
    id?: SortOrder
    slot?: SortOrder
    itemId?: SortOrder
    name?: SortOrder
    _count?: PlayerItemCountOrderByAggregateInput
    _avg?: PlayerItemAvgOrderByAggregateInput
    _max?: PlayerItemMaxOrderByAggregateInput
    _min?: PlayerItemMinOrderByAggregateInput
    _sum?: PlayerItemSumOrderByAggregateInput
  }

  export type PlayerItemScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PlayerItemScalarWhereWithAggregatesInput>
    OR?: Enumerable<PlayerItemScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PlayerItemScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    slot?: IntNullableWithAggregatesFilter | number | null
    itemId?: IntNullableWithAggregatesFilter | number | null
    name?: StringWithAggregatesFilter | string
  }

  export type PlayerItemEventWhereInput = {
    AND?: Enumerable<PlayerItemEventWhereInput>
    OR?: Enumerable<PlayerItemEventWhereInput>
    NOT?: Enumerable<PlayerItemEventWhereInput>
    id?: StringFilter | string
    player?: PlayerListRelationFilter
    type?: StringFilter | string
    itemId?: IntNullableFilter | number | null
    name?: StringFilter | string
    undoId?: IntNullableFilter | number | null
  }

  export type PlayerItemEventOrderByWithRelationInput = {
    id?: SortOrder
    player?: PlayerOrderByRelationAggregateInput
    type?: SortOrder
    itemId?: SortOrder
    name?: SortOrder
    undoId?: SortOrder
  }

  export type PlayerItemEventWhereUniqueInput = {
    id?: string
  }

  export type PlayerItemEventOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    itemId?: SortOrder
    name?: SortOrder
    undoId?: SortOrder
    _count?: PlayerItemEventCountOrderByAggregateInput
    _avg?: PlayerItemEventAvgOrderByAggregateInput
    _max?: PlayerItemEventMaxOrderByAggregateInput
    _min?: PlayerItemEventMinOrderByAggregateInput
    _sum?: PlayerItemEventSumOrderByAggregateInput
  }

  export type PlayerItemEventScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PlayerItemEventScalarWhereWithAggregatesInput>
    OR?: Enumerable<PlayerItemEventScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PlayerItemEventScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    type?: StringWithAggregatesFilter | string
    itemId?: IntNullableWithAggregatesFilter | number | null
    name?: StringWithAggregatesFilter | string
    undoId?: IntNullableWithAggregatesFilter | number | null
  }

  export type PlayerKillWhereInput = {
    AND?: Enumerable<PlayerKillWhereInput>
    OR?: Enumerable<PlayerKillWhereInput>
    NOT?: Enumerable<PlayerKillWhereInput>
    id?: StringFilter | string
    killer?: PlayerListRelationFilter
    victim?: PlayerListRelationFilter
  }

  export type PlayerKillOrderByWithRelationInput = {
    id?: SortOrder
    killer?: PlayerOrderByRelationAggregateInput
    victim?: PlayerOrderByRelationAggregateInput
  }

  export type PlayerKillWhereUniqueInput = {
    id?: string
  }

  export type PlayerKillOrderByWithAggregationInput = {
    id?: SortOrder
    _count?: PlayerKillCountOrderByAggregateInput
    _max?: PlayerKillMaxOrderByAggregateInput
    _min?: PlayerKillMinOrderByAggregateInput
  }

  export type PlayerKillScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PlayerKillScalarWhereWithAggregatesInput>
    OR?: Enumerable<PlayerKillScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PlayerKillScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
  }

  export type PlayerRuneWhereInput = {
    AND?: Enumerable<PlayerRuneWhereInput>
    OR?: Enumerable<PlayerRuneWhereInput>
    NOT?: Enumerable<PlayerRuneWhereInput>
    id?: StringFilter | string
    playerEndOfGameStat?: XOR<PlayerEndOfGameStatRelationFilter, PlayerEndOfGameStatWhereInput> | null
    runeStyle?: RuneStyleListRelationFilter
    defense?: IntNullableFilter | number | null
    flex?: IntNullableFilter | number | null
    offense?: IntNullableFilter | number | null
  }

  export type PlayerRuneOrderByWithRelationInput = {
    id?: SortOrder
    playerEndOfGameStat?: PlayerEndOfGameStatOrderByWithRelationInput
    runeStyle?: RuneStyleOrderByRelationAggregateInput
    defense?: SortOrder
    flex?: SortOrder
    offense?: SortOrder
  }

  export type PlayerRuneWhereUniqueInput = {
    id?: string
  }

  export type PlayerRuneOrderByWithAggregationInput = {
    id?: SortOrder
    defense?: SortOrder
    flex?: SortOrder
    offense?: SortOrder
    _count?: PlayerRuneCountOrderByAggregateInput
    _avg?: PlayerRuneAvgOrderByAggregateInput
    _max?: PlayerRuneMaxOrderByAggregateInput
    _min?: PlayerRuneMinOrderByAggregateInput
    _sum?: PlayerRuneSumOrderByAggregateInput
  }

  export type PlayerRuneScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PlayerRuneScalarWhereWithAggregatesInput>
    OR?: Enumerable<PlayerRuneScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PlayerRuneScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    defense?: IntNullableWithAggregatesFilter | number | null
    flex?: IntNullableWithAggregatesFilter | number | null
    offense?: IntNullableWithAggregatesFilter | number | null
  }

  export type PlayerSkillLevelUpEventWhereInput = {
    AND?: Enumerable<PlayerSkillLevelUpEventWhereInput>
    OR?: Enumerable<PlayerSkillLevelUpEventWhereInput>
    NOT?: Enumerable<PlayerSkillLevelUpEventWhereInput>
    id?: StringFilter | string
    player?: PlayerListRelationFilter
    type?: StringFilter | string
    slot?: IntNullableFilter | number | null
  }

  export type PlayerSkillLevelUpEventOrderByWithRelationInput = {
    id?: SortOrder
    player?: PlayerOrderByRelationAggregateInput
    type?: SortOrder
    slot?: SortOrder
  }

  export type PlayerSkillLevelUpEventWhereUniqueInput = {
    id?: string
  }

  export type PlayerSkillLevelUpEventOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    slot?: SortOrder
    _count?: PlayerSkillLevelUpEventCountOrderByAggregateInput
    _avg?: PlayerSkillLevelUpEventAvgOrderByAggregateInput
    _max?: PlayerSkillLevelUpEventMaxOrderByAggregateInput
    _min?: PlayerSkillLevelUpEventMinOrderByAggregateInput
    _sum?: PlayerSkillLevelUpEventSumOrderByAggregateInput
  }

  export type PlayerSkillLevelUpEventScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PlayerSkillLevelUpEventScalarWhereWithAggregatesInput>
    OR?: Enumerable<PlayerSkillLevelUpEventScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PlayerSkillLevelUpEventScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    type?: StringWithAggregatesFilter | string
    slot?: IntNullableWithAggregatesFilter | number | null
  }

  export type PlayerSnapshotWhereInput = {
    AND?: Enumerable<PlayerSnapshotWhereInput>
    OR?: Enumerable<PlayerSnapshotWhereInput>
    NOT?: Enumerable<PlayerSnapshotWhereInput>
    id?: StringFilter | string
    timestamp?: FloatNullableFilter | number | null
    currentGold?: IntNullableFilter | number | null
    totalGold?: IntNullableFilter | number | null
    totalGoldDiff?: IntNullableFilter | number | null
    xp?: IntNullableFilter | number | null
    xpDiff?: IntNullableFilter | number | null
    level?: IntNullableFilter | number | null
    cs?: IntNullableFilter | number | null
    csDiff?: IntNullableFilter | number | null
    monstersKilled?: IntNullableFilter | number | null
    monstersKilledDiff?: IntNullableFilter | number | null
    position?: PositionListRelationFilter
    player?: PlayerListRelationFilter
  }

  export type PlayerSnapshotOrderByWithRelationInput = {
    id?: SortOrder
    timestamp?: SortOrder
    currentGold?: SortOrder
    totalGold?: SortOrder
    totalGoldDiff?: SortOrder
    xp?: SortOrder
    xpDiff?: SortOrder
    level?: SortOrder
    cs?: SortOrder
    csDiff?: SortOrder
    monstersKilled?: SortOrder
    monstersKilledDiff?: SortOrder
    position?: PositionOrderByRelationAggregateInput
    player?: PlayerOrderByRelationAggregateInput
  }

  export type PlayerSnapshotWhereUniqueInput = {
    id?: string
  }

  export type PlayerSnapshotOrderByWithAggregationInput = {
    id?: SortOrder
    timestamp?: SortOrder
    currentGold?: SortOrder
    totalGold?: SortOrder
    totalGoldDiff?: SortOrder
    xp?: SortOrder
    xpDiff?: SortOrder
    level?: SortOrder
    cs?: SortOrder
    csDiff?: SortOrder
    monstersKilled?: SortOrder
    monstersKilledDiff?: SortOrder
    _count?: PlayerSnapshotCountOrderByAggregateInput
    _avg?: PlayerSnapshotAvgOrderByAggregateInput
    _max?: PlayerSnapshotMaxOrderByAggregateInput
    _min?: PlayerSnapshotMinOrderByAggregateInput
    _sum?: PlayerSnapshotSumOrderByAggregateInput
  }

  export type PlayerSnapshotScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PlayerSnapshotScalarWhereWithAggregatesInput>
    OR?: Enumerable<PlayerSnapshotScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PlayerSnapshotScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    timestamp?: FloatNullableWithAggregatesFilter | number | null
    currentGold?: IntNullableWithAggregatesFilter | number | null
    totalGold?: IntNullableWithAggregatesFilter | number | null
    totalGoldDiff?: IntNullableWithAggregatesFilter | number | null
    xp?: IntNullableWithAggregatesFilter | number | null
    xpDiff?: IntNullableWithAggregatesFilter | number | null
    level?: IntNullableWithAggregatesFilter | number | null
    cs?: IntNullableWithAggregatesFilter | number | null
    csDiff?: IntNullableWithAggregatesFilter | number | null
    monstersKilled?: IntNullableWithAggregatesFilter | number | null
    monstersKilledDiff?: IntNullableWithAggregatesFilter | number | null
  }

  export type PlayerWardEventWhereInput = {
    AND?: Enumerable<PlayerWardEventWhereInput>
    OR?: Enumerable<PlayerWardEventWhereInput>
    NOT?: Enumerable<PlayerWardEventWhereInput>
    id?: StringFilter | string
    player?: PlayerListRelationFilter
    type?: StringFilter | string
    wardType?: EnumPlayerWardEventWardTypeTypeNullableFilter | PlayerWardEventWardTypeType | null
  }

  export type PlayerWardEventOrderByWithRelationInput = {
    id?: SortOrder
    player?: PlayerOrderByRelationAggregateInput
    type?: SortOrder
    wardType?: SortOrder
  }

  export type PlayerWardEventWhereUniqueInput = {
    id?: string
  }

  export type PlayerWardEventOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    wardType?: SortOrder
    _count?: PlayerWardEventCountOrderByAggregateInput
    _max?: PlayerWardEventMaxOrderByAggregateInput
    _min?: PlayerWardEventMinOrderByAggregateInput
  }

  export type PlayerWardEventScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PlayerWardEventScalarWhereWithAggregatesInput>
    OR?: Enumerable<PlayerWardEventScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PlayerWardEventScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    type?: StringWithAggregatesFilter | string
    wardType?: EnumPlayerWardEventWardTypeTypeNullableWithAggregatesFilter | PlayerWardEventWardTypeType | null
  }

  export type PositionWhereInput = {
    AND?: Enumerable<PositionWhereInput>
    OR?: Enumerable<PositionWhereInput>
    NOT?: Enumerable<PositionWhereInput>
    id?: StringFilter | string
    event?: EventListRelationFilter
    x?: IntNullableFilter | number | null
    y?: IntNullableFilter | number | null
    playerSnapshot?: PlayerSnapshotListRelationFilter
  }

  export type PositionOrderByWithRelationInput = {
    id?: SortOrder
    event?: EventOrderByRelationAggregateInput
    x?: SortOrder
    y?: SortOrder
    playerSnapshot?: PlayerSnapshotOrderByRelationAggregateInput
  }

  export type PositionWhereUniqueInput = {
    id?: string
  }

  export type PositionOrderByWithAggregationInput = {
    id?: SortOrder
    x?: SortOrder
    y?: SortOrder
    _count?: PositionCountOrderByAggregateInput
    _avg?: PositionAvgOrderByAggregateInput
    _max?: PositionMaxOrderByAggregateInput
    _min?: PositionMinOrderByAggregateInput
    _sum?: PositionSumOrderByAggregateInput
  }

  export type PositionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PositionScalarWhereWithAggregatesInput>
    OR?: Enumerable<PositionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PositionScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    x?: IntNullableWithAggregatesFilter | number | null
    y?: IntNullableWithAggregatesFilter | number | null
  }

  export type ProfileWhereInput = {
    AND?: Enumerable<ProfileWhereInput>
    OR?: Enumerable<ProfileWhereInput>
    NOT?: Enumerable<ProfileWhereInput>
    id?: StringFilter | string
    update?: BoolFilter | boolean
    player?: XOR<PlayerRelationFilter, PlayerWhereInput> | null
    lastUpdate?: DateTimeFilter | Date | string
    kills?: IntNullableFilter | number | null
    deaths?: IntNullableFilter | number | null
    assists?: IntNullableFilter | number | null
    kda?: StringFilter | string
    winRate?: StringFilter | string
    csPerMinute?: StringFilter | string
    damagePerMinute?: StringFilter | string
    killsPerMinute?: StringFilter | string
    goldPerMinute?: StringFilter | string
    averageGameTime?: StringFilter | string
    averageTimeSpentDead?: StringFilter | string
    totalGameTime?: StringFilter | string
    activity?: ActivityListRelationFilter
    championWinrate?: ChampionWinrateListRelationFilter
    duos?: DuoListRelationFilter
  }

  export type ProfileOrderByWithRelationInput = {
    id?: SortOrder
    update?: SortOrder
    player?: PlayerOrderByWithRelationInput
    lastUpdate?: SortOrder
    kills?: SortOrder
    deaths?: SortOrder
    assists?: SortOrder
    kda?: SortOrder
    winRate?: SortOrder
    csPerMinute?: SortOrder
    damagePerMinute?: SortOrder
    killsPerMinute?: SortOrder
    goldPerMinute?: SortOrder
    averageGameTime?: SortOrder
    averageTimeSpentDead?: SortOrder
    totalGameTime?: SortOrder
    activity?: ActivityOrderByRelationAggregateInput
    championWinrate?: ChampionWinrateOrderByRelationAggregateInput
    duos?: DuoOrderByRelationAggregateInput
  }

  export type ProfileWhereUniqueInput = {
    id?: string
  }

  export type ProfileOrderByWithAggregationInput = {
    id?: SortOrder
    update?: SortOrder
    lastUpdate?: SortOrder
    kills?: SortOrder
    deaths?: SortOrder
    assists?: SortOrder
    kda?: SortOrder
    winRate?: SortOrder
    csPerMinute?: SortOrder
    damagePerMinute?: SortOrder
    killsPerMinute?: SortOrder
    goldPerMinute?: SortOrder
    averageGameTime?: SortOrder
    averageTimeSpentDead?: SortOrder
    totalGameTime?: SortOrder
    _count?: ProfileCountOrderByAggregateInput
    _avg?: ProfileAvgOrderByAggregateInput
    _max?: ProfileMaxOrderByAggregateInput
    _min?: ProfileMinOrderByAggregateInput
    _sum?: ProfileSumOrderByAggregateInput
  }

  export type ProfileScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ProfileScalarWhereWithAggregatesInput>
    OR?: Enumerable<ProfileScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ProfileScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    update?: BoolWithAggregatesFilter | boolean
    lastUpdate?: DateTimeWithAggregatesFilter | Date | string
    kills?: IntNullableWithAggregatesFilter | number | null
    deaths?: IntNullableWithAggregatesFilter | number | null
    assists?: IntNullableWithAggregatesFilter | number | null
    kda?: StringWithAggregatesFilter | string
    winRate?: StringWithAggregatesFilter | string
    csPerMinute?: StringWithAggregatesFilter | string
    damagePerMinute?: StringWithAggregatesFilter | string
    killsPerMinute?: StringWithAggregatesFilter | string
    goldPerMinute?: StringWithAggregatesFilter | string
    averageGameTime?: StringWithAggregatesFilter | string
    averageTimeSpentDead?: StringWithAggregatesFilter | string
    totalGameTime?: StringWithAggregatesFilter | string
  }

  export type SeedIdentifierWhereInput = {
    AND?: Enumerable<SeedIdentifierWhereInput>
    OR?: Enumerable<SeedIdentifierWhereInput>
    NOT?: Enumerable<SeedIdentifierWhereInput>
    id?: StringFilter | string
    identifier?: StringFilter | string
    type?: StringFilter | string
    timestamp?: DateTimeFilter | Date | string
    priority?: BoolFilter | boolean
    retrieved?: BoolFilter | boolean
  }

  export type SeedIdentifierOrderByWithRelationInput = {
    id?: SortOrder
    identifier?: SortOrder
    type?: SortOrder
    timestamp?: SortOrder
    priority?: SortOrder
    retrieved?: SortOrder
  }

  export type SeedIdentifierWhereUniqueInput = {
    id?: string
    identifier?: string
  }

  export type SeedIdentifierOrderByWithAggregationInput = {
    id?: SortOrder
    identifier?: SortOrder
    type?: SortOrder
    timestamp?: SortOrder
    priority?: SortOrder
    retrieved?: SortOrder
    _count?: SeedIdentifierCountOrderByAggregateInput
    _max?: SeedIdentifierMaxOrderByAggregateInput
    _min?: SeedIdentifierMinOrderByAggregateInput
  }

  export type SeedIdentifierScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SeedIdentifierScalarWhereWithAggregatesInput>
    OR?: Enumerable<SeedIdentifierScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SeedIdentifierScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    identifier?: StringWithAggregatesFilter | string
    type?: StringWithAggregatesFilter | string
    timestamp?: DateTimeWithAggregatesFilter | Date | string
    priority?: BoolWithAggregatesFilter | boolean
    retrieved?: BoolWithAggregatesFilter | boolean
  }

  export type SourceWhereInput = {
    AND?: Enumerable<SourceWhereInput>
    OR?: Enumerable<SourceWhereInput>
    NOT?: Enumerable<SourceWhereInput>
    id?: StringFilter | string
    game?: GameListRelationFilter
    api?: StringFilter | string
  }

  export type SourceOrderByWithRelationInput = {
    id?: SortOrder
    game?: GameOrderByRelationAggregateInput
    api?: SortOrder
  }

  export type SourceWhereUniqueInput = {
    id?: string
  }

  export type SourceOrderByWithAggregationInput = {
    id?: SortOrder
    api?: SortOrder
    _count?: SourceCountOrderByAggregateInput
    _max?: SourceMaxOrderByAggregateInput
    _min?: SourceMinOrderByAggregateInput
  }

  export type SourceScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SourceScalarWhereWithAggregatesInput>
    OR?: Enumerable<SourceScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SourceScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    api?: StringWithAggregatesFilter | string
  }

  export type TeamWhereInput = {
    AND?: Enumerable<TeamWhereInput>
    OR?: Enumerable<TeamWhereInput>
    NOT?: Enumerable<TeamWhereInput>
    id?: StringFilter | string
    pickBan?: PickBanListRelationFilter
    game?: XOR<GameRelationFilter, GameWhereInput> | null
    gameId?: StringNullableFilter | string | null
    players?: PlayerListRelationFilter
    objectives?: ObjectiveListRelationFilter
    teamId?: IntNullableFilter | number | null
    teamMatchId?: StringFilter | string
    win?: BoolFilter | boolean
    from_Game_blueTeam?: GameListRelationFilter
    from_Game_redTeam?: GameListRelationFilter
  }

  export type TeamOrderByWithRelationInput = {
    id?: SortOrder
    pickBan?: PickBanOrderByRelationAggregateInput
    game?: GameOrderByWithRelationInput
    gameId?: SortOrder
    players?: PlayerOrderByRelationAggregateInput
    objectives?: ObjectiveOrderByRelationAggregateInput
    teamId?: SortOrder
    teamMatchId?: SortOrder
    win?: SortOrder
    from_Game_blueTeam?: GameOrderByRelationAggregateInput
    from_Game_redTeam?: GameOrderByRelationAggregateInput
  }

  export type TeamWhereUniqueInput = {
    id?: string
    teamMatchId?: string
  }

  export type TeamOrderByWithAggregationInput = {
    id?: SortOrder
    gameId?: SortOrder
    teamId?: SortOrder
    teamMatchId?: SortOrder
    win?: SortOrder
    _count?: TeamCountOrderByAggregateInput
    _avg?: TeamAvgOrderByAggregateInput
    _max?: TeamMaxOrderByAggregateInput
    _min?: TeamMinOrderByAggregateInput
    _sum?: TeamSumOrderByAggregateInput
  }

  export type TeamScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TeamScalarWhereWithAggregatesInput>
    OR?: Enumerable<TeamScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TeamScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    gameId?: StringNullableWithAggregatesFilter | string | null
    teamId?: IntNullableWithAggregatesFilter | number | null
    teamMatchId?: StringWithAggregatesFilter | string
    win?: BoolWithAggregatesFilter | boolean
  }

  export type TeamBuildingKillWhereInput = {
    AND?: Enumerable<TeamBuildingKillWhereInput>
    OR?: Enumerable<TeamBuildingKillWhereInput>
    NOT?: Enumerable<TeamBuildingKillWhereInput>
    id?: StringFilter | string
    killer?: PlayerListRelationFilter
    type?: StringFilter | string
    lane?: StringFilter | string
    side?: StringFilter | string
    towerLocation?: StringFilter | string
  }

  export type TeamBuildingKillOrderByWithRelationInput = {
    id?: SortOrder
    killer?: PlayerOrderByRelationAggregateInput
    type?: SortOrder
    lane?: SortOrder
    side?: SortOrder
    towerLocation?: SortOrder
  }

  export type TeamBuildingKillWhereUniqueInput = {
    id?: string
  }

  export type TeamBuildingKillOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    lane?: SortOrder
    side?: SortOrder
    towerLocation?: SortOrder
    _count?: TeamBuildingKillCountOrderByAggregateInput
    _max?: TeamBuildingKillMaxOrderByAggregateInput
    _min?: TeamBuildingKillMinOrderByAggregateInput
  }

  export type TeamBuildingKillScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TeamBuildingKillScalarWhereWithAggregatesInput>
    OR?: Enumerable<TeamBuildingKillScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TeamBuildingKillScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    type?: StringWithAggregatesFilter | string
    lane?: StringWithAggregatesFilter | string
    side?: StringWithAggregatesFilter | string
    towerLocation?: StringWithAggregatesFilter | string
  }

  export type TeamMonsterKillWhereInput = {
    AND?: Enumerable<TeamMonsterKillWhereInput>
    OR?: Enumerable<TeamMonsterKillWhereInput>
    NOT?: Enumerable<TeamMonsterKillWhereInput>
    id?: StringFilter | string
    killer?: PlayerListRelationFilter
    type?: StringFilter | string
    subType?: StringFilter | string
  }

  export type TeamMonsterKillOrderByWithRelationInput = {
    id?: SortOrder
    killer?: PlayerOrderByRelationAggregateInput
    type?: SortOrder
    subType?: SortOrder
  }

  export type TeamMonsterKillWhereUniqueInput = {
    id?: string
  }

  export type TeamMonsterKillOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    subType?: SortOrder
    _count?: TeamMonsterKillCountOrderByAggregateInput
    _max?: TeamMonsterKillMaxOrderByAggregateInput
    _min?: TeamMonsterKillMinOrderByAggregateInput
  }

  export type TeamMonsterKillScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TeamMonsterKillScalarWhereWithAggregatesInput>
    OR?: Enumerable<TeamMonsterKillScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TeamMonsterKillScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    type?: StringWithAggregatesFilter | string
    subType?: StringWithAggregatesFilter | string
  }

  export type RuneSelectionWhereInput = {
    AND?: Enumerable<RuneSelectionWhereInput>
    OR?: Enumerable<RuneSelectionWhereInput>
    NOT?: Enumerable<RuneSelectionWhereInput>
    id?: StringFilter | string
    runeStyle?: XOR<RuneStyleRelationFilter, RuneStyleWhereInput> | null
    runeStyleId?: StringNullableFilter | string | null
    perk?: IntNullableFilter | number | null
    var1?: IntNullableFilter | number | null
    var2?: IntNullableFilter | number | null
    var3?: IntNullableFilter | number | null
  }

  export type RuneSelectionOrderByWithRelationInput = {
    id?: SortOrder
    runeStyle?: RuneStyleOrderByWithRelationInput
    runeStyleId?: SortOrder
    perk?: SortOrder
    var1?: SortOrder
    var2?: SortOrder
    var3?: SortOrder
  }

  export type RuneSelectionWhereUniqueInput = {
    id?: string
  }

  export type RuneSelectionOrderByWithAggregationInput = {
    id?: SortOrder
    runeStyleId?: SortOrder
    perk?: SortOrder
    var1?: SortOrder
    var2?: SortOrder
    var3?: SortOrder
    _count?: RuneSelectionCountOrderByAggregateInput
    _avg?: RuneSelectionAvgOrderByAggregateInput
    _max?: RuneSelectionMaxOrderByAggregateInput
    _min?: RuneSelectionMinOrderByAggregateInput
    _sum?: RuneSelectionSumOrderByAggregateInput
  }

  export type RuneSelectionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<RuneSelectionScalarWhereWithAggregatesInput>
    OR?: Enumerable<RuneSelectionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<RuneSelectionScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    runeStyleId?: StringNullableWithAggregatesFilter | string | null
    perk?: IntNullableWithAggregatesFilter | number | null
    var1?: IntNullableWithAggregatesFilter | number | null
    var2?: IntNullableWithAggregatesFilter | number | null
    var3?: IntNullableWithAggregatesFilter | number | null
  }

  export type RuneStyleWhereInput = {
    AND?: Enumerable<RuneStyleWhereInput>
    OR?: Enumerable<RuneStyleWhereInput>
    NOT?: Enumerable<RuneStyleWhereInput>
    id?: StringFilter | string
    playerRunes?: XOR<PlayerRuneRelationFilter, PlayerRuneWhereInput> | null
    playerRunesId?: StringNullableFilter | string | null
    selection?: RuneSelectionListRelationFilter
    description?: StringFilter | string
    style?: IntNullableFilter | number | null
  }

  export type RuneStyleOrderByWithRelationInput = {
    id?: SortOrder
    playerRunes?: PlayerRuneOrderByWithRelationInput
    playerRunesId?: SortOrder
    selection?: RuneSelectionOrderByRelationAggregateInput
    description?: SortOrder
    style?: SortOrder
  }

  export type RuneStyleWhereUniqueInput = {
    id?: string
  }

  export type RuneStyleOrderByWithAggregationInput = {
    id?: SortOrder
    playerRunesId?: SortOrder
    description?: SortOrder
    style?: SortOrder
    _count?: RuneStyleCountOrderByAggregateInput
    _avg?: RuneStyleAvgOrderByAggregateInput
    _max?: RuneStyleMaxOrderByAggregateInput
    _min?: RuneStyleMinOrderByAggregateInput
    _sum?: RuneStyleSumOrderByAggregateInput
  }

  export type RuneStyleScalarWhereWithAggregatesInput = {
    AND?: Enumerable<RuneStyleScalarWhereWithAggregatesInput>
    OR?: Enumerable<RuneStyleScalarWhereWithAggregatesInput>
    NOT?: Enumerable<RuneStyleScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    playerRunesId?: StringNullableWithAggregatesFilter | string | null
    description?: StringWithAggregatesFilter | string
    style?: IntNullableWithAggregatesFilter | number | null
  }

  export type ActivityCreateInput = {
    id?: string
    profile?: ProfileCreateNestedOneWithoutActivityInput
    month?: number | null
    year?: number | null
    day?: number | null
    gamesPlayed?: number | null
  }

  export type ActivityUncheckedCreateInput = {
    id?: string
    profileId?: string | null
    month?: number | null
    year?: number | null
    day?: number | null
    gamesPlayed?: number | null
  }

  export type ActivityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUpdateOneWithoutActivityInput
    month?: NullableIntFieldUpdateOperationsInput | number | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    day?: NullableIntFieldUpdateOperationsInput | number | null
    gamesPlayed?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ActivityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: NullableStringFieldUpdateOperationsInput | string | null
    month?: NullableIntFieldUpdateOperationsInput | number | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    day?: NullableIntFieldUpdateOperationsInput | number | null
    gamesPlayed?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ActivityCreateManyInput = {
    id?: string
    profileId?: string | null
    month?: number | null
    year?: number | null
    day?: number | null
    gamesPlayed?: number | null
  }

  export type ActivityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: NullableIntFieldUpdateOperationsInput | number | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    day?: NullableIntFieldUpdateOperationsInput | number | null
    gamesPlayed?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ActivityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: NullableStringFieldUpdateOperationsInput | string | null
    month?: NullableIntFieldUpdateOperationsInput | number | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    day?: NullableIntFieldUpdateOperationsInput | number | null
    gamesPlayed?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ChampionWinrateCreateInput = {
    id?: string
    profile?: ProfileCreateNestedOneWithoutChampionWinrateInput
    champion?: string
    wins?: number | null
    games?: number | null
    spell1Casts?: number | null
    spell2Casts?: number | null
    spell3Casts?: number | null
    spell4Casts?: number | null
  }

  export type ChampionWinrateUncheckedCreateInput = {
    id?: string
    profileId?: string | null
    champion?: string
    wins?: number | null
    games?: number | null
    spell1Casts?: number | null
    spell2Casts?: number | null
    spell3Casts?: number | null
    spell4Casts?: number | null
  }

  export type ChampionWinrateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUpdateOneWithoutChampionWinrateInput
    champion?: StringFieldUpdateOperationsInput | string
    wins?: NullableIntFieldUpdateOperationsInput | number | null
    games?: NullableIntFieldUpdateOperationsInput | number | null
    spell1Casts?: NullableIntFieldUpdateOperationsInput | number | null
    spell2Casts?: NullableIntFieldUpdateOperationsInput | number | null
    spell3Casts?: NullableIntFieldUpdateOperationsInput | number | null
    spell4Casts?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ChampionWinrateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: NullableStringFieldUpdateOperationsInput | string | null
    champion?: StringFieldUpdateOperationsInput | string
    wins?: NullableIntFieldUpdateOperationsInput | number | null
    games?: NullableIntFieldUpdateOperationsInput | number | null
    spell1Casts?: NullableIntFieldUpdateOperationsInput | number | null
    spell2Casts?: NullableIntFieldUpdateOperationsInput | number | null
    spell3Casts?: NullableIntFieldUpdateOperationsInput | number | null
    spell4Casts?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ChampionWinrateCreateManyInput = {
    id?: string
    profileId?: string | null
    champion?: string
    wins?: number | null
    games?: number | null
    spell1Casts?: number | null
    spell2Casts?: number | null
    spell3Casts?: number | null
    spell4Casts?: number | null
  }

  export type ChampionWinrateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    champion?: StringFieldUpdateOperationsInput | string
    wins?: NullableIntFieldUpdateOperationsInput | number | null
    games?: NullableIntFieldUpdateOperationsInput | number | null
    spell1Casts?: NullableIntFieldUpdateOperationsInput | number | null
    spell2Casts?: NullableIntFieldUpdateOperationsInput | number | null
    spell3Casts?: NullableIntFieldUpdateOperationsInput | number | null
    spell4Casts?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ChampionWinrateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: NullableStringFieldUpdateOperationsInput | string | null
    champion?: StringFieldUpdateOperationsInput | string
    wins?: NullableIntFieldUpdateOperationsInput | number | null
    games?: NullableIntFieldUpdateOperationsInput | number | null
    spell1Casts?: NullableIntFieldUpdateOperationsInput | number | null
    spell2Casts?: NullableIntFieldUpdateOperationsInput | number | null
    spell3Casts?: NullableIntFieldUpdateOperationsInput | number | null
    spell4Casts?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type DuoCreateInput = {
    id?: string
    profile?: ProfileCreateNestedOneWithoutDuosInput
    name?: string
    wins?: number | null
    losses?: number | null
    winrate?: string
  }

  export type DuoUncheckedCreateInput = {
    id?: string
    profileId?: string | null
    name?: string
    wins?: number | null
    losses?: number | null
    winrate?: string
  }

  export type DuoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUpdateOneWithoutDuosInput
    name?: StringFieldUpdateOperationsInput | string
    wins?: NullableIntFieldUpdateOperationsInput | number | null
    losses?: NullableIntFieldUpdateOperationsInput | number | null
    winrate?: StringFieldUpdateOperationsInput | string
  }

  export type DuoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    wins?: NullableIntFieldUpdateOperationsInput | number | null
    losses?: NullableIntFieldUpdateOperationsInput | number | null
    winrate?: StringFieldUpdateOperationsInput | string
  }

  export type DuoCreateManyInput = {
    id?: string
    profileId?: string | null
    name?: string
    wins?: number | null
    losses?: number | null
    winrate?: string
  }

  export type DuoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    wins?: NullableIntFieldUpdateOperationsInput | number | null
    losses?: NullableIntFieldUpdateOperationsInput | number | null
    winrate?: StringFieldUpdateOperationsInput | string
  }

  export type DuoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    wins?: NullableIntFieldUpdateOperationsInput | number | null
    losses?: NullableIntFieldUpdateOperationsInput | number | null
    winrate?: StringFieldUpdateOperationsInput | string
  }

  export type ConstantCreateInput = {
    id?: string
    startTime?: string
    currentSeason?: string
    seeding?: boolean
  }

  export type ConstantUncheckedCreateInput = {
    id?: string
    startTime?: string
    currentSeason?: string
    seeding?: boolean
  }

  export type ConstantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    currentSeason?: StringFieldUpdateOperationsInput | string
    seeding?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ConstantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    currentSeason?: StringFieldUpdateOperationsInput | string
    seeding?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ConstantCreateManyInput = {
    id?: string
    startTime?: string
    currentSeason?: string
    seeding?: boolean
  }

  export type ConstantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    currentSeason?: StringFieldUpdateOperationsInput | string
    seeding?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ConstantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    currentSeason?: StringFieldUpdateOperationsInput | string
    seeding?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EventCreateInput = {
    id?: string
    timestamp?: number | null
    position?: PositionCreateNestedManyWithoutEventInput
  }

  export type EventUncheckedCreateInput = {
    id?: string
    timestamp?: number | null
    position?: PositionUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: NullableIntFieldUpdateOperationsInput | number | null
    position?: PositionUpdateManyWithoutEventInput
  }

  export type EventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: NullableIntFieldUpdateOperationsInput | number | null
    position?: PositionUncheckedUpdateManyWithoutEventInput
  }

  export type EventCreateManyInput = {
    id?: string
    timestamp?: number | null
  }

  export type EventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type EventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type GameCreateInput = {
    id?: string
    matchId?: string
    gameId?: string
    gameCreation?: string
    gameStartTimestamp?: string
    gameEndTimestamp?: string
    duration?: number | null
    start?: string
    gameVersion?: string
    blueTeam?: TeamCreateNestedOneWithoutFrom_Game_blueTeamInput
    redTeam?: TeamCreateNestedOneWithoutFrom_Game_redTeamInput
    source?: SourceCreateNestedManyWithoutGameInput
    tournament?: string
    gameInSeries?: number | null
    vod?: string
    platformId?: string
    from_PlayerEndOfGameStat_game?: PlayerEndOfGameStatCreateNestedManyWithoutGameInput
    from_Team_game?: TeamCreateNestedManyWithoutGameInput
  }

  export type GameUncheckedCreateInput = {
    id?: string
    matchId?: string
    gameId?: string
    gameCreation?: string
    gameStartTimestamp?: string
    gameEndTimestamp?: string
    duration?: number | null
    start?: string
    gameVersion?: string
    blueTeamId?: string | null
    redTeamId?: string | null
    source?: SourceUncheckedCreateNestedManyWithoutGameInput
    tournament?: string
    gameInSeries?: number | null
    vod?: string
    platformId?: string
    from_PlayerEndOfGameStat_game?: PlayerEndOfGameStatUncheckedCreateNestedManyWithoutGameInput
    from_Team_game?: TeamUncheckedCreateNestedManyWithoutGameInput
  }

  export type GameUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    matchId?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    gameCreation?: StringFieldUpdateOperationsInput | string
    gameStartTimestamp?: StringFieldUpdateOperationsInput | string
    gameEndTimestamp?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    start?: StringFieldUpdateOperationsInput | string
    gameVersion?: StringFieldUpdateOperationsInput | string
    blueTeam?: TeamUpdateOneWithoutFrom_Game_blueTeamInput
    redTeam?: TeamUpdateOneWithoutFrom_Game_redTeamInput
    source?: SourceUpdateManyWithoutGameInput
    tournament?: StringFieldUpdateOperationsInput | string
    gameInSeries?: NullableIntFieldUpdateOperationsInput | number | null
    vod?: StringFieldUpdateOperationsInput | string
    platformId?: StringFieldUpdateOperationsInput | string
    from_PlayerEndOfGameStat_game?: PlayerEndOfGameStatUpdateManyWithoutGameInput
    from_Team_game?: TeamUpdateManyWithoutGameInput
  }

  export type GameUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    matchId?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    gameCreation?: StringFieldUpdateOperationsInput | string
    gameStartTimestamp?: StringFieldUpdateOperationsInput | string
    gameEndTimestamp?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    start?: StringFieldUpdateOperationsInput | string
    gameVersion?: StringFieldUpdateOperationsInput | string
    blueTeamId?: NullableStringFieldUpdateOperationsInput | string | null
    redTeamId?: NullableStringFieldUpdateOperationsInput | string | null
    source?: SourceUncheckedUpdateManyWithoutGameInput
    tournament?: StringFieldUpdateOperationsInput | string
    gameInSeries?: NullableIntFieldUpdateOperationsInput | number | null
    vod?: StringFieldUpdateOperationsInput | string
    platformId?: StringFieldUpdateOperationsInput | string
    from_PlayerEndOfGameStat_game?: PlayerEndOfGameStatUncheckedUpdateManyWithoutGameInput
    from_Team_game?: TeamUncheckedUpdateManyWithoutGameInput
  }

  export type GameCreateManyInput = {
    id?: string
    matchId?: string
    gameId?: string
    gameCreation?: string
    gameStartTimestamp?: string
    gameEndTimestamp?: string
    duration?: number | null
    start?: string
    gameVersion?: string
    blueTeamId?: string | null
    redTeamId?: string | null
    tournament?: string
    gameInSeries?: number | null
    vod?: string
    platformId?: string
  }

  export type GameUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    matchId?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    gameCreation?: StringFieldUpdateOperationsInput | string
    gameStartTimestamp?: StringFieldUpdateOperationsInput | string
    gameEndTimestamp?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    start?: StringFieldUpdateOperationsInput | string
    gameVersion?: StringFieldUpdateOperationsInput | string
    tournament?: StringFieldUpdateOperationsInput | string
    gameInSeries?: NullableIntFieldUpdateOperationsInput | number | null
    vod?: StringFieldUpdateOperationsInput | string
    platformId?: StringFieldUpdateOperationsInput | string
  }

  export type GameUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    matchId?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    gameCreation?: StringFieldUpdateOperationsInput | string
    gameStartTimestamp?: StringFieldUpdateOperationsInput | string
    gameEndTimestamp?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    start?: StringFieldUpdateOperationsInput | string
    gameVersion?: StringFieldUpdateOperationsInput | string
    blueTeamId?: NullableStringFieldUpdateOperationsInput | string | null
    redTeamId?: NullableStringFieldUpdateOperationsInput | string | null
    tournament?: StringFieldUpdateOperationsInput | string
    gameInSeries?: NullableIntFieldUpdateOperationsInput | number | null
    vod?: StringFieldUpdateOperationsInput | string
    platformId?: StringFieldUpdateOperationsInput | string
  }

  export type ObjectiveCreateInput = {
    id?: string
    team?: TeamCreateNestedOneWithoutObjectivesInput
    first?: boolean
    kills?: number | null
    type?: string
  }

  export type ObjectiveUncheckedCreateInput = {
    id?: string
    teamId?: string | null
    first?: boolean
    kills?: number | null
    type?: string
  }

  export type ObjectiveUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    team?: TeamUpdateOneWithoutObjectivesInput
    first?: BoolFieldUpdateOperationsInput | boolean
    kills?: NullableIntFieldUpdateOperationsInput | number | null
    type?: StringFieldUpdateOperationsInput | string
  }

  export type ObjectiveUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    first?: BoolFieldUpdateOperationsInput | boolean
    kills?: NullableIntFieldUpdateOperationsInput | number | null
    type?: StringFieldUpdateOperationsInput | string
  }

  export type ObjectiveCreateManyInput = {
    id?: string
    teamId?: string | null
    first?: boolean
    kills?: number | null
    type?: string
  }

  export type ObjectiveUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    first?: BoolFieldUpdateOperationsInput | boolean
    kills?: NullableIntFieldUpdateOperationsInput | number | null
    type?: StringFieldUpdateOperationsInput | string
  }

  export type ObjectiveUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    first?: BoolFieldUpdateOperationsInput | boolean
    kills?: NullableIntFieldUpdateOperationsInput | number | null
    type?: StringFieldUpdateOperationsInput | string
  }

  export type PickBanCreateInput = {
    id?: string
    team?: TeamCreateNestedOneWithoutPickBanInput
    championId?: number | null
    pickTurn?: number | null
  }

  export type PickBanUncheckedCreateInput = {
    id?: string
    teamId?: string | null
    championId?: number | null
    pickTurn?: number | null
  }

  export type PickBanUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    team?: TeamUpdateOneWithoutPickBanInput
    championId?: NullableIntFieldUpdateOperationsInput | number | null
    pickTurn?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PickBanUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    championId?: NullableIntFieldUpdateOperationsInput | number | null
    pickTurn?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PickBanCreateManyInput = {
    id?: string
    teamId?: string | null
    championId?: number | null
    pickTurn?: number | null
  }

  export type PickBanUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    championId?: NullableIntFieldUpdateOperationsInput | number | null
    pickTurn?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PickBanUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    championId?: NullableIntFieldUpdateOperationsInput | number | null
    pickTurn?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PlayerCreateInput = {
    id?: string
    puuid?: string
    accountId?: string
    platformId?: string
    summonerId?: string
    summonerName?: string
    summonerLevel?: number | null
    profileIconId?: number | null
    revisionDate?: string
    kills?: PlayerKillCreateNestedManyWithoutKillerInput
    deaths?: PlayerKillCreateNestedManyWithoutVictimInput
    teams?: TeamCreateNestedManyWithoutPlayersInput
    profile?: ProfileCreateNestedOneWithoutPlayerInput
    monsterKills?: TeamMonsterKillCreateNestedManyWithoutKillerInput
    buildingKills?: TeamBuildingKillCreateNestedManyWithoutKillerInput
    itemEvent?: PlayerItemEventCreateNestedManyWithoutPlayerInput
    endOfGameStats?: PlayerEndOfGameStatCreateNestedManyWithoutPlayerInput
    snapshots?: PlayerSnapshotCreateNestedManyWithoutPlayerInput
    wardEvents?: PlayerWardEventCreateNestedManyWithoutPlayerInput
    skillLevelUpEvents?: PlayerSkillLevelUpEventCreateNestedManyWithoutPlayerInput
  }

  export type PlayerUncheckedCreateInput = {
    id?: string
    puuid?: string
    accountId?: string
    platformId?: string
    summonerId?: string
    summonerName?: string
    summonerLevel?: number | null
    profileIconId?: number | null
    revisionDate?: string
    kills?: PlayerKillUncheckedCreateNestedManyWithoutKillerInput
    deaths?: PlayerKillUncheckedCreateNestedManyWithoutVictimInput
    teams?: TeamUncheckedCreateNestedManyWithoutPlayersInput
    profileId?: string | null
    monsterKills?: TeamMonsterKillUncheckedCreateNestedManyWithoutKillerInput
    buildingKills?: TeamBuildingKillUncheckedCreateNestedManyWithoutKillerInput
    itemEvent?: PlayerItemEventUncheckedCreateNestedManyWithoutPlayerInput
    endOfGameStats?: PlayerEndOfGameStatUncheckedCreateNestedManyWithoutPlayerInput
    snapshots?: PlayerSnapshotUncheckedCreateNestedManyWithoutPlayerInput
    wardEvents?: PlayerWardEventUncheckedCreateNestedManyWithoutPlayerInput
    skillLevelUpEvents?: PlayerSkillLevelUpEventUncheckedCreateNestedManyWithoutPlayerInput
  }

  export type PlayerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    puuid?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    platformId?: StringFieldUpdateOperationsInput | string
    summonerId?: StringFieldUpdateOperationsInput | string
    summonerName?: StringFieldUpdateOperationsInput | string
    summonerLevel?: NullableIntFieldUpdateOperationsInput | number | null
    profileIconId?: NullableIntFieldUpdateOperationsInput | number | null
    revisionDate?: StringFieldUpdateOperationsInput | string
    kills?: PlayerKillUpdateManyWithoutKillerInput
    deaths?: PlayerKillUpdateManyWithoutVictimInput
    teams?: TeamUpdateManyWithoutPlayersInput
    profile?: ProfileUpdateOneWithoutPlayerInput
    monsterKills?: TeamMonsterKillUpdateManyWithoutKillerInput
    buildingKills?: TeamBuildingKillUpdateManyWithoutKillerInput
    itemEvent?: PlayerItemEventUpdateManyWithoutPlayerInput
    endOfGameStats?: PlayerEndOfGameStatUpdateManyWithoutPlayerInput
    snapshots?: PlayerSnapshotUpdateManyWithoutPlayerInput
    wardEvents?: PlayerWardEventUpdateManyWithoutPlayerInput
    skillLevelUpEvents?: PlayerSkillLevelUpEventUpdateManyWithoutPlayerInput
  }

  export type PlayerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    puuid?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    platformId?: StringFieldUpdateOperationsInput | string
    summonerId?: StringFieldUpdateOperationsInput | string
    summonerName?: StringFieldUpdateOperationsInput | string
    summonerLevel?: NullableIntFieldUpdateOperationsInput | number | null
    profileIconId?: NullableIntFieldUpdateOperationsInput | number | null
    revisionDate?: StringFieldUpdateOperationsInput | string
    kills?: PlayerKillUncheckedUpdateManyWithoutKillerInput
    deaths?: PlayerKillUncheckedUpdateManyWithoutVictimInput
    teams?: TeamUncheckedUpdateManyWithoutPlayersInput
    profileId?: NullableStringFieldUpdateOperationsInput | string | null
    monsterKills?: TeamMonsterKillUncheckedUpdateManyWithoutKillerInput
    buildingKills?: TeamBuildingKillUncheckedUpdateManyWithoutKillerInput
    itemEvent?: PlayerItemEventUncheckedUpdateManyWithoutPlayerInput
    endOfGameStats?: PlayerEndOfGameStatUncheckedUpdateManyWithoutPlayerInput
    snapshots?: PlayerSnapshotUncheckedUpdateManyWithoutPlayerInput
    wardEvents?: PlayerWardEventUncheckedUpdateManyWithoutPlayerInput
    skillLevelUpEvents?: PlayerSkillLevelUpEventUncheckedUpdateManyWithoutPlayerInput
  }

  export type PlayerCreateManyInput = {
    id?: string
    puuid?: string
    accountId?: string
    platformId?: string
    summonerId?: string
    summonerName?: string
    summonerLevel?: number | null
    profileIconId?: number | null
    revisionDate?: string
    profileId?: string | null
  }

  export type PlayerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    puuid?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    platformId?: StringFieldUpdateOperationsInput | string
    summonerId?: StringFieldUpdateOperationsInput | string
    summonerName?: StringFieldUpdateOperationsInput | string
    summonerLevel?: NullableIntFieldUpdateOperationsInput | number | null
    profileIconId?: NullableIntFieldUpdateOperationsInput | number | null
    revisionDate?: StringFieldUpdateOperationsInput | string
  }

  export type PlayerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    puuid?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    platformId?: StringFieldUpdateOperationsInput | string
    summonerId?: StringFieldUpdateOperationsInput | string
    summonerName?: StringFieldUpdateOperationsInput | string
    summonerLevel?: NullableIntFieldUpdateOperationsInput | number | null
    profileIconId?: NullableIntFieldUpdateOperationsInput | number | null
    revisionDate?: StringFieldUpdateOperationsInput | string
    profileId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PlayerEndOfGameStatCreateInput = {
    id?: string
    player?: PlayerCreateNestedOneWithoutEndOfGameStatsInput
    game?: GameCreateNestedOneWithoutFrom_PlayerEndOfGameStat_gameInput
    perks?: PlayerRuneCreateNestedOneWithoutPlayerEndOfGameStatInput
    items?: PlayerItemCreateNestedOneWithoutPlayerEndOfGameStatInput
    assists?: number | null
    baronKills?: number | null
    bountyLevel?: number | null
    championExperience?: number | null
    championLevel?: number | null
    championId?: number | null
    championName?: string
    championTransform?: number | null
    consumablesPurchased?: number | null
    damageDealtToBuildings?: number | null
    damageDealtToObjectives?: number | null
    damageDealtToTurrets?: number | null
    damageSelfMitigated?: number | null
    deaths?: number | null
    detectorWardsPlaced?: number | null
    doubleKills?: number | null
    dragonKills?: number | null
    firstBlood?: boolean
    firstBloodAssist?: boolean
    firstTowerKill?: boolean
    firstTowerAssist?: boolean
    gameEndedInEarlySurrender?: boolean
    gameEndedInSurrender?: boolean
    goldEarned?: number | null
    goldSpent?: number | null
    individualPosition?: string
    inhibitorKills?: number | null
    inhibitorTakedowns?: number | null
    inhibitorsLost?: number | null
    item0?: number | null
    item1?: number | null
    item2?: number | null
    item3?: number | null
    item4?: number | null
    item5?: number | null
    item6?: number | null
    itemsPurchased?: number | null
    killingSprees?: number | null
    kills?: number | null
    lane?: string
    largestCriticalStrike?: number | null
    largestKillingSpree?: number | null
    largestMultiKill?: number | null
    longestTimeSpentLiving?: number | null
    magicDamageDealt?: number | null
    magicDamageDealtToChampions?: number | null
    magicDamageTaken?: number | null
    neutralMinionsKilled?: number | null
    nexusKills?: number | null
    nexusLost?: number | null
    nexusTakedowns?: number | null
    objectivesStolen?: number | null
    objectivesStolenAssists?: number | null
    participantId?: number | null
    pentaKills?: number | null
    physicalDamageDealt?: number | null
    physicalDamageDealtToChampions?: number | null
    physicalDamageTaken?: number | null
    quadraKills?: number | null
    riotIdName?: string
    riotIdTagline?: string
    role?: string
    sightWardsBoughtInGame?: number | null
    spell1Casts?: number | null
    spell2Casts?: number | null
    spell3Casts?: number | null
    spell4Casts?: number | null
    summoner1Casts?: number | null
    summoner1Id?: number | null
    summoner2Casts?: number | null
    summoner2Id?: number | null
    summonerLevel?: number | null
    summonerName?: string
    teamEarlySurrendered?: boolean
    teamId?: number | null
    teamPosition?: string
    timeCCingOthers?: number | null
    timePlayed?: number | null
    totalDamageDealt?: number | null
    totalDamageDealtToChampions?: number | null
    totalDamageShieldedOnTeammates?: number | null
    totalDamageTaken?: number | null
    totalHeal?: number | null
    totalHealsOnTeammates?: number | null
    totalMinionsKilled?: number | null
    totalTimeCCDealt?: number | null
    totalTimeSpentDead?: number | null
    totalUnitsHealed?: number | null
    tripleKills?: number | null
    trueDamageDealt?: number | null
    trueDamageDealtToChampions?: number | null
    trueDamageTaken?: number | null
    turretsKilled?: number | null
    turretTakedowns?: number | null
    turretsLost?: number | null
    unrealKills?: number | null
    visionScore?: number | null
    visionWardsBoughtInGame?: number | null
    wardsKilled?: number | null
    wardsPlaced?: number | null
    win?: boolean
  }

  export type PlayerEndOfGameStatUncheckedCreateInput = {
    id?: string
    playerId?: string | null
    gameId?: string | null
    perksId?: string | null
    itemsId?: string | null
    assists?: number | null
    baronKills?: number | null
    bountyLevel?: number | null
    championExperience?: number | null
    championLevel?: number | null
    championId?: number | null
    championName?: string
    championTransform?: number | null
    consumablesPurchased?: number | null
    damageDealtToBuildings?: number | null
    damageDealtToObjectives?: number | null
    damageDealtToTurrets?: number | null
    damageSelfMitigated?: number | null
    deaths?: number | null
    detectorWardsPlaced?: number | null
    doubleKills?: number | null
    dragonKills?: number | null
    firstBlood?: boolean
    firstBloodAssist?: boolean
    firstTowerKill?: boolean
    firstTowerAssist?: boolean
    gameEndedInEarlySurrender?: boolean
    gameEndedInSurrender?: boolean
    goldEarned?: number | null
    goldSpent?: number | null
    individualPosition?: string
    inhibitorKills?: number | null
    inhibitorTakedowns?: number | null
    inhibitorsLost?: number | null
    item0?: number | null
    item1?: number | null
    item2?: number | null
    item3?: number | null
    item4?: number | null
    item5?: number | null
    item6?: number | null
    itemsPurchased?: number | null
    killingSprees?: number | null
    kills?: number | null
    lane?: string
    largestCriticalStrike?: number | null
    largestKillingSpree?: number | null
    largestMultiKill?: number | null
    longestTimeSpentLiving?: number | null
    magicDamageDealt?: number | null
    magicDamageDealtToChampions?: number | null
    magicDamageTaken?: number | null
    neutralMinionsKilled?: number | null
    nexusKills?: number | null
    nexusLost?: number | null
    nexusTakedowns?: number | null
    objectivesStolen?: number | null
    objectivesStolenAssists?: number | null
    participantId?: number | null
    pentaKills?: number | null
    physicalDamageDealt?: number | null
    physicalDamageDealtToChampions?: number | null
    physicalDamageTaken?: number | null
    quadraKills?: number | null
    riotIdName?: string
    riotIdTagline?: string
    role?: string
    sightWardsBoughtInGame?: number | null
    spell1Casts?: number | null
    spell2Casts?: number | null
    spell3Casts?: number | null
    spell4Casts?: number | null
    summoner1Casts?: number | null
    summoner1Id?: number | null
    summoner2Casts?: number | null
    summoner2Id?: number | null
    summonerLevel?: number | null
    summonerName?: string
    teamEarlySurrendered?: boolean
    teamId?: number | null
    teamPosition?: string
    timeCCingOthers?: number | null
    timePlayed?: number | null
    totalDamageDealt?: number | null
    totalDamageDealtToChampions?: number | null
    totalDamageShieldedOnTeammates?: number | null
    totalDamageTaken?: number | null
    totalHeal?: number | null
    totalHealsOnTeammates?: number | null
    totalMinionsKilled?: number | null
    totalTimeCCDealt?: number | null
    totalTimeSpentDead?: number | null
    totalUnitsHealed?: number | null
    tripleKills?: number | null
    trueDamageDealt?: number | null
    trueDamageDealtToChampions?: number | null
    trueDamageTaken?: number | null
    turretsKilled?: number | null
    turretTakedowns?: number | null
    turretsLost?: number | null
    unrealKills?: number | null
    visionScore?: number | null
    visionWardsBoughtInGame?: number | null
    wardsKilled?: number | null
    wardsPlaced?: number | null
    win?: boolean
  }

  export type PlayerEndOfGameStatUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    player?: PlayerUpdateOneWithoutEndOfGameStatsInput
    game?: GameUpdateOneWithoutFrom_PlayerEndOfGameStat_gameInput
    perks?: PlayerRuneUpdateOneWithoutPlayerEndOfGameStatInput
    items?: PlayerItemUpdateOneWithoutPlayerEndOfGameStatInput
    assists?: NullableIntFieldUpdateOperationsInput | number | null
    baronKills?: NullableIntFieldUpdateOperationsInput | number | null
    bountyLevel?: NullableIntFieldUpdateOperationsInput | number | null
    championExperience?: NullableIntFieldUpdateOperationsInput | number | null
    championLevel?: NullableIntFieldUpdateOperationsInput | number | null
    championId?: NullableIntFieldUpdateOperationsInput | number | null
    championName?: StringFieldUpdateOperationsInput | string
    championTransform?: NullableIntFieldUpdateOperationsInput | number | null
    consumablesPurchased?: NullableIntFieldUpdateOperationsInput | number | null
    damageDealtToBuildings?: NullableIntFieldUpdateOperationsInput | number | null
    damageDealtToObjectives?: NullableIntFieldUpdateOperationsInput | number | null
    damageDealtToTurrets?: NullableIntFieldUpdateOperationsInput | number | null
    damageSelfMitigated?: NullableIntFieldUpdateOperationsInput | number | null
    deaths?: NullableIntFieldUpdateOperationsInput | number | null
    detectorWardsPlaced?: NullableIntFieldUpdateOperationsInput | number | null
    doubleKills?: NullableIntFieldUpdateOperationsInput | number | null
    dragonKills?: NullableIntFieldUpdateOperationsInput | number | null
    firstBlood?: BoolFieldUpdateOperationsInput | boolean
    firstBloodAssist?: BoolFieldUpdateOperationsInput | boolean
    firstTowerKill?: BoolFieldUpdateOperationsInput | boolean
    firstTowerAssist?: BoolFieldUpdateOperationsInput | boolean
    gameEndedInEarlySurrender?: BoolFieldUpdateOperationsInput | boolean
    gameEndedInSurrender?: BoolFieldUpdateOperationsInput | boolean
    goldEarned?: NullableIntFieldUpdateOperationsInput | number | null
    goldSpent?: NullableIntFieldUpdateOperationsInput | number | null
    individualPosition?: StringFieldUpdateOperationsInput | string
    inhibitorKills?: NullableIntFieldUpdateOperationsInput | number | null
    inhibitorTakedowns?: NullableIntFieldUpdateOperationsInput | number | null
    inhibitorsLost?: NullableIntFieldUpdateOperationsInput | number | null
    item0?: NullableIntFieldUpdateOperationsInput | number | null
    item1?: NullableIntFieldUpdateOperationsInput | number | null
    item2?: NullableIntFieldUpdateOperationsInput | number | null
    item3?: NullableIntFieldUpdateOperationsInput | number | null
    item4?: NullableIntFieldUpdateOperationsInput | number | null
    item5?: NullableIntFieldUpdateOperationsInput | number | null
    item6?: NullableIntFieldUpdateOperationsInput | number | null
    itemsPurchased?: NullableIntFieldUpdateOperationsInput | number | null
    killingSprees?: NullableIntFieldUpdateOperationsInput | number | null
    kills?: NullableIntFieldUpdateOperationsInput | number | null
    lane?: StringFieldUpdateOperationsInput | string
    largestCriticalStrike?: NullableIntFieldUpdateOperationsInput | number | null
    largestKillingSpree?: NullableIntFieldUpdateOperationsInput | number | null
    largestMultiKill?: NullableIntFieldUpdateOperationsInput | number | null
    longestTimeSpentLiving?: NullableIntFieldUpdateOperationsInput | number | null
    magicDamageDealt?: NullableIntFieldUpdateOperationsInput | number | null
    magicDamageDealtToChampions?: NullableIntFieldUpdateOperationsInput | number | null
    magicDamageTaken?: NullableIntFieldUpdateOperationsInput | number | null
    neutralMinionsKilled?: NullableIntFieldUpdateOperationsInput | number | null
    nexusKills?: NullableIntFieldUpdateOperationsInput | number | null
    nexusLost?: NullableIntFieldUpdateOperationsInput | number | null
    nexusTakedowns?: NullableIntFieldUpdateOperationsInput | number | null
    objectivesStolen?: NullableIntFieldUpdateOperationsInput | number | null
    objectivesStolenAssists?: NullableIntFieldUpdateOperationsInput | number | null
    participantId?: NullableIntFieldUpdateOperationsInput | number | null
    pentaKills?: NullableIntFieldUpdateOperationsInput | number | null
    physicalDamageDealt?: NullableIntFieldUpdateOperationsInput | number | null
    physicalDamageDealtToChampions?: NullableIntFieldUpdateOperationsInput | number | null
    physicalDamageTaken?: NullableIntFieldUpdateOperationsInput | number | null
    quadraKills?: NullableIntFieldUpdateOperationsInput | number | null
    riotIdName?: StringFieldUpdateOperationsInput | string
    riotIdTagline?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    sightWardsBoughtInGame?: NullableIntFieldUpdateOperationsInput | number | null
    spell1Casts?: NullableIntFieldUpdateOperationsInput | number | null
    spell2Casts?: NullableIntFieldUpdateOperationsInput | number | null
    spell3Casts?: NullableIntFieldUpdateOperationsInput | number | null
    spell4Casts?: NullableIntFieldUpdateOperationsInput | number | null
    summoner1Casts?: NullableIntFieldUpdateOperationsInput | number | null
    summoner1Id?: NullableIntFieldUpdateOperationsInput | number | null
    summoner2Casts?: NullableIntFieldUpdateOperationsInput | number | null
    summoner2Id?: NullableIntFieldUpdateOperationsInput | number | null
    summonerLevel?: NullableIntFieldUpdateOperationsInput | number | null
    summonerName?: StringFieldUpdateOperationsInput | string
    teamEarlySurrendered?: BoolFieldUpdateOperationsInput | boolean
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    teamPosition?: StringFieldUpdateOperationsInput | string
    timeCCingOthers?: NullableIntFieldUpdateOperationsInput | number | null
    timePlayed?: NullableIntFieldUpdateOperationsInput | number | null
    totalDamageDealt?: NullableIntFieldUpdateOperationsInput | number | null
    totalDamageDealtToChampions?: NullableIntFieldUpdateOperationsInput | number | null
    totalDamageShieldedOnTeammates?: NullableIntFieldUpdateOperationsInput | number | null
    totalDamageTaken?: NullableIntFieldUpdateOperationsInput | number | null
    totalHeal?: NullableIntFieldUpdateOperationsInput | number | null
    totalHealsOnTeammates?: NullableIntFieldUpdateOperationsInput | number | null
    totalMinionsKilled?: NullableIntFieldUpdateOperationsInput | number | null
    totalTimeCCDealt?: NullableIntFieldUpdateOperationsInput | number | null
    totalTimeSpentDead?: NullableIntFieldUpdateOperationsInput | number | null
    totalUnitsHealed?: NullableIntFieldUpdateOperationsInput | number | null
    tripleKills?: NullableIntFieldUpdateOperationsInput | number | null
    trueDamageDealt?: NullableIntFieldUpdateOperationsInput | number | null
    trueDamageDealtToChampions?: NullableIntFieldUpdateOperationsInput | number | null
    trueDamageTaken?: NullableIntFieldUpdateOperationsInput | number | null
    turretsKilled?: NullableIntFieldUpdateOperationsInput | number | null
    turretTakedowns?: NullableIntFieldUpdateOperationsInput | number | null
    turretsLost?: NullableIntFieldUpdateOperationsInput | number | null
    unrealKills?: NullableIntFieldUpdateOperationsInput | number | null
    visionScore?: NullableIntFieldUpdateOperationsInput | number | null
    visionWardsBoughtInGame?: NullableIntFieldUpdateOperationsInput | number | null
    wardsKilled?: NullableIntFieldUpdateOperationsInput | number | null
    wardsPlaced?: NullableIntFieldUpdateOperationsInput | number | null
    win?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PlayerEndOfGameStatUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: NullableStringFieldUpdateOperationsInput | string | null
    gameId?: NullableStringFieldUpdateOperationsInput | string | null
    perksId?: NullableStringFieldUpdateOperationsInput | string | null
    itemsId?: NullableStringFieldUpdateOperationsInput | string | null
    assists?: NullableIntFieldUpdateOperationsInput | number | null
    baronKills?: NullableIntFieldUpdateOperationsInput | number | null
    bountyLevel?: NullableIntFieldUpdateOperationsInput | number | null
    championExperience?: NullableIntFieldUpdateOperationsInput | number | null
    championLevel?: NullableIntFieldUpdateOperationsInput | number | null
    championId?: NullableIntFieldUpdateOperationsInput | number | null
    championName?: StringFieldUpdateOperationsInput | string
    championTransform?: NullableIntFieldUpdateOperationsInput | number | null
    consumablesPurchased?: NullableIntFieldUpdateOperationsInput | number | null
    damageDealtToBuildings?: NullableIntFieldUpdateOperationsInput | number | null
    damageDealtToObjectives?: NullableIntFieldUpdateOperationsInput | number | null
    damageDealtToTurrets?: NullableIntFieldUpdateOperationsInput | number | null
    damageSelfMitigated?: NullableIntFieldUpdateOperationsInput | number | null
    deaths?: NullableIntFieldUpdateOperationsInput | number | null
    detectorWardsPlaced?: NullableIntFieldUpdateOperationsInput | number | null
    doubleKills?: NullableIntFieldUpdateOperationsInput | number | null
    dragonKills?: NullableIntFieldUpdateOperationsInput | number | null
    firstBlood?: BoolFieldUpdateOperationsInput | boolean
    firstBloodAssist?: BoolFieldUpdateOperationsInput | boolean
    firstTowerKill?: BoolFieldUpdateOperationsInput | boolean
    firstTowerAssist?: BoolFieldUpdateOperationsInput | boolean
    gameEndedInEarlySurrender?: BoolFieldUpdateOperationsInput | boolean
    gameEndedInSurrender?: BoolFieldUpdateOperationsInput | boolean
    goldEarned?: NullableIntFieldUpdateOperationsInput | number | null
    goldSpent?: NullableIntFieldUpdateOperationsInput | number | null
    individualPosition?: StringFieldUpdateOperationsInput | string
    inhibitorKills?: NullableIntFieldUpdateOperationsInput | number | null
    inhibitorTakedowns?: NullableIntFieldUpdateOperationsInput | number | null
    inhibitorsLost?: NullableIntFieldUpdateOperationsInput | number | null
    item0?: NullableIntFieldUpdateOperationsInput | number | null
    item1?: NullableIntFieldUpdateOperationsInput | number | null
    item2?: NullableIntFieldUpdateOperationsInput | number | null
    item3?: NullableIntFieldUpdateOperationsInput | number | null
    item4?: NullableIntFieldUpdateOperationsInput | number | null
    item5?: NullableIntFieldUpdateOperationsInput | number | null
    item6?: NullableIntFieldUpdateOperationsInput | number | null
    itemsPurchased?: NullableIntFieldUpdateOperationsInput | number | null
    killingSprees?: NullableIntFieldUpdateOperationsInput | number | null
    kills?: NullableIntFieldUpdateOperationsInput | number | null
    lane?: StringFieldUpdateOperationsInput | string
    largestCriticalStrike?: NullableIntFieldUpdateOperationsInput | number | null
    largestKillingSpree?: NullableIntFieldUpdateOperationsInput | number | null
    largestMultiKill?: NullableIntFieldUpdateOperationsInput | number | null
    longestTimeSpentLiving?: NullableIntFieldUpdateOperationsInput | number | null
    magicDamageDealt?: NullableIntFieldUpdateOperationsInput | number | null
    magicDamageDealtToChampions?: NullableIntFieldUpdateOperationsInput | number | null
    magicDamageTaken?: NullableIntFieldUpdateOperationsInput | number | null
    neutralMinionsKilled?: NullableIntFieldUpdateOperationsInput | number | null
    nexusKills?: NullableIntFieldUpdateOperationsInput | number | null
    nexusLost?: NullableIntFieldUpdateOperationsInput | number | null
    nexusTakedowns?: NullableIntFieldUpdateOperationsInput | number | null
    objectivesStolen?: NullableIntFieldUpdateOperationsInput | number | null
    objectivesStolenAssists?: NullableIntFieldUpdateOperationsInput | number | null
    participantId?: NullableIntFieldUpdateOperationsInput | number | null
    pentaKills?: NullableIntFieldUpdateOperationsInput | number | null
    physicalDamageDealt?: NullableIntFieldUpdateOperationsInput | number | null
    physicalDamageDealtToChampions?: NullableIntFieldUpdateOperationsInput | number | null
    physicalDamageTaken?: NullableIntFieldUpdateOperationsInput | number | null
    quadraKills?: NullableIntFieldUpdateOperationsInput | number | null
    riotIdName?: StringFieldUpdateOperationsInput | string
    riotIdTagline?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    sightWardsBoughtInGame?: NullableIntFieldUpdateOperationsInput | number | null
    spell1Casts?: NullableIntFieldUpdateOperationsInput | number | null
    spell2Casts?: NullableIntFieldUpdateOperationsInput | number | null
    spell3Casts?: NullableIntFieldUpdateOperationsInput | number | null
    spell4Casts?: NullableIntFieldUpdateOperationsInput | number | null
    summoner1Casts?: NullableIntFieldUpdateOperationsInput | number | null
    summoner1Id?: NullableIntFieldUpdateOperationsInput | number | null
    summoner2Casts?: NullableIntFieldUpdateOperationsInput | number | null
    summoner2Id?: NullableIntFieldUpdateOperationsInput | number | null
    summonerLevel?: NullableIntFieldUpdateOperationsInput | number | null
    summonerName?: StringFieldUpdateOperationsInput | string
    teamEarlySurrendered?: BoolFieldUpdateOperationsInput | boolean
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    teamPosition?: StringFieldUpdateOperationsInput | string
    timeCCingOthers?: NullableIntFieldUpdateOperationsInput | number | null
    timePlayed?: NullableIntFieldUpdateOperationsInput | number | null
    totalDamageDealt?: NullableIntFieldUpdateOperationsInput | number | null
    totalDamageDealtToChampions?: NullableIntFieldUpdateOperationsInput | number | null
    totalDamageShieldedOnTeammates?: NullableIntFieldUpdateOperationsInput | number | null
    totalDamageTaken?: NullableIntFieldUpdateOperationsInput | number | null
    totalHeal?: NullableIntFieldUpdateOperationsInput | number | null
    totalHealsOnTeammates?: NullableIntFieldUpdateOperationsInput | number | null
    totalMinionsKilled?: NullableIntFieldUpdateOperationsInput | number | null
    totalTimeCCDealt?: NullableIntFieldUpdateOperationsInput | number | null
    totalTimeSpentDead?: NullableIntFieldUpdateOperationsInput | number | null
    totalUnitsHealed?: NullableIntFieldUpdateOperationsInput | number | null
    tripleKills?: NullableIntFieldUpdateOperationsInput | number | null
    trueDamageDealt?: NullableIntFieldUpdateOperationsInput | number | null
    trueDamageDealtToChampions?: NullableIntFieldUpdateOperationsInput | number | null
    trueDamageTaken?: NullableIntFieldUpdateOperationsInput | number | null
    turretsKilled?: NullableIntFieldUpdateOperationsInput | number | null
    turretTakedowns?: NullableIntFieldUpdateOperationsInput | number | null
    turretsLost?: NullableIntFieldUpdateOperationsInput | number | null
    unrealKills?: NullableIntFieldUpdateOperationsInput | number | null
    visionScore?: NullableIntFieldUpdateOperationsInput | number | null
    visionWardsBoughtInGame?: NullableIntFieldUpdateOperationsInput | number | null
    wardsKilled?: NullableIntFieldUpdateOperationsInput | number | null
    wardsPlaced?: NullableIntFieldUpdateOperationsInput | number | null
    win?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PlayerEndOfGameStatCreateManyInput = {
    id?: string
    playerId?: string | null
    gameId?: string | null
    perksId?: string | null
    itemsId?: string | null
    assists?: number | null
    baronKills?: number | null
    bountyLevel?: number | null
    championExperience?: number | null
    championLevel?: number | null
    championId?: number | null
    championName?: string
    championTransform?: number | null
    consumablesPurchased?: number | null
    damageDealtToBuildings?: number | null
    damageDealtToObjectives?: number | null
    damageDealtToTurrets?: number | null
    damageSelfMitigated?: number | null
    deaths?: number | null
    detectorWardsPlaced?: number | null
    doubleKills?: number | null
    dragonKills?: number | null
    firstBlood?: boolean
    firstBloodAssist?: boolean
    firstTowerKill?: boolean
    firstTowerAssist?: boolean
    gameEndedInEarlySurrender?: boolean
    gameEndedInSurrender?: boolean
    goldEarned?: number | null
    goldSpent?: number | null
    individualPosition?: string
    inhibitorKills?: number | null
    inhibitorTakedowns?: number | null
    inhibitorsLost?: number | null
    item0?: number | null
    item1?: number | null
    item2?: number | null
    item3?: number | null
    item4?: number | null
    item5?: number | null
    item6?: number | null
    itemsPurchased?: number | null
    killingSprees?: number | null
    kills?: number | null
    lane?: string
    largestCriticalStrike?: number | null
    largestKillingSpree?: number | null
    largestMultiKill?: number | null
    longestTimeSpentLiving?: number | null
    magicDamageDealt?: number | null
    magicDamageDealtToChampions?: number | null
    magicDamageTaken?: number | null
    neutralMinionsKilled?: number | null
    nexusKills?: number | null
    nexusLost?: number | null
    nexusTakedowns?: number | null
    objectivesStolen?: number | null
    objectivesStolenAssists?: number | null
    participantId?: number | null
    pentaKills?: number | null
    physicalDamageDealt?: number | null
    physicalDamageDealtToChampions?: number | null
    physicalDamageTaken?: number | null
    quadraKills?: number | null
    riotIdName?: string
    riotIdTagline?: string
    role?: string
    sightWardsBoughtInGame?: number | null
    spell1Casts?: number | null
    spell2Casts?: number | null
    spell3Casts?: number | null
    spell4Casts?: number | null
    summoner1Casts?: number | null
    summoner1Id?: number | null
    summoner2Casts?: number | null
    summoner2Id?: number | null
    summonerLevel?: number | null
    summonerName?: string
    teamEarlySurrendered?: boolean
    teamId?: number | null
    teamPosition?: string
    timeCCingOthers?: number | null
    timePlayed?: number | null
    totalDamageDealt?: number | null
    totalDamageDealtToChampions?: number | null
    totalDamageShieldedOnTeammates?: number | null
    totalDamageTaken?: number | null
    totalHeal?: number | null
    totalHealsOnTeammates?: number | null
    totalMinionsKilled?: number | null
    totalTimeCCDealt?: number | null
    totalTimeSpentDead?: number | null
    totalUnitsHealed?: number | null
    tripleKills?: number | null
    trueDamageDealt?: number | null
    trueDamageDealtToChampions?: number | null
    trueDamageTaken?: number | null
    turretsKilled?: number | null
    turretTakedowns?: number | null
    turretsLost?: number | null
    unrealKills?: number | null
    visionScore?: number | null
    visionWardsBoughtInGame?: number | null
    wardsKilled?: number | null
    wardsPlaced?: number | null
    win?: boolean
  }

  export type PlayerEndOfGameStatUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    assists?: NullableIntFieldUpdateOperationsInput | number | null
    baronKills?: NullableIntFieldUpdateOperationsInput | number | null
    bountyLevel?: NullableIntFieldUpdateOperationsInput | number | null
    championExperience?: NullableIntFieldUpdateOperationsInput | number | null
    championLevel?: NullableIntFieldUpdateOperationsInput | number | null
    championId?: NullableIntFieldUpdateOperationsInput | number | null
    championName?: StringFieldUpdateOperationsInput | string
    championTransform?: NullableIntFieldUpdateOperationsInput | number | null
    consumablesPurchased?: NullableIntFieldUpdateOperationsInput | number | null
    damageDealtToBuildings?: NullableIntFieldUpdateOperationsInput | number | null
    damageDealtToObjectives?: NullableIntFieldUpdateOperationsInput | number | null
    damageDealtToTurrets?: NullableIntFieldUpdateOperationsInput | number | null
    damageSelfMitigated?: NullableIntFieldUpdateOperationsInput | number | null
    deaths?: NullableIntFieldUpdateOperationsInput | number | null
    detectorWardsPlaced?: NullableIntFieldUpdateOperationsInput | number | null
    doubleKills?: NullableIntFieldUpdateOperationsInput | number | null
    dragonKills?: NullableIntFieldUpdateOperationsInput | number | null
    firstBlood?: BoolFieldUpdateOperationsInput | boolean
    firstBloodAssist?: BoolFieldUpdateOperationsInput | boolean
    firstTowerKill?: BoolFieldUpdateOperationsInput | boolean
    firstTowerAssist?: BoolFieldUpdateOperationsInput | boolean
    gameEndedInEarlySurrender?: BoolFieldUpdateOperationsInput | boolean
    gameEndedInSurrender?: BoolFieldUpdateOperationsInput | boolean
    goldEarned?: NullableIntFieldUpdateOperationsInput | number | null
    goldSpent?: NullableIntFieldUpdateOperationsInput | number | null
    individualPosition?: StringFieldUpdateOperationsInput | string
    inhibitorKills?: NullableIntFieldUpdateOperationsInput | number | null
    inhibitorTakedowns?: NullableIntFieldUpdateOperationsInput | number | null
    inhibitorsLost?: NullableIntFieldUpdateOperationsInput | number | null
    item0?: NullableIntFieldUpdateOperationsInput | number | null
    item1?: NullableIntFieldUpdateOperationsInput | number | null
    item2?: NullableIntFieldUpdateOperationsInput | number | null
    item3?: NullableIntFieldUpdateOperationsInput | number | null
    item4?: NullableIntFieldUpdateOperationsInput | number | null
    item5?: NullableIntFieldUpdateOperationsInput | number | null
    item6?: NullableIntFieldUpdateOperationsInput | number | null
    itemsPurchased?: NullableIntFieldUpdateOperationsInput | number | null
    killingSprees?: NullableIntFieldUpdateOperationsInput | number | null
    kills?: NullableIntFieldUpdateOperationsInput | number | null
    lane?: StringFieldUpdateOperationsInput | string
    largestCriticalStrike?: NullableIntFieldUpdateOperationsInput | number | null
    largestKillingSpree?: NullableIntFieldUpdateOperationsInput | number | null
    largestMultiKill?: NullableIntFieldUpdateOperationsInput | number | null
    longestTimeSpentLiving?: NullableIntFieldUpdateOperationsInput | number | null
    magicDamageDealt?: NullableIntFieldUpdateOperationsInput | number | null
    magicDamageDealtToChampions?: NullableIntFieldUpdateOperationsInput | number | null
    magicDamageTaken?: NullableIntFieldUpdateOperationsInput | number | null
    neutralMinionsKilled?: NullableIntFieldUpdateOperationsInput | number | null
    nexusKills?: NullableIntFieldUpdateOperationsInput | number | null
    nexusLost?: NullableIntFieldUpdateOperationsInput | number | null
    nexusTakedowns?: NullableIntFieldUpdateOperationsInput | number | null
    objectivesStolen?: NullableIntFieldUpdateOperationsInput | number | null
    objectivesStolenAssists?: NullableIntFieldUpdateOperationsInput | number | null
    participantId?: NullableIntFieldUpdateOperationsInput | number | null
    pentaKills?: NullableIntFieldUpdateOperationsInput | number | null
    physicalDamageDealt?: NullableIntFieldUpdateOperationsInput | number | null
    physicalDamageDealtToChampions?: NullableIntFieldUpdateOperationsInput | number | null
    physicalDamageTaken?: NullableIntFieldUpdateOperationsInput | number | null
    quadraKills?: NullableIntFieldUpdateOperationsInput | number | null
    riotIdName?: StringFieldUpdateOperationsInput | string
    riotIdTagline?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    sightWardsBoughtInGame?: NullableIntFieldUpdateOperationsInput | number | null
    spell1Casts?: NullableIntFieldUpdateOperationsInput | number | null
    spell2Casts?: NullableIntFieldUpdateOperationsInput | number | null
    spell3Casts?: NullableIntFieldUpdateOperationsInput | number | null
    spell4Casts?: NullableIntFieldUpdateOperationsInput | number | null
    summoner1Casts?: NullableIntFieldUpdateOperationsInput | number | null
    summoner1Id?: NullableIntFieldUpdateOperationsInput | number | null
    summoner2Casts?: NullableIntFieldUpdateOperationsInput | number | null
    summoner2Id?: NullableIntFieldUpdateOperationsInput | number | null
    summonerLevel?: NullableIntFieldUpdateOperationsInput | number | null
    summonerName?: StringFieldUpdateOperationsInput | string
    teamEarlySurrendered?: BoolFieldUpdateOperationsInput | boolean
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    teamPosition?: StringFieldUpdateOperationsInput | string
    timeCCingOthers?: NullableIntFieldUpdateOperationsInput | number | null
    timePlayed?: NullableIntFieldUpdateOperationsInput | number | null
    totalDamageDealt?: NullableIntFieldUpdateOperationsInput | number | null
    totalDamageDealtToChampions?: NullableIntFieldUpdateOperationsInput | number | null
    totalDamageShieldedOnTeammates?: NullableIntFieldUpdateOperationsInput | number | null
    totalDamageTaken?: NullableIntFieldUpdateOperationsInput | number | null
    totalHeal?: NullableIntFieldUpdateOperationsInput | number | null
    totalHealsOnTeammates?: NullableIntFieldUpdateOperationsInput | number | null
    totalMinionsKilled?: NullableIntFieldUpdateOperationsInput | number | null
    totalTimeCCDealt?: NullableIntFieldUpdateOperationsInput | number | null
    totalTimeSpentDead?: NullableIntFieldUpdateOperationsInput | number | null
    totalUnitsHealed?: NullableIntFieldUpdateOperationsInput | number | null
    tripleKills?: NullableIntFieldUpdateOperationsInput | number | null
    trueDamageDealt?: NullableIntFieldUpdateOperationsInput | number | null
    trueDamageDealtToChampions?: NullableIntFieldUpdateOperationsInput | number | null
    trueDamageTaken?: NullableIntFieldUpdateOperationsInput | number | null
    turretsKilled?: NullableIntFieldUpdateOperationsInput | number | null
    turretTakedowns?: NullableIntFieldUpdateOperationsInput | number | null
    turretsLost?: NullableIntFieldUpdateOperationsInput | number | null
    unrealKills?: NullableIntFieldUpdateOperationsInput | number | null
    visionScore?: NullableIntFieldUpdateOperationsInput | number | null
    visionWardsBoughtInGame?: NullableIntFieldUpdateOperationsInput | number | null
    wardsKilled?: NullableIntFieldUpdateOperationsInput | number | null
    wardsPlaced?: NullableIntFieldUpdateOperationsInput | number | null
    win?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PlayerEndOfGameStatUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: NullableStringFieldUpdateOperationsInput | string | null
    gameId?: NullableStringFieldUpdateOperationsInput | string | null
    perksId?: NullableStringFieldUpdateOperationsInput | string | null
    itemsId?: NullableStringFieldUpdateOperationsInput | string | null
    assists?: NullableIntFieldUpdateOperationsInput | number | null
    baronKills?: NullableIntFieldUpdateOperationsInput | number | null
    bountyLevel?: NullableIntFieldUpdateOperationsInput | number | null
    championExperience?: NullableIntFieldUpdateOperationsInput | number | null
    championLevel?: NullableIntFieldUpdateOperationsInput | number | null
    championId?: NullableIntFieldUpdateOperationsInput | number | null
    championName?: StringFieldUpdateOperationsInput | string
    championTransform?: NullableIntFieldUpdateOperationsInput | number | null
    consumablesPurchased?: NullableIntFieldUpdateOperationsInput | number | null
    damageDealtToBuildings?: NullableIntFieldUpdateOperationsInput | number | null
    damageDealtToObjectives?: NullableIntFieldUpdateOperationsInput | number | null
    damageDealtToTurrets?: NullableIntFieldUpdateOperationsInput | number | null
    damageSelfMitigated?: NullableIntFieldUpdateOperationsInput | number | null
    deaths?: NullableIntFieldUpdateOperationsInput | number | null
    detectorWardsPlaced?: NullableIntFieldUpdateOperationsInput | number | null
    doubleKills?: NullableIntFieldUpdateOperationsInput | number | null
    dragonKills?: NullableIntFieldUpdateOperationsInput | number | null
    firstBlood?: BoolFieldUpdateOperationsInput | boolean
    firstBloodAssist?: BoolFieldUpdateOperationsInput | boolean
    firstTowerKill?: BoolFieldUpdateOperationsInput | boolean
    firstTowerAssist?: BoolFieldUpdateOperationsInput | boolean
    gameEndedInEarlySurrender?: BoolFieldUpdateOperationsInput | boolean
    gameEndedInSurrender?: BoolFieldUpdateOperationsInput | boolean
    goldEarned?: NullableIntFieldUpdateOperationsInput | number | null
    goldSpent?: NullableIntFieldUpdateOperationsInput | number | null
    individualPosition?: StringFieldUpdateOperationsInput | string
    inhibitorKills?: NullableIntFieldUpdateOperationsInput | number | null
    inhibitorTakedowns?: NullableIntFieldUpdateOperationsInput | number | null
    inhibitorsLost?: NullableIntFieldUpdateOperationsInput | number | null
    item0?: NullableIntFieldUpdateOperationsInput | number | null
    item1?: NullableIntFieldUpdateOperationsInput | number | null
    item2?: NullableIntFieldUpdateOperationsInput | number | null
    item3?: NullableIntFieldUpdateOperationsInput | number | null
    item4?: NullableIntFieldUpdateOperationsInput | number | null
    item5?: NullableIntFieldUpdateOperationsInput | number | null
    item6?: NullableIntFieldUpdateOperationsInput | number | null
    itemsPurchased?: NullableIntFieldUpdateOperationsInput | number | null
    killingSprees?: NullableIntFieldUpdateOperationsInput | number | null
    kills?: NullableIntFieldUpdateOperationsInput | number | null
    lane?: StringFieldUpdateOperationsInput | string
    largestCriticalStrike?: NullableIntFieldUpdateOperationsInput | number | null
    largestKillingSpree?: NullableIntFieldUpdateOperationsInput | number | null
    largestMultiKill?: NullableIntFieldUpdateOperationsInput | number | null
    longestTimeSpentLiving?: NullableIntFieldUpdateOperationsInput | number | null
    magicDamageDealt?: NullableIntFieldUpdateOperationsInput | number | null
    magicDamageDealtToChampions?: NullableIntFieldUpdateOperationsInput | number | null
    magicDamageTaken?: NullableIntFieldUpdateOperationsInput | number | null
    neutralMinionsKilled?: NullableIntFieldUpdateOperationsInput | number | null
    nexusKills?: NullableIntFieldUpdateOperationsInput | number | null
    nexusLost?: NullableIntFieldUpdateOperationsInput | number | null
    nexusTakedowns?: NullableIntFieldUpdateOperationsInput | number | null
    objectivesStolen?: NullableIntFieldUpdateOperationsInput | number | null
    objectivesStolenAssists?: NullableIntFieldUpdateOperationsInput | number | null
    participantId?: NullableIntFieldUpdateOperationsInput | number | null
    pentaKills?: NullableIntFieldUpdateOperationsInput | number | null
    physicalDamageDealt?: NullableIntFieldUpdateOperationsInput | number | null
    physicalDamageDealtToChampions?: NullableIntFieldUpdateOperationsInput | number | null
    physicalDamageTaken?: NullableIntFieldUpdateOperationsInput | number | null
    quadraKills?: NullableIntFieldUpdateOperationsInput | number | null
    riotIdName?: StringFieldUpdateOperationsInput | string
    riotIdTagline?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    sightWardsBoughtInGame?: NullableIntFieldUpdateOperationsInput | number | null
    spell1Casts?: NullableIntFieldUpdateOperationsInput | number | null
    spell2Casts?: NullableIntFieldUpdateOperationsInput | number | null
    spell3Casts?: NullableIntFieldUpdateOperationsInput | number | null
    spell4Casts?: NullableIntFieldUpdateOperationsInput | number | null
    summoner1Casts?: NullableIntFieldUpdateOperationsInput | number | null
    summoner1Id?: NullableIntFieldUpdateOperationsInput | number | null
    summoner2Casts?: NullableIntFieldUpdateOperationsInput | number | null
    summoner2Id?: NullableIntFieldUpdateOperationsInput | number | null
    summonerLevel?: NullableIntFieldUpdateOperationsInput | number | null
    summonerName?: StringFieldUpdateOperationsInput | string
    teamEarlySurrendered?: BoolFieldUpdateOperationsInput | boolean
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    teamPosition?: StringFieldUpdateOperationsInput | string
    timeCCingOthers?: NullableIntFieldUpdateOperationsInput | number | null
    timePlayed?: NullableIntFieldUpdateOperationsInput | number | null
    totalDamageDealt?: NullableIntFieldUpdateOperationsInput | number | null
    totalDamageDealtToChampions?: NullableIntFieldUpdateOperationsInput | number | null
    totalDamageShieldedOnTeammates?: NullableIntFieldUpdateOperationsInput | number | null
    totalDamageTaken?: NullableIntFieldUpdateOperationsInput | number | null
    totalHeal?: NullableIntFieldUpdateOperationsInput | number | null
    totalHealsOnTeammates?: NullableIntFieldUpdateOperationsInput | number | null
    totalMinionsKilled?: NullableIntFieldUpdateOperationsInput | number | null
    totalTimeCCDealt?: NullableIntFieldUpdateOperationsInput | number | null
    totalTimeSpentDead?: NullableIntFieldUpdateOperationsInput | number | null
    totalUnitsHealed?: NullableIntFieldUpdateOperationsInput | number | null
    tripleKills?: NullableIntFieldUpdateOperationsInput | number | null
    trueDamageDealt?: NullableIntFieldUpdateOperationsInput | number | null
    trueDamageDealtToChampions?: NullableIntFieldUpdateOperationsInput | number | null
    trueDamageTaken?: NullableIntFieldUpdateOperationsInput | number | null
    turretsKilled?: NullableIntFieldUpdateOperationsInput | number | null
    turretTakedowns?: NullableIntFieldUpdateOperationsInput | number | null
    turretsLost?: NullableIntFieldUpdateOperationsInput | number | null
    unrealKills?: NullableIntFieldUpdateOperationsInput | number | null
    visionScore?: NullableIntFieldUpdateOperationsInput | number | null
    visionWardsBoughtInGame?: NullableIntFieldUpdateOperationsInput | number | null
    wardsKilled?: NullableIntFieldUpdateOperationsInput | number | null
    wardsPlaced?: NullableIntFieldUpdateOperationsInput | number | null
    win?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PlayerItemCreateInput = {
    id?: string
    slot?: number | null
    itemId?: number | null
    name?: string
    playerEndOfGameStat?: PlayerEndOfGameStatCreateNestedManyWithoutItemsInput
  }

  export type PlayerItemUncheckedCreateInput = {
    id?: string
    slot?: number | null
    itemId?: number | null
    name?: string
    playerEndOfGameStat?: PlayerEndOfGameStatUncheckedCreateNestedManyWithoutItemsInput
  }

  export type PlayerItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slot?: NullableIntFieldUpdateOperationsInput | number | null
    itemId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    playerEndOfGameStat?: PlayerEndOfGameStatUpdateManyWithoutItemsInput
  }

  export type PlayerItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slot?: NullableIntFieldUpdateOperationsInput | number | null
    itemId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    playerEndOfGameStat?: PlayerEndOfGameStatUncheckedUpdateManyWithoutItemsInput
  }

  export type PlayerItemCreateManyInput = {
    id?: string
    slot?: number | null
    itemId?: number | null
    name?: string
  }

  export type PlayerItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    slot?: NullableIntFieldUpdateOperationsInput | number | null
    itemId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
  }

  export type PlayerItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    slot?: NullableIntFieldUpdateOperationsInput | number | null
    itemId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
  }

  export type PlayerItemEventCreateInput = {
    id?: string
    player?: PlayerCreateNestedManyWithoutItemEventInput
    type?: string
    itemId?: number | null
    name?: string
    undoId?: number | null
  }

  export type PlayerItemEventUncheckedCreateInput = {
    id?: string
    player?: PlayerUncheckedCreateNestedManyWithoutItemEventInput
    type?: string
    itemId?: number | null
    name?: string
    undoId?: number | null
  }

  export type PlayerItemEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    player?: PlayerUpdateManyWithoutItemEventInput
    type?: StringFieldUpdateOperationsInput | string
    itemId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    undoId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PlayerItemEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    player?: PlayerUncheckedUpdateManyWithoutItemEventInput
    type?: StringFieldUpdateOperationsInput | string
    itemId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    undoId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PlayerItemEventCreateManyInput = {
    id?: string
    type?: string
    itemId?: number | null
    name?: string
    undoId?: number | null
  }

  export type PlayerItemEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    itemId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    undoId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PlayerItemEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    itemId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    undoId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PlayerKillCreateInput = {
    id?: string
    killer?: PlayerCreateNestedManyWithoutKillsInput
    victim?: PlayerCreateNestedManyWithoutDeathsInput
  }

  export type PlayerKillUncheckedCreateInput = {
    id?: string
    killer?: PlayerUncheckedCreateNestedManyWithoutKillsInput
    victim?: PlayerUncheckedCreateNestedManyWithoutDeathsInput
  }

  export type PlayerKillUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    killer?: PlayerUpdateManyWithoutKillsInput
    victim?: PlayerUpdateManyWithoutDeathsInput
  }

  export type PlayerKillUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    killer?: PlayerUncheckedUpdateManyWithoutKillsInput
    victim?: PlayerUncheckedUpdateManyWithoutDeathsInput
  }

  export type PlayerKillCreateManyInput = {
    id?: string
  }

  export type PlayerKillUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type PlayerKillUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type PlayerRuneCreateInput = {
    id?: string
    playerEndOfGameStat?: PlayerEndOfGameStatCreateNestedOneWithoutPerksInput
    runeStyle?: RuneStyleCreateNestedManyWithoutPlayerRunesInput
    defense?: number | null
    flex?: number | null
    offense?: number | null
  }

  export type PlayerRuneUncheckedCreateInput = {
    id?: string
    playerEndOfGameStat?: PlayerEndOfGameStatUncheckedCreateNestedOneWithoutPerksInput
    runeStyle?: RuneStyleUncheckedCreateNestedManyWithoutPlayerRunesInput
    defense?: number | null
    flex?: number | null
    offense?: number | null
  }

  export type PlayerRuneUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerEndOfGameStat?: PlayerEndOfGameStatUpdateOneWithoutPerksInput
    runeStyle?: RuneStyleUpdateManyWithoutPlayerRunesInput
    defense?: NullableIntFieldUpdateOperationsInput | number | null
    flex?: NullableIntFieldUpdateOperationsInput | number | null
    offense?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PlayerRuneUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerEndOfGameStat?: PlayerEndOfGameStatUncheckedUpdateOneWithoutPerksInput
    runeStyle?: RuneStyleUncheckedUpdateManyWithoutPlayerRunesInput
    defense?: NullableIntFieldUpdateOperationsInput | number | null
    flex?: NullableIntFieldUpdateOperationsInput | number | null
    offense?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PlayerRuneCreateManyInput = {
    id?: string
    defense?: number | null
    flex?: number | null
    offense?: number | null
  }

  export type PlayerRuneUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    defense?: NullableIntFieldUpdateOperationsInput | number | null
    flex?: NullableIntFieldUpdateOperationsInput | number | null
    offense?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PlayerRuneUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    defense?: NullableIntFieldUpdateOperationsInput | number | null
    flex?: NullableIntFieldUpdateOperationsInput | number | null
    offense?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PlayerSkillLevelUpEventCreateInput = {
    id?: string
    player?: PlayerCreateNestedManyWithoutSkillLevelUpEventsInput
    type?: string
    slot?: number | null
  }

  export type PlayerSkillLevelUpEventUncheckedCreateInput = {
    id?: string
    player?: PlayerUncheckedCreateNestedManyWithoutSkillLevelUpEventsInput
    type?: string
    slot?: number | null
  }

  export type PlayerSkillLevelUpEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    player?: PlayerUpdateManyWithoutSkillLevelUpEventsInput
    type?: StringFieldUpdateOperationsInput | string
    slot?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PlayerSkillLevelUpEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    player?: PlayerUncheckedUpdateManyWithoutSkillLevelUpEventsInput
    type?: StringFieldUpdateOperationsInput | string
    slot?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PlayerSkillLevelUpEventCreateManyInput = {
    id?: string
    type?: string
    slot?: number | null
  }

  export type PlayerSkillLevelUpEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    slot?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PlayerSkillLevelUpEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    slot?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PlayerSnapshotCreateInput = {
    id?: string
    timestamp?: number | null
    currentGold?: number | null
    totalGold?: number | null
    totalGoldDiff?: number | null
    xp?: number | null
    xpDiff?: number | null
    level?: number | null
    cs?: number | null
    csDiff?: number | null
    monstersKilled?: number | null
    monstersKilledDiff?: number | null
    position?: PositionCreateNestedManyWithoutPlayerSnapshotInput
    player?: PlayerCreateNestedManyWithoutSnapshotsInput
  }

  export type PlayerSnapshotUncheckedCreateInput = {
    id?: string
    timestamp?: number | null
    currentGold?: number | null
    totalGold?: number | null
    totalGoldDiff?: number | null
    xp?: number | null
    xpDiff?: number | null
    level?: number | null
    cs?: number | null
    csDiff?: number | null
    monstersKilled?: number | null
    monstersKilledDiff?: number | null
    position?: PositionUncheckedCreateNestedManyWithoutPlayerSnapshotInput
    player?: PlayerUncheckedCreateNestedManyWithoutSnapshotsInput
  }

  export type PlayerSnapshotUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: NullableFloatFieldUpdateOperationsInput | number | null
    currentGold?: NullableIntFieldUpdateOperationsInput | number | null
    totalGold?: NullableIntFieldUpdateOperationsInput | number | null
    totalGoldDiff?: NullableIntFieldUpdateOperationsInput | number | null
    xp?: NullableIntFieldUpdateOperationsInput | number | null
    xpDiff?: NullableIntFieldUpdateOperationsInput | number | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    cs?: NullableIntFieldUpdateOperationsInput | number | null
    csDiff?: NullableIntFieldUpdateOperationsInput | number | null
    monstersKilled?: NullableIntFieldUpdateOperationsInput | number | null
    monstersKilledDiff?: NullableIntFieldUpdateOperationsInput | number | null
    position?: PositionUpdateManyWithoutPlayerSnapshotInput
    player?: PlayerUpdateManyWithoutSnapshotsInput
  }

  export type PlayerSnapshotUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: NullableFloatFieldUpdateOperationsInput | number | null
    currentGold?: NullableIntFieldUpdateOperationsInput | number | null
    totalGold?: NullableIntFieldUpdateOperationsInput | number | null
    totalGoldDiff?: NullableIntFieldUpdateOperationsInput | number | null
    xp?: NullableIntFieldUpdateOperationsInput | number | null
    xpDiff?: NullableIntFieldUpdateOperationsInput | number | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    cs?: NullableIntFieldUpdateOperationsInput | number | null
    csDiff?: NullableIntFieldUpdateOperationsInput | number | null
    monstersKilled?: NullableIntFieldUpdateOperationsInput | number | null
    monstersKilledDiff?: NullableIntFieldUpdateOperationsInput | number | null
    position?: PositionUncheckedUpdateManyWithoutPlayerSnapshotInput
    player?: PlayerUncheckedUpdateManyWithoutSnapshotsInput
  }

  export type PlayerSnapshotCreateManyInput = {
    id?: string
    timestamp?: number | null
    currentGold?: number | null
    totalGold?: number | null
    totalGoldDiff?: number | null
    xp?: number | null
    xpDiff?: number | null
    level?: number | null
    cs?: number | null
    csDiff?: number | null
    monstersKilled?: number | null
    monstersKilledDiff?: number | null
  }

  export type PlayerSnapshotUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: NullableFloatFieldUpdateOperationsInput | number | null
    currentGold?: NullableIntFieldUpdateOperationsInput | number | null
    totalGold?: NullableIntFieldUpdateOperationsInput | number | null
    totalGoldDiff?: NullableIntFieldUpdateOperationsInput | number | null
    xp?: NullableIntFieldUpdateOperationsInput | number | null
    xpDiff?: NullableIntFieldUpdateOperationsInput | number | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    cs?: NullableIntFieldUpdateOperationsInput | number | null
    csDiff?: NullableIntFieldUpdateOperationsInput | number | null
    monstersKilled?: NullableIntFieldUpdateOperationsInput | number | null
    monstersKilledDiff?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PlayerSnapshotUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: NullableFloatFieldUpdateOperationsInput | number | null
    currentGold?: NullableIntFieldUpdateOperationsInput | number | null
    totalGold?: NullableIntFieldUpdateOperationsInput | number | null
    totalGoldDiff?: NullableIntFieldUpdateOperationsInput | number | null
    xp?: NullableIntFieldUpdateOperationsInput | number | null
    xpDiff?: NullableIntFieldUpdateOperationsInput | number | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    cs?: NullableIntFieldUpdateOperationsInput | number | null
    csDiff?: NullableIntFieldUpdateOperationsInput | number | null
    monstersKilled?: NullableIntFieldUpdateOperationsInput | number | null
    monstersKilledDiff?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PlayerWardEventCreateInput = {
    id?: string
    player?: PlayerCreateNestedManyWithoutWardEventsInput
    type?: string
    wardType?: PlayerWardEventWardTypeType | null
  }

  export type PlayerWardEventUncheckedCreateInput = {
    id?: string
    player?: PlayerUncheckedCreateNestedManyWithoutWardEventsInput
    type?: string
    wardType?: PlayerWardEventWardTypeType | null
  }

  export type PlayerWardEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    player?: PlayerUpdateManyWithoutWardEventsInput
    type?: StringFieldUpdateOperationsInput | string
    wardType?: NullableEnumPlayerWardEventWardTypeTypeFieldUpdateOperationsInput | PlayerWardEventWardTypeType | null
  }

  export type PlayerWardEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    player?: PlayerUncheckedUpdateManyWithoutWardEventsInput
    type?: StringFieldUpdateOperationsInput | string
    wardType?: NullableEnumPlayerWardEventWardTypeTypeFieldUpdateOperationsInput | PlayerWardEventWardTypeType | null
  }

  export type PlayerWardEventCreateManyInput = {
    id?: string
    type?: string
    wardType?: PlayerWardEventWardTypeType | null
  }

  export type PlayerWardEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    wardType?: NullableEnumPlayerWardEventWardTypeTypeFieldUpdateOperationsInput | PlayerWardEventWardTypeType | null
  }

  export type PlayerWardEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    wardType?: NullableEnumPlayerWardEventWardTypeTypeFieldUpdateOperationsInput | PlayerWardEventWardTypeType | null
  }

  export type PositionCreateInput = {
    id?: string
    event?: EventCreateNestedManyWithoutPositionInput
    x?: number | null
    y?: number | null
    playerSnapshot?: PlayerSnapshotCreateNestedManyWithoutPositionInput
  }

  export type PositionUncheckedCreateInput = {
    id?: string
    event?: EventUncheckedCreateNestedManyWithoutPositionInput
    x?: number | null
    y?: number | null
    playerSnapshot?: PlayerSnapshotUncheckedCreateNestedManyWithoutPositionInput
  }

  export type PositionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    event?: EventUpdateManyWithoutPositionInput
    x?: NullableIntFieldUpdateOperationsInput | number | null
    y?: NullableIntFieldUpdateOperationsInput | number | null
    playerSnapshot?: PlayerSnapshotUpdateManyWithoutPositionInput
  }

  export type PositionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    event?: EventUncheckedUpdateManyWithoutPositionInput
    x?: NullableIntFieldUpdateOperationsInput | number | null
    y?: NullableIntFieldUpdateOperationsInput | number | null
    playerSnapshot?: PlayerSnapshotUncheckedUpdateManyWithoutPositionInput
  }

  export type PositionCreateManyInput = {
    id?: string
    x?: number | null
    y?: number | null
  }

  export type PositionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    x?: NullableIntFieldUpdateOperationsInput | number | null
    y?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PositionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    x?: NullableIntFieldUpdateOperationsInput | number | null
    y?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProfileCreateInput = {
    id?: string
    update?: boolean
    player?: PlayerCreateNestedOneWithoutProfileInput
    lastUpdate?: Date | string
    kills?: number | null
    deaths?: number | null
    assists?: number | null
    kda?: string
    winRate?: string
    csPerMinute?: string
    damagePerMinute?: string
    killsPerMinute?: string
    goldPerMinute?: string
    averageGameTime?: string
    averageTimeSpentDead?: string
    totalGameTime?: string
    activity?: ActivityCreateNestedManyWithoutProfileInput
    championWinrate?: ChampionWinrateCreateNestedManyWithoutProfileInput
    duos?: DuoCreateNestedManyWithoutProfileInput
  }

  export type ProfileUncheckedCreateInput = {
    id?: string
    update?: boolean
    player?: PlayerUncheckedCreateNestedOneWithoutProfileInput
    lastUpdate?: Date | string
    kills?: number | null
    deaths?: number | null
    assists?: number | null
    kda?: string
    winRate?: string
    csPerMinute?: string
    damagePerMinute?: string
    killsPerMinute?: string
    goldPerMinute?: string
    averageGameTime?: string
    averageTimeSpentDead?: string
    totalGameTime?: string
    activity?: ActivityUncheckedCreateNestedManyWithoutProfileInput
    championWinrate?: ChampionWinrateUncheckedCreateNestedManyWithoutProfileInput
    duos?: DuoUncheckedCreateNestedManyWithoutProfileInput
  }

  export type ProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    update?: BoolFieldUpdateOperationsInput | boolean
    player?: PlayerUpdateOneWithoutProfileInput
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    kills?: NullableIntFieldUpdateOperationsInput | number | null
    deaths?: NullableIntFieldUpdateOperationsInput | number | null
    assists?: NullableIntFieldUpdateOperationsInput | number | null
    kda?: StringFieldUpdateOperationsInput | string
    winRate?: StringFieldUpdateOperationsInput | string
    csPerMinute?: StringFieldUpdateOperationsInput | string
    damagePerMinute?: StringFieldUpdateOperationsInput | string
    killsPerMinute?: StringFieldUpdateOperationsInput | string
    goldPerMinute?: StringFieldUpdateOperationsInput | string
    averageGameTime?: StringFieldUpdateOperationsInput | string
    averageTimeSpentDead?: StringFieldUpdateOperationsInput | string
    totalGameTime?: StringFieldUpdateOperationsInput | string
    activity?: ActivityUpdateManyWithoutProfileInput
    championWinrate?: ChampionWinrateUpdateManyWithoutProfileInput
    duos?: DuoUpdateManyWithoutProfileInput
  }

  export type ProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    update?: BoolFieldUpdateOperationsInput | boolean
    player?: PlayerUncheckedUpdateOneWithoutProfileInput
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    kills?: NullableIntFieldUpdateOperationsInput | number | null
    deaths?: NullableIntFieldUpdateOperationsInput | number | null
    assists?: NullableIntFieldUpdateOperationsInput | number | null
    kda?: StringFieldUpdateOperationsInput | string
    winRate?: StringFieldUpdateOperationsInput | string
    csPerMinute?: StringFieldUpdateOperationsInput | string
    damagePerMinute?: StringFieldUpdateOperationsInput | string
    killsPerMinute?: StringFieldUpdateOperationsInput | string
    goldPerMinute?: StringFieldUpdateOperationsInput | string
    averageGameTime?: StringFieldUpdateOperationsInput | string
    averageTimeSpentDead?: StringFieldUpdateOperationsInput | string
    totalGameTime?: StringFieldUpdateOperationsInput | string
    activity?: ActivityUncheckedUpdateManyWithoutProfileInput
    championWinrate?: ChampionWinrateUncheckedUpdateManyWithoutProfileInput
    duos?: DuoUncheckedUpdateManyWithoutProfileInput
  }

  export type ProfileCreateManyInput = {
    id?: string
    update?: boolean
    lastUpdate?: Date | string
    kills?: number | null
    deaths?: number | null
    assists?: number | null
    kda?: string
    winRate?: string
    csPerMinute?: string
    damagePerMinute?: string
    killsPerMinute?: string
    goldPerMinute?: string
    averageGameTime?: string
    averageTimeSpentDead?: string
    totalGameTime?: string
  }

  export type ProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    update?: BoolFieldUpdateOperationsInput | boolean
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    kills?: NullableIntFieldUpdateOperationsInput | number | null
    deaths?: NullableIntFieldUpdateOperationsInput | number | null
    assists?: NullableIntFieldUpdateOperationsInput | number | null
    kda?: StringFieldUpdateOperationsInput | string
    winRate?: StringFieldUpdateOperationsInput | string
    csPerMinute?: StringFieldUpdateOperationsInput | string
    damagePerMinute?: StringFieldUpdateOperationsInput | string
    killsPerMinute?: StringFieldUpdateOperationsInput | string
    goldPerMinute?: StringFieldUpdateOperationsInput | string
    averageGameTime?: StringFieldUpdateOperationsInput | string
    averageTimeSpentDead?: StringFieldUpdateOperationsInput | string
    totalGameTime?: StringFieldUpdateOperationsInput | string
  }

  export type ProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    update?: BoolFieldUpdateOperationsInput | boolean
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    kills?: NullableIntFieldUpdateOperationsInput | number | null
    deaths?: NullableIntFieldUpdateOperationsInput | number | null
    assists?: NullableIntFieldUpdateOperationsInput | number | null
    kda?: StringFieldUpdateOperationsInput | string
    winRate?: StringFieldUpdateOperationsInput | string
    csPerMinute?: StringFieldUpdateOperationsInput | string
    damagePerMinute?: StringFieldUpdateOperationsInput | string
    killsPerMinute?: StringFieldUpdateOperationsInput | string
    goldPerMinute?: StringFieldUpdateOperationsInput | string
    averageGameTime?: StringFieldUpdateOperationsInput | string
    averageTimeSpentDead?: StringFieldUpdateOperationsInput | string
    totalGameTime?: StringFieldUpdateOperationsInput | string
  }

  export type SeedIdentifierCreateInput = {
    id?: string
    identifier?: string
    type?: string
    timestamp?: Date | string
    priority?: boolean
    retrieved?: boolean
  }

  export type SeedIdentifierUncheckedCreateInput = {
    id?: string
    identifier?: string
    type?: string
    timestamp?: Date | string
    priority?: boolean
    retrieved?: boolean
  }

  export type SeedIdentifierUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    priority?: BoolFieldUpdateOperationsInput | boolean
    retrieved?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SeedIdentifierUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    priority?: BoolFieldUpdateOperationsInput | boolean
    retrieved?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SeedIdentifierCreateManyInput = {
    id?: string
    identifier?: string
    type?: string
    timestamp?: Date | string
    priority?: boolean
    retrieved?: boolean
  }

  export type SeedIdentifierUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    priority?: BoolFieldUpdateOperationsInput | boolean
    retrieved?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SeedIdentifierUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    priority?: BoolFieldUpdateOperationsInput | boolean
    retrieved?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SourceCreateInput = {
    id?: string
    game?: GameCreateNestedManyWithoutSourceInput
    api?: string
  }

  export type SourceUncheckedCreateInput = {
    id?: string
    game?: GameUncheckedCreateNestedManyWithoutSourceInput
    api?: string
  }

  export type SourceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    game?: GameUpdateManyWithoutSourceInput
    api?: StringFieldUpdateOperationsInput | string
  }

  export type SourceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    game?: GameUncheckedUpdateManyWithoutSourceInput
    api?: StringFieldUpdateOperationsInput | string
  }

  export type SourceCreateManyInput = {
    id?: string
    api?: string
  }

  export type SourceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    api?: StringFieldUpdateOperationsInput | string
  }

  export type SourceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    api?: StringFieldUpdateOperationsInput | string
  }

  export type TeamCreateInput = {
    id?: string
    pickBan?: PickBanCreateNestedManyWithoutTeamInput
    game?: GameCreateNestedOneWithoutFrom_Team_gameInput
    players?: PlayerCreateNestedManyWithoutTeamsInput
    objectives?: ObjectiveCreateNestedManyWithoutTeamInput
    teamId?: number | null
    teamMatchId?: string
    win?: boolean
    from_Game_blueTeam?: GameCreateNestedManyWithoutBlueTeamInput
    from_Game_redTeam?: GameCreateNestedManyWithoutRedTeamInput
  }

  export type TeamUncheckedCreateInput = {
    id?: string
    pickBan?: PickBanUncheckedCreateNestedManyWithoutTeamInput
    gameId?: string | null
    players?: PlayerUncheckedCreateNestedManyWithoutTeamsInput
    objectives?: ObjectiveUncheckedCreateNestedManyWithoutTeamInput
    teamId?: number | null
    teamMatchId?: string
    win?: boolean
    from_Game_blueTeam?: GameUncheckedCreateNestedManyWithoutBlueTeamInput
    from_Game_redTeam?: GameUncheckedCreateNestedManyWithoutRedTeamInput
  }

  export type TeamUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    pickBan?: PickBanUpdateManyWithoutTeamInput
    game?: GameUpdateOneWithoutFrom_Team_gameInput
    players?: PlayerUpdateManyWithoutTeamsInput
    objectives?: ObjectiveUpdateManyWithoutTeamInput
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    teamMatchId?: StringFieldUpdateOperationsInput | string
    win?: BoolFieldUpdateOperationsInput | boolean
    from_Game_blueTeam?: GameUpdateManyWithoutBlueTeamInput
    from_Game_redTeam?: GameUpdateManyWithoutRedTeamInput
  }

  export type TeamUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    pickBan?: PickBanUncheckedUpdateManyWithoutTeamInput
    gameId?: NullableStringFieldUpdateOperationsInput | string | null
    players?: PlayerUncheckedUpdateManyWithoutTeamsInput
    objectives?: ObjectiveUncheckedUpdateManyWithoutTeamInput
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    teamMatchId?: StringFieldUpdateOperationsInput | string
    win?: BoolFieldUpdateOperationsInput | boolean
    from_Game_blueTeam?: GameUncheckedUpdateManyWithoutBlueTeamInput
    from_Game_redTeam?: GameUncheckedUpdateManyWithoutRedTeamInput
  }

  export type TeamCreateManyInput = {
    id?: string
    gameId?: string | null
    teamId?: number | null
    teamMatchId?: string
    win?: boolean
  }

  export type TeamUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    teamMatchId?: StringFieldUpdateOperationsInput | string
    win?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TeamUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    teamMatchId?: StringFieldUpdateOperationsInput | string
    win?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TeamBuildingKillCreateInput = {
    id?: string
    killer?: PlayerCreateNestedManyWithoutBuildingKillsInput
    type?: string
    lane?: string
    side?: string
    towerLocation?: string
  }

  export type TeamBuildingKillUncheckedCreateInput = {
    id?: string
    killer?: PlayerUncheckedCreateNestedManyWithoutBuildingKillsInput
    type?: string
    lane?: string
    side?: string
    towerLocation?: string
  }

  export type TeamBuildingKillUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    killer?: PlayerUpdateManyWithoutBuildingKillsInput
    type?: StringFieldUpdateOperationsInput | string
    lane?: StringFieldUpdateOperationsInput | string
    side?: StringFieldUpdateOperationsInput | string
    towerLocation?: StringFieldUpdateOperationsInput | string
  }

  export type TeamBuildingKillUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    killer?: PlayerUncheckedUpdateManyWithoutBuildingKillsInput
    type?: StringFieldUpdateOperationsInput | string
    lane?: StringFieldUpdateOperationsInput | string
    side?: StringFieldUpdateOperationsInput | string
    towerLocation?: StringFieldUpdateOperationsInput | string
  }

  export type TeamBuildingKillCreateManyInput = {
    id?: string
    type?: string
    lane?: string
    side?: string
    towerLocation?: string
  }

  export type TeamBuildingKillUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    lane?: StringFieldUpdateOperationsInput | string
    side?: StringFieldUpdateOperationsInput | string
    towerLocation?: StringFieldUpdateOperationsInput | string
  }

  export type TeamBuildingKillUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    lane?: StringFieldUpdateOperationsInput | string
    side?: StringFieldUpdateOperationsInput | string
    towerLocation?: StringFieldUpdateOperationsInput | string
  }

  export type TeamMonsterKillCreateInput = {
    id?: string
    killer?: PlayerCreateNestedManyWithoutMonsterKillsInput
    type?: string
    subType?: string
  }

  export type TeamMonsterKillUncheckedCreateInput = {
    id?: string
    killer?: PlayerUncheckedCreateNestedManyWithoutMonsterKillsInput
    type?: string
    subType?: string
  }

  export type TeamMonsterKillUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    killer?: PlayerUpdateManyWithoutMonsterKillsInput
    type?: StringFieldUpdateOperationsInput | string
    subType?: StringFieldUpdateOperationsInput | string
  }

  export type TeamMonsterKillUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    killer?: PlayerUncheckedUpdateManyWithoutMonsterKillsInput
    type?: StringFieldUpdateOperationsInput | string
    subType?: StringFieldUpdateOperationsInput | string
  }

  export type TeamMonsterKillCreateManyInput = {
    id?: string
    type?: string
    subType?: string
  }

  export type TeamMonsterKillUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    subType?: StringFieldUpdateOperationsInput | string
  }

  export type TeamMonsterKillUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    subType?: StringFieldUpdateOperationsInput | string
  }

  export type RuneSelectionCreateInput = {
    id?: string
    runeStyle?: RuneStyleCreateNestedOneWithoutSelectionInput
    perk?: number | null
    var1?: number | null
    var2?: number | null
    var3?: number | null
  }

  export type RuneSelectionUncheckedCreateInput = {
    id?: string
    runeStyleId?: string | null
    perk?: number | null
    var1?: number | null
    var2?: number | null
    var3?: number | null
  }

  export type RuneSelectionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    runeStyle?: RuneStyleUpdateOneWithoutSelectionInput
    perk?: NullableIntFieldUpdateOperationsInput | number | null
    var1?: NullableIntFieldUpdateOperationsInput | number | null
    var2?: NullableIntFieldUpdateOperationsInput | number | null
    var3?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RuneSelectionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    runeStyleId?: NullableStringFieldUpdateOperationsInput | string | null
    perk?: NullableIntFieldUpdateOperationsInput | number | null
    var1?: NullableIntFieldUpdateOperationsInput | number | null
    var2?: NullableIntFieldUpdateOperationsInput | number | null
    var3?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RuneSelectionCreateManyInput = {
    id?: string
    runeStyleId?: string | null
    perk?: number | null
    var1?: number | null
    var2?: number | null
    var3?: number | null
  }

  export type RuneSelectionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    perk?: NullableIntFieldUpdateOperationsInput | number | null
    var1?: NullableIntFieldUpdateOperationsInput | number | null
    var2?: NullableIntFieldUpdateOperationsInput | number | null
    var3?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RuneSelectionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    runeStyleId?: NullableStringFieldUpdateOperationsInput | string | null
    perk?: NullableIntFieldUpdateOperationsInput | number | null
    var1?: NullableIntFieldUpdateOperationsInput | number | null
    var2?: NullableIntFieldUpdateOperationsInput | number | null
    var3?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RuneStyleCreateInput = {
    id?: string
    playerRunes?: PlayerRuneCreateNestedOneWithoutRuneStyleInput
    selection?: RuneSelectionCreateNestedManyWithoutRuneStyleInput
    description?: string
    style?: number | null
  }

  export type RuneStyleUncheckedCreateInput = {
    id?: string
    playerRunesId?: string | null
    selection?: RuneSelectionUncheckedCreateNestedManyWithoutRuneStyleInput
    description?: string
    style?: number | null
  }

  export type RuneStyleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerRunes?: PlayerRuneUpdateOneWithoutRuneStyleInput
    selection?: RuneSelectionUpdateManyWithoutRuneStyleInput
    description?: StringFieldUpdateOperationsInput | string
    style?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RuneStyleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerRunesId?: NullableStringFieldUpdateOperationsInput | string | null
    selection?: RuneSelectionUncheckedUpdateManyWithoutRuneStyleInput
    description?: StringFieldUpdateOperationsInput | string
    style?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RuneStyleCreateManyInput = {
    id?: string
    playerRunesId?: string | null
    description?: string
    style?: number | null
  }

  export type RuneStyleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    style?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RuneStyleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerRunesId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    style?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringFilter | string
  }

  export type ProfileRelationFilter = {
    is?: ProfileWhereInput | null
    isNot?: ProfileWhereInput | null
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableFilter | string | null
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type ActivityCountOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    month?: SortOrder
    year?: SortOrder
    day?: SortOrder
    gamesPlayed?: SortOrder
  }

  export type ActivityAvgOrderByAggregateInput = {
    month?: SortOrder
    year?: SortOrder
    day?: SortOrder
    gamesPlayed?: SortOrder
  }

  export type ActivityMaxOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    month?: SortOrder
    year?: SortOrder
    day?: SortOrder
    gamesPlayed?: SortOrder
  }

  export type ActivityMinOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    month?: SortOrder
    year?: SortOrder
    day?: SortOrder
    gamesPlayed?: SortOrder
  }

  export type ActivitySumOrderByAggregateInput = {
    month?: SortOrder
    year?: SortOrder
    day?: SortOrder
    gamesPlayed?: SortOrder
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type IntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type ChampionWinrateCountOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    champion?: SortOrder
    wins?: SortOrder
    games?: SortOrder
    spell1Casts?: SortOrder
    spell2Casts?: SortOrder
    spell3Casts?: SortOrder
    spell4Casts?: SortOrder
  }

  export type ChampionWinrateAvgOrderByAggregateInput = {
    wins?: SortOrder
    games?: SortOrder
    spell1Casts?: SortOrder
    spell2Casts?: SortOrder
    spell3Casts?: SortOrder
    spell4Casts?: SortOrder
  }

  export type ChampionWinrateMaxOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    champion?: SortOrder
    wins?: SortOrder
    games?: SortOrder
    spell1Casts?: SortOrder
    spell2Casts?: SortOrder
    spell3Casts?: SortOrder
    spell4Casts?: SortOrder
  }

  export type ChampionWinrateMinOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    champion?: SortOrder
    wins?: SortOrder
    games?: SortOrder
    spell1Casts?: SortOrder
    spell2Casts?: SortOrder
    spell3Casts?: SortOrder
    spell4Casts?: SortOrder
  }

  export type ChampionWinrateSumOrderByAggregateInput = {
    wins?: SortOrder
    games?: SortOrder
    spell1Casts?: SortOrder
    spell2Casts?: SortOrder
    spell3Casts?: SortOrder
    spell4Casts?: SortOrder
  }

  export type DuoCountOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    name?: SortOrder
    wins?: SortOrder
    losses?: SortOrder
    winrate?: SortOrder
  }

  export type DuoAvgOrderByAggregateInput = {
    wins?: SortOrder
    losses?: SortOrder
  }

  export type DuoMaxOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    name?: SortOrder
    wins?: SortOrder
    losses?: SortOrder
    winrate?: SortOrder
  }

  export type DuoMinOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    name?: SortOrder
    wins?: SortOrder
    losses?: SortOrder
    winrate?: SortOrder
  }

  export type DuoSumOrderByAggregateInput = {
    wins?: SortOrder
    losses?: SortOrder
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type ConstantCountOrderByAggregateInput = {
    id?: SortOrder
    startTime?: SortOrder
    currentSeason?: SortOrder
    seeding?: SortOrder
  }

  export type ConstantMaxOrderByAggregateInput = {
    id?: SortOrder
    startTime?: SortOrder
    currentSeason?: SortOrder
    seeding?: SortOrder
  }

  export type ConstantMinOrderByAggregateInput = {
    id?: SortOrder
    startTime?: SortOrder
    currentSeason?: SortOrder
    seeding?: SortOrder
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type PositionListRelationFilter = {
    every?: PositionWhereInput
    some?: PositionWhereInput
    none?: PositionWhereInput
  }

  export type PositionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EventCountOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
  }

  export type EventAvgOrderByAggregateInput = {
    timestamp?: SortOrder
  }

  export type EventMaxOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
  }

  export type EventMinOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
  }

  export type EventSumOrderByAggregateInput = {
    timestamp?: SortOrder
  }

  export type TeamRelationFilter = {
    is?: TeamWhereInput | null
    isNot?: TeamWhereInput | null
  }

  export type SourceListRelationFilter = {
    every?: SourceWhereInput
    some?: SourceWhereInput
    none?: SourceWhereInput
  }

  export type PlayerEndOfGameStatListRelationFilter = {
    every?: PlayerEndOfGameStatWhereInput
    some?: PlayerEndOfGameStatWhereInput
    none?: PlayerEndOfGameStatWhereInput
  }

  export type TeamListRelationFilter = {
    every?: TeamWhereInput
    some?: TeamWhereInput
    none?: TeamWhereInput
  }

  export type SourceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlayerEndOfGameStatOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeamOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GameCountOrderByAggregateInput = {
    id?: SortOrder
    matchId?: SortOrder
    gameId?: SortOrder
    gameCreation?: SortOrder
    gameStartTimestamp?: SortOrder
    gameEndTimestamp?: SortOrder
    duration?: SortOrder
    start?: SortOrder
    gameVersion?: SortOrder
    blueTeamId?: SortOrder
    redTeamId?: SortOrder
    tournament?: SortOrder
    gameInSeries?: SortOrder
    vod?: SortOrder
    platformId?: SortOrder
  }

  export type GameAvgOrderByAggregateInput = {
    duration?: SortOrder
    gameInSeries?: SortOrder
  }

  export type GameMaxOrderByAggregateInput = {
    id?: SortOrder
    matchId?: SortOrder
    gameId?: SortOrder
    gameCreation?: SortOrder
    gameStartTimestamp?: SortOrder
    gameEndTimestamp?: SortOrder
    duration?: SortOrder
    start?: SortOrder
    gameVersion?: SortOrder
    blueTeamId?: SortOrder
    redTeamId?: SortOrder
    tournament?: SortOrder
    gameInSeries?: SortOrder
    vod?: SortOrder
    platformId?: SortOrder
  }

  export type GameMinOrderByAggregateInput = {
    id?: SortOrder
    matchId?: SortOrder
    gameId?: SortOrder
    gameCreation?: SortOrder
    gameStartTimestamp?: SortOrder
    gameEndTimestamp?: SortOrder
    duration?: SortOrder
    start?: SortOrder
    gameVersion?: SortOrder
    blueTeamId?: SortOrder
    redTeamId?: SortOrder
    tournament?: SortOrder
    gameInSeries?: SortOrder
    vod?: SortOrder
    platformId?: SortOrder
  }

  export type GameSumOrderByAggregateInput = {
    duration?: SortOrder
    gameInSeries?: SortOrder
  }

  export type ObjectiveCountOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    first?: SortOrder
    kills?: SortOrder
    type?: SortOrder
  }

  export type ObjectiveAvgOrderByAggregateInput = {
    kills?: SortOrder
  }

  export type ObjectiveMaxOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    first?: SortOrder
    kills?: SortOrder
    type?: SortOrder
  }

  export type ObjectiveMinOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    first?: SortOrder
    kills?: SortOrder
    type?: SortOrder
  }

  export type ObjectiveSumOrderByAggregateInput = {
    kills?: SortOrder
  }

  export type PickBanCountOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    championId?: SortOrder
    pickTurn?: SortOrder
  }

  export type PickBanAvgOrderByAggregateInput = {
    championId?: SortOrder
    pickTurn?: SortOrder
  }

  export type PickBanMaxOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    championId?: SortOrder
    pickTurn?: SortOrder
  }

  export type PickBanMinOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    championId?: SortOrder
    pickTurn?: SortOrder
  }

  export type PickBanSumOrderByAggregateInput = {
    championId?: SortOrder
    pickTurn?: SortOrder
  }

  export type PlayerKillListRelationFilter = {
    every?: PlayerKillWhereInput
    some?: PlayerKillWhereInput
    none?: PlayerKillWhereInput
  }

  export type TeamMonsterKillListRelationFilter = {
    every?: TeamMonsterKillWhereInput
    some?: TeamMonsterKillWhereInput
    none?: TeamMonsterKillWhereInput
  }

  export type TeamBuildingKillListRelationFilter = {
    every?: TeamBuildingKillWhereInput
    some?: TeamBuildingKillWhereInput
    none?: TeamBuildingKillWhereInput
  }

  export type PlayerItemEventListRelationFilter = {
    every?: PlayerItemEventWhereInput
    some?: PlayerItemEventWhereInput
    none?: PlayerItemEventWhereInput
  }

  export type PlayerSnapshotListRelationFilter = {
    every?: PlayerSnapshotWhereInput
    some?: PlayerSnapshotWhereInput
    none?: PlayerSnapshotWhereInput
  }

  export type PlayerWardEventListRelationFilter = {
    every?: PlayerWardEventWhereInput
    some?: PlayerWardEventWhereInput
    none?: PlayerWardEventWhereInput
  }

  export type PlayerSkillLevelUpEventListRelationFilter = {
    every?: PlayerSkillLevelUpEventWhereInput
    some?: PlayerSkillLevelUpEventWhereInput
    none?: PlayerSkillLevelUpEventWhereInput
  }

  export type PlayerKillOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeamMonsterKillOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeamBuildingKillOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlayerItemEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlayerSnapshotOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlayerWardEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlayerSkillLevelUpEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlayerCountOrderByAggregateInput = {
    id?: SortOrder
    puuid?: SortOrder
    accountId?: SortOrder
    platformId?: SortOrder
    summonerId?: SortOrder
    summonerName?: SortOrder
    summonerLevel?: SortOrder
    profileIconId?: SortOrder
    revisionDate?: SortOrder
    profileId?: SortOrder
  }

  export type PlayerAvgOrderByAggregateInput = {
    summonerLevel?: SortOrder
    profileIconId?: SortOrder
  }

  export type PlayerMaxOrderByAggregateInput = {
    id?: SortOrder
    puuid?: SortOrder
    accountId?: SortOrder
    platformId?: SortOrder
    summonerId?: SortOrder
    summonerName?: SortOrder
    summonerLevel?: SortOrder
    profileIconId?: SortOrder
    revisionDate?: SortOrder
    profileId?: SortOrder
  }

  export type PlayerMinOrderByAggregateInput = {
    id?: SortOrder
    puuid?: SortOrder
    accountId?: SortOrder
    platformId?: SortOrder
    summonerId?: SortOrder
    summonerName?: SortOrder
    summonerLevel?: SortOrder
    profileIconId?: SortOrder
    revisionDate?: SortOrder
    profileId?: SortOrder
  }

  export type PlayerSumOrderByAggregateInput = {
    summonerLevel?: SortOrder
    profileIconId?: SortOrder
  }

  export type PlayerRelationFilter = {
    is?: PlayerWhereInput | null
    isNot?: PlayerWhereInput | null
  }

  export type GameRelationFilter = {
    is?: GameWhereInput | null
    isNot?: GameWhereInput | null
  }

  export type PlayerRuneRelationFilter = {
    is?: PlayerRuneWhereInput | null
    isNot?: PlayerRuneWhereInput | null
  }

  export type PlayerItemRelationFilter = {
    is?: PlayerItemWhereInput | null
    isNot?: PlayerItemWhereInput | null
  }

  export type PlayerEndOfGameStatCountOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    gameId?: SortOrder
    perksId?: SortOrder
    itemsId?: SortOrder
    assists?: SortOrder
    baronKills?: SortOrder
    bountyLevel?: SortOrder
    championExperience?: SortOrder
    championLevel?: SortOrder
    championId?: SortOrder
    championName?: SortOrder
    championTransform?: SortOrder
    consumablesPurchased?: SortOrder
    damageDealtToBuildings?: SortOrder
    damageDealtToObjectives?: SortOrder
    damageDealtToTurrets?: SortOrder
    damageSelfMitigated?: SortOrder
    deaths?: SortOrder
    detectorWardsPlaced?: SortOrder
    doubleKills?: SortOrder
    dragonKills?: SortOrder
    firstBlood?: SortOrder
    firstBloodAssist?: SortOrder
    firstTowerKill?: SortOrder
    firstTowerAssist?: SortOrder
    gameEndedInEarlySurrender?: SortOrder
    gameEndedInSurrender?: SortOrder
    goldEarned?: SortOrder
    goldSpent?: SortOrder
    individualPosition?: SortOrder
    inhibitorKills?: SortOrder
    inhibitorTakedowns?: SortOrder
    inhibitorsLost?: SortOrder
    item0?: SortOrder
    item1?: SortOrder
    item2?: SortOrder
    item3?: SortOrder
    item4?: SortOrder
    item5?: SortOrder
    item6?: SortOrder
    itemsPurchased?: SortOrder
    killingSprees?: SortOrder
    kills?: SortOrder
    lane?: SortOrder
    largestCriticalStrike?: SortOrder
    largestKillingSpree?: SortOrder
    largestMultiKill?: SortOrder
    longestTimeSpentLiving?: SortOrder
    magicDamageDealt?: SortOrder
    magicDamageDealtToChampions?: SortOrder
    magicDamageTaken?: SortOrder
    neutralMinionsKilled?: SortOrder
    nexusKills?: SortOrder
    nexusLost?: SortOrder
    nexusTakedowns?: SortOrder
    objectivesStolen?: SortOrder
    objectivesStolenAssists?: SortOrder
    participantId?: SortOrder
    pentaKills?: SortOrder
    physicalDamageDealt?: SortOrder
    physicalDamageDealtToChampions?: SortOrder
    physicalDamageTaken?: SortOrder
    quadraKills?: SortOrder
    riotIdName?: SortOrder
    riotIdTagline?: SortOrder
    role?: SortOrder
    sightWardsBoughtInGame?: SortOrder
    spell1Casts?: SortOrder
    spell2Casts?: SortOrder
    spell3Casts?: SortOrder
    spell4Casts?: SortOrder
    summoner1Casts?: SortOrder
    summoner1Id?: SortOrder
    summoner2Casts?: SortOrder
    summoner2Id?: SortOrder
    summonerLevel?: SortOrder
    summonerName?: SortOrder
    teamEarlySurrendered?: SortOrder
    teamId?: SortOrder
    teamPosition?: SortOrder
    timeCCingOthers?: SortOrder
    timePlayed?: SortOrder
    totalDamageDealt?: SortOrder
    totalDamageDealtToChampions?: SortOrder
    totalDamageShieldedOnTeammates?: SortOrder
    totalDamageTaken?: SortOrder
    totalHeal?: SortOrder
    totalHealsOnTeammates?: SortOrder
    totalMinionsKilled?: SortOrder
    totalTimeCCDealt?: SortOrder
    totalTimeSpentDead?: SortOrder
    totalUnitsHealed?: SortOrder
    tripleKills?: SortOrder
    trueDamageDealt?: SortOrder
    trueDamageDealtToChampions?: SortOrder
    trueDamageTaken?: SortOrder
    turretsKilled?: SortOrder
    turretTakedowns?: SortOrder
    turretsLost?: SortOrder
    unrealKills?: SortOrder
    visionScore?: SortOrder
    visionWardsBoughtInGame?: SortOrder
    wardsKilled?: SortOrder
    wardsPlaced?: SortOrder
    win?: SortOrder
  }

  export type PlayerEndOfGameStatAvgOrderByAggregateInput = {
    assists?: SortOrder
    baronKills?: SortOrder
    bountyLevel?: SortOrder
    championExperience?: SortOrder
    championLevel?: SortOrder
    championId?: SortOrder
    championTransform?: SortOrder
    consumablesPurchased?: SortOrder
    damageDealtToBuildings?: SortOrder
    damageDealtToObjectives?: SortOrder
    damageDealtToTurrets?: SortOrder
    damageSelfMitigated?: SortOrder
    deaths?: SortOrder
    detectorWardsPlaced?: SortOrder
    doubleKills?: SortOrder
    dragonKills?: SortOrder
    goldEarned?: SortOrder
    goldSpent?: SortOrder
    inhibitorKills?: SortOrder
    inhibitorTakedowns?: SortOrder
    inhibitorsLost?: SortOrder
    item0?: SortOrder
    item1?: SortOrder
    item2?: SortOrder
    item3?: SortOrder
    item4?: SortOrder
    item5?: SortOrder
    item6?: SortOrder
    itemsPurchased?: SortOrder
    killingSprees?: SortOrder
    kills?: SortOrder
    largestCriticalStrike?: SortOrder
    largestKillingSpree?: SortOrder
    largestMultiKill?: SortOrder
    longestTimeSpentLiving?: SortOrder
    magicDamageDealt?: SortOrder
    magicDamageDealtToChampions?: SortOrder
    magicDamageTaken?: SortOrder
    neutralMinionsKilled?: SortOrder
    nexusKills?: SortOrder
    nexusLost?: SortOrder
    nexusTakedowns?: SortOrder
    objectivesStolen?: SortOrder
    objectivesStolenAssists?: SortOrder
    participantId?: SortOrder
    pentaKills?: SortOrder
    physicalDamageDealt?: SortOrder
    physicalDamageDealtToChampions?: SortOrder
    physicalDamageTaken?: SortOrder
    quadraKills?: SortOrder
    sightWardsBoughtInGame?: SortOrder
    spell1Casts?: SortOrder
    spell2Casts?: SortOrder
    spell3Casts?: SortOrder
    spell4Casts?: SortOrder
    summoner1Casts?: SortOrder
    summoner1Id?: SortOrder
    summoner2Casts?: SortOrder
    summoner2Id?: SortOrder
    summonerLevel?: SortOrder
    teamId?: SortOrder
    timeCCingOthers?: SortOrder
    timePlayed?: SortOrder
    totalDamageDealt?: SortOrder
    totalDamageDealtToChampions?: SortOrder
    totalDamageShieldedOnTeammates?: SortOrder
    totalDamageTaken?: SortOrder
    totalHeal?: SortOrder
    totalHealsOnTeammates?: SortOrder
    totalMinionsKilled?: SortOrder
    totalTimeCCDealt?: SortOrder
    totalTimeSpentDead?: SortOrder
    totalUnitsHealed?: SortOrder
    tripleKills?: SortOrder
    trueDamageDealt?: SortOrder
    trueDamageDealtToChampions?: SortOrder
    trueDamageTaken?: SortOrder
    turretsKilled?: SortOrder
    turretTakedowns?: SortOrder
    turretsLost?: SortOrder
    unrealKills?: SortOrder
    visionScore?: SortOrder
    visionWardsBoughtInGame?: SortOrder
    wardsKilled?: SortOrder
    wardsPlaced?: SortOrder
  }

  export type PlayerEndOfGameStatMaxOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    gameId?: SortOrder
    perksId?: SortOrder
    itemsId?: SortOrder
    assists?: SortOrder
    baronKills?: SortOrder
    bountyLevel?: SortOrder
    championExperience?: SortOrder
    championLevel?: SortOrder
    championId?: SortOrder
    championName?: SortOrder
    championTransform?: SortOrder
    consumablesPurchased?: SortOrder
    damageDealtToBuildings?: SortOrder
    damageDealtToObjectives?: SortOrder
    damageDealtToTurrets?: SortOrder
    damageSelfMitigated?: SortOrder
    deaths?: SortOrder
    detectorWardsPlaced?: SortOrder
    doubleKills?: SortOrder
    dragonKills?: SortOrder
    firstBlood?: SortOrder
    firstBloodAssist?: SortOrder
    firstTowerKill?: SortOrder
    firstTowerAssist?: SortOrder
    gameEndedInEarlySurrender?: SortOrder
    gameEndedInSurrender?: SortOrder
    goldEarned?: SortOrder
    goldSpent?: SortOrder
    individualPosition?: SortOrder
    inhibitorKills?: SortOrder
    inhibitorTakedowns?: SortOrder
    inhibitorsLost?: SortOrder
    item0?: SortOrder
    item1?: SortOrder
    item2?: SortOrder
    item3?: SortOrder
    item4?: SortOrder
    item5?: SortOrder
    item6?: SortOrder
    itemsPurchased?: SortOrder
    killingSprees?: SortOrder
    kills?: SortOrder
    lane?: SortOrder
    largestCriticalStrike?: SortOrder
    largestKillingSpree?: SortOrder
    largestMultiKill?: SortOrder
    longestTimeSpentLiving?: SortOrder
    magicDamageDealt?: SortOrder
    magicDamageDealtToChampions?: SortOrder
    magicDamageTaken?: SortOrder
    neutralMinionsKilled?: SortOrder
    nexusKills?: SortOrder
    nexusLost?: SortOrder
    nexusTakedowns?: SortOrder
    objectivesStolen?: SortOrder
    objectivesStolenAssists?: SortOrder
    participantId?: SortOrder
    pentaKills?: SortOrder
    physicalDamageDealt?: SortOrder
    physicalDamageDealtToChampions?: SortOrder
    physicalDamageTaken?: SortOrder
    quadraKills?: SortOrder
    riotIdName?: SortOrder
    riotIdTagline?: SortOrder
    role?: SortOrder
    sightWardsBoughtInGame?: SortOrder
    spell1Casts?: SortOrder
    spell2Casts?: SortOrder
    spell3Casts?: SortOrder
    spell4Casts?: SortOrder
    summoner1Casts?: SortOrder
    summoner1Id?: SortOrder
    summoner2Casts?: SortOrder
    summoner2Id?: SortOrder
    summonerLevel?: SortOrder
    summonerName?: SortOrder
    teamEarlySurrendered?: SortOrder
    teamId?: SortOrder
    teamPosition?: SortOrder
    timeCCingOthers?: SortOrder
    timePlayed?: SortOrder
    totalDamageDealt?: SortOrder
    totalDamageDealtToChampions?: SortOrder
    totalDamageShieldedOnTeammates?: SortOrder
    totalDamageTaken?: SortOrder
    totalHeal?: SortOrder
    totalHealsOnTeammates?: SortOrder
    totalMinionsKilled?: SortOrder
    totalTimeCCDealt?: SortOrder
    totalTimeSpentDead?: SortOrder
    totalUnitsHealed?: SortOrder
    tripleKills?: SortOrder
    trueDamageDealt?: SortOrder
    trueDamageDealtToChampions?: SortOrder
    trueDamageTaken?: SortOrder
    turretsKilled?: SortOrder
    turretTakedowns?: SortOrder
    turretsLost?: SortOrder
    unrealKills?: SortOrder
    visionScore?: SortOrder
    visionWardsBoughtInGame?: SortOrder
    wardsKilled?: SortOrder
    wardsPlaced?: SortOrder
    win?: SortOrder
  }

  export type PlayerEndOfGameStatMinOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    gameId?: SortOrder
    perksId?: SortOrder
    itemsId?: SortOrder
    assists?: SortOrder
    baronKills?: SortOrder
    bountyLevel?: SortOrder
    championExperience?: SortOrder
    championLevel?: SortOrder
    championId?: SortOrder
    championName?: SortOrder
    championTransform?: SortOrder
    consumablesPurchased?: SortOrder
    damageDealtToBuildings?: SortOrder
    damageDealtToObjectives?: SortOrder
    damageDealtToTurrets?: SortOrder
    damageSelfMitigated?: SortOrder
    deaths?: SortOrder
    detectorWardsPlaced?: SortOrder
    doubleKills?: SortOrder
    dragonKills?: SortOrder
    firstBlood?: SortOrder
    firstBloodAssist?: SortOrder
    firstTowerKill?: SortOrder
    firstTowerAssist?: SortOrder
    gameEndedInEarlySurrender?: SortOrder
    gameEndedInSurrender?: SortOrder
    goldEarned?: SortOrder
    goldSpent?: SortOrder
    individualPosition?: SortOrder
    inhibitorKills?: SortOrder
    inhibitorTakedowns?: SortOrder
    inhibitorsLost?: SortOrder
    item0?: SortOrder
    item1?: SortOrder
    item2?: SortOrder
    item3?: SortOrder
    item4?: SortOrder
    item5?: SortOrder
    item6?: SortOrder
    itemsPurchased?: SortOrder
    killingSprees?: SortOrder
    kills?: SortOrder
    lane?: SortOrder
    largestCriticalStrike?: SortOrder
    largestKillingSpree?: SortOrder
    largestMultiKill?: SortOrder
    longestTimeSpentLiving?: SortOrder
    magicDamageDealt?: SortOrder
    magicDamageDealtToChampions?: SortOrder
    magicDamageTaken?: SortOrder
    neutralMinionsKilled?: SortOrder
    nexusKills?: SortOrder
    nexusLost?: SortOrder
    nexusTakedowns?: SortOrder
    objectivesStolen?: SortOrder
    objectivesStolenAssists?: SortOrder
    participantId?: SortOrder
    pentaKills?: SortOrder
    physicalDamageDealt?: SortOrder
    physicalDamageDealtToChampions?: SortOrder
    physicalDamageTaken?: SortOrder
    quadraKills?: SortOrder
    riotIdName?: SortOrder
    riotIdTagline?: SortOrder
    role?: SortOrder
    sightWardsBoughtInGame?: SortOrder
    spell1Casts?: SortOrder
    spell2Casts?: SortOrder
    spell3Casts?: SortOrder
    spell4Casts?: SortOrder
    summoner1Casts?: SortOrder
    summoner1Id?: SortOrder
    summoner2Casts?: SortOrder
    summoner2Id?: SortOrder
    summonerLevel?: SortOrder
    summonerName?: SortOrder
    teamEarlySurrendered?: SortOrder
    teamId?: SortOrder
    teamPosition?: SortOrder
    timeCCingOthers?: SortOrder
    timePlayed?: SortOrder
    totalDamageDealt?: SortOrder
    totalDamageDealtToChampions?: SortOrder
    totalDamageShieldedOnTeammates?: SortOrder
    totalDamageTaken?: SortOrder
    totalHeal?: SortOrder
    totalHealsOnTeammates?: SortOrder
    totalMinionsKilled?: SortOrder
    totalTimeCCDealt?: SortOrder
    totalTimeSpentDead?: SortOrder
    totalUnitsHealed?: SortOrder
    tripleKills?: SortOrder
    trueDamageDealt?: SortOrder
    trueDamageDealtToChampions?: SortOrder
    trueDamageTaken?: SortOrder
    turretsKilled?: SortOrder
    turretTakedowns?: SortOrder
    turretsLost?: SortOrder
    unrealKills?: SortOrder
    visionScore?: SortOrder
    visionWardsBoughtInGame?: SortOrder
    wardsKilled?: SortOrder
    wardsPlaced?: SortOrder
    win?: SortOrder
  }

  export type PlayerEndOfGameStatSumOrderByAggregateInput = {
    assists?: SortOrder
    baronKills?: SortOrder
    bountyLevel?: SortOrder
    championExperience?: SortOrder
    championLevel?: SortOrder
    championId?: SortOrder
    championTransform?: SortOrder
    consumablesPurchased?: SortOrder
    damageDealtToBuildings?: SortOrder
    damageDealtToObjectives?: SortOrder
    damageDealtToTurrets?: SortOrder
    damageSelfMitigated?: SortOrder
    deaths?: SortOrder
    detectorWardsPlaced?: SortOrder
    doubleKills?: SortOrder
    dragonKills?: SortOrder
    goldEarned?: SortOrder
    goldSpent?: SortOrder
    inhibitorKills?: SortOrder
    inhibitorTakedowns?: SortOrder
    inhibitorsLost?: SortOrder
    item0?: SortOrder
    item1?: SortOrder
    item2?: SortOrder
    item3?: SortOrder
    item4?: SortOrder
    item5?: SortOrder
    item6?: SortOrder
    itemsPurchased?: SortOrder
    killingSprees?: SortOrder
    kills?: SortOrder
    largestCriticalStrike?: SortOrder
    largestKillingSpree?: SortOrder
    largestMultiKill?: SortOrder
    longestTimeSpentLiving?: SortOrder
    magicDamageDealt?: SortOrder
    magicDamageDealtToChampions?: SortOrder
    magicDamageTaken?: SortOrder
    neutralMinionsKilled?: SortOrder
    nexusKills?: SortOrder
    nexusLost?: SortOrder
    nexusTakedowns?: SortOrder
    objectivesStolen?: SortOrder
    objectivesStolenAssists?: SortOrder
    participantId?: SortOrder
    pentaKills?: SortOrder
    physicalDamageDealt?: SortOrder
    physicalDamageDealtToChampions?: SortOrder
    physicalDamageTaken?: SortOrder
    quadraKills?: SortOrder
    sightWardsBoughtInGame?: SortOrder
    spell1Casts?: SortOrder
    spell2Casts?: SortOrder
    spell3Casts?: SortOrder
    spell4Casts?: SortOrder
    summoner1Casts?: SortOrder
    summoner1Id?: SortOrder
    summoner2Casts?: SortOrder
    summoner2Id?: SortOrder
    summonerLevel?: SortOrder
    teamId?: SortOrder
    timeCCingOthers?: SortOrder
    timePlayed?: SortOrder
    totalDamageDealt?: SortOrder
    totalDamageDealtToChampions?: SortOrder
    totalDamageShieldedOnTeammates?: SortOrder
    totalDamageTaken?: SortOrder
    totalHeal?: SortOrder
    totalHealsOnTeammates?: SortOrder
    totalMinionsKilled?: SortOrder
    totalTimeCCDealt?: SortOrder
    totalTimeSpentDead?: SortOrder
    totalUnitsHealed?: SortOrder
    tripleKills?: SortOrder
    trueDamageDealt?: SortOrder
    trueDamageDealtToChampions?: SortOrder
    trueDamageTaken?: SortOrder
    turretsKilled?: SortOrder
    turretTakedowns?: SortOrder
    turretsLost?: SortOrder
    unrealKills?: SortOrder
    visionScore?: SortOrder
    visionWardsBoughtInGame?: SortOrder
    wardsKilled?: SortOrder
    wardsPlaced?: SortOrder
  }

  export type PlayerItemCountOrderByAggregateInput = {
    id?: SortOrder
    slot?: SortOrder
    itemId?: SortOrder
    name?: SortOrder
  }

  export type PlayerItemAvgOrderByAggregateInput = {
    slot?: SortOrder
    itemId?: SortOrder
  }

  export type PlayerItemMaxOrderByAggregateInput = {
    id?: SortOrder
    slot?: SortOrder
    itemId?: SortOrder
    name?: SortOrder
  }

  export type PlayerItemMinOrderByAggregateInput = {
    id?: SortOrder
    slot?: SortOrder
    itemId?: SortOrder
    name?: SortOrder
  }

  export type PlayerItemSumOrderByAggregateInput = {
    slot?: SortOrder
    itemId?: SortOrder
  }

  export type PlayerListRelationFilter = {
    every?: PlayerWhereInput
    some?: PlayerWhereInput
    none?: PlayerWhereInput
  }

  export type PlayerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlayerItemEventCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    itemId?: SortOrder
    name?: SortOrder
    undoId?: SortOrder
  }

  export type PlayerItemEventAvgOrderByAggregateInput = {
    itemId?: SortOrder
    undoId?: SortOrder
  }

  export type PlayerItemEventMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    itemId?: SortOrder
    name?: SortOrder
    undoId?: SortOrder
  }

  export type PlayerItemEventMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    itemId?: SortOrder
    name?: SortOrder
    undoId?: SortOrder
  }

  export type PlayerItemEventSumOrderByAggregateInput = {
    itemId?: SortOrder
    undoId?: SortOrder
  }

  export type PlayerKillCountOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PlayerKillMaxOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PlayerKillMinOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PlayerEndOfGameStatRelationFilter = {
    is?: PlayerEndOfGameStatWhereInput | null
    isNot?: PlayerEndOfGameStatWhereInput | null
  }

  export type RuneStyleListRelationFilter = {
    every?: RuneStyleWhereInput
    some?: RuneStyleWhereInput
    none?: RuneStyleWhereInput
  }

  export type RuneStyleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlayerRuneCountOrderByAggregateInput = {
    id?: SortOrder
    defense?: SortOrder
    flex?: SortOrder
    offense?: SortOrder
  }

  export type PlayerRuneAvgOrderByAggregateInput = {
    defense?: SortOrder
    flex?: SortOrder
    offense?: SortOrder
  }

  export type PlayerRuneMaxOrderByAggregateInput = {
    id?: SortOrder
    defense?: SortOrder
    flex?: SortOrder
    offense?: SortOrder
  }

  export type PlayerRuneMinOrderByAggregateInput = {
    id?: SortOrder
    defense?: SortOrder
    flex?: SortOrder
    offense?: SortOrder
  }

  export type PlayerRuneSumOrderByAggregateInput = {
    defense?: SortOrder
    flex?: SortOrder
    offense?: SortOrder
  }

  export type PlayerSkillLevelUpEventCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    slot?: SortOrder
  }

  export type PlayerSkillLevelUpEventAvgOrderByAggregateInput = {
    slot?: SortOrder
  }

  export type PlayerSkillLevelUpEventMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    slot?: SortOrder
  }

  export type PlayerSkillLevelUpEventMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    slot?: SortOrder
  }

  export type PlayerSkillLevelUpEventSumOrderByAggregateInput = {
    slot?: SortOrder
  }

  export type FloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type PlayerSnapshotCountOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    currentGold?: SortOrder
    totalGold?: SortOrder
    totalGoldDiff?: SortOrder
    xp?: SortOrder
    xpDiff?: SortOrder
    level?: SortOrder
    cs?: SortOrder
    csDiff?: SortOrder
    monstersKilled?: SortOrder
    monstersKilledDiff?: SortOrder
  }

  export type PlayerSnapshotAvgOrderByAggregateInput = {
    timestamp?: SortOrder
    currentGold?: SortOrder
    totalGold?: SortOrder
    totalGoldDiff?: SortOrder
    xp?: SortOrder
    xpDiff?: SortOrder
    level?: SortOrder
    cs?: SortOrder
    csDiff?: SortOrder
    monstersKilled?: SortOrder
    monstersKilledDiff?: SortOrder
  }

  export type PlayerSnapshotMaxOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    currentGold?: SortOrder
    totalGold?: SortOrder
    totalGoldDiff?: SortOrder
    xp?: SortOrder
    xpDiff?: SortOrder
    level?: SortOrder
    cs?: SortOrder
    csDiff?: SortOrder
    monstersKilled?: SortOrder
    monstersKilledDiff?: SortOrder
  }

  export type PlayerSnapshotMinOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    currentGold?: SortOrder
    totalGold?: SortOrder
    totalGoldDiff?: SortOrder
    xp?: SortOrder
    xpDiff?: SortOrder
    level?: SortOrder
    cs?: SortOrder
    csDiff?: SortOrder
    monstersKilled?: SortOrder
    monstersKilledDiff?: SortOrder
  }

  export type PlayerSnapshotSumOrderByAggregateInput = {
    timestamp?: SortOrder
    currentGold?: SortOrder
    totalGold?: SortOrder
    totalGoldDiff?: SortOrder
    xp?: SortOrder
    xpDiff?: SortOrder
    level?: SortOrder
    cs?: SortOrder
    csDiff?: SortOrder
    monstersKilled?: SortOrder
    monstersKilledDiff?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedFloatNullableFilter
    _min?: NestedFloatNullableFilter
    _max?: NestedFloatNullableFilter
  }

  export type EnumPlayerWardEventWardTypeTypeNullableFilter = {
    equals?: PlayerWardEventWardTypeType | null
    in?: Enumerable<PlayerWardEventWardTypeType> | null
    notIn?: Enumerable<PlayerWardEventWardTypeType> | null
    not?: NestedEnumPlayerWardEventWardTypeTypeNullableFilter | PlayerWardEventWardTypeType | null
  }

  export type PlayerWardEventCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    wardType?: SortOrder
  }

  export type PlayerWardEventMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    wardType?: SortOrder
  }

  export type PlayerWardEventMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    wardType?: SortOrder
  }

  export type EnumPlayerWardEventWardTypeTypeNullableWithAggregatesFilter = {
    equals?: PlayerWardEventWardTypeType | null
    in?: Enumerable<PlayerWardEventWardTypeType> | null
    notIn?: Enumerable<PlayerWardEventWardTypeType> | null
    not?: NestedEnumPlayerWardEventWardTypeTypeNullableWithAggregatesFilter | PlayerWardEventWardTypeType | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumPlayerWardEventWardTypeTypeNullableFilter
    _max?: NestedEnumPlayerWardEventWardTypeTypeNullableFilter
  }

  export type EventListRelationFilter = {
    every?: EventWhereInput
    some?: EventWhereInput
    none?: EventWhereInput
  }

  export type EventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PositionCountOrderByAggregateInput = {
    id?: SortOrder
    x?: SortOrder
    y?: SortOrder
  }

  export type PositionAvgOrderByAggregateInput = {
    x?: SortOrder
    y?: SortOrder
  }

  export type PositionMaxOrderByAggregateInput = {
    id?: SortOrder
    x?: SortOrder
    y?: SortOrder
  }

  export type PositionMinOrderByAggregateInput = {
    id?: SortOrder
    x?: SortOrder
    y?: SortOrder
  }

  export type PositionSumOrderByAggregateInput = {
    x?: SortOrder
    y?: SortOrder
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type ActivityListRelationFilter = {
    every?: ActivityWhereInput
    some?: ActivityWhereInput
    none?: ActivityWhereInput
  }

  export type ChampionWinrateListRelationFilter = {
    every?: ChampionWinrateWhereInput
    some?: ChampionWinrateWhereInput
    none?: ChampionWinrateWhereInput
  }

  export type DuoListRelationFilter = {
    every?: DuoWhereInput
    some?: DuoWhereInput
    none?: DuoWhereInput
  }

  export type ActivityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChampionWinrateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DuoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProfileCountOrderByAggregateInput = {
    id?: SortOrder
    update?: SortOrder
    lastUpdate?: SortOrder
    kills?: SortOrder
    deaths?: SortOrder
    assists?: SortOrder
    kda?: SortOrder
    winRate?: SortOrder
    csPerMinute?: SortOrder
    damagePerMinute?: SortOrder
    killsPerMinute?: SortOrder
    goldPerMinute?: SortOrder
    averageGameTime?: SortOrder
    averageTimeSpentDead?: SortOrder
    totalGameTime?: SortOrder
  }

  export type ProfileAvgOrderByAggregateInput = {
    kills?: SortOrder
    deaths?: SortOrder
    assists?: SortOrder
  }

  export type ProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    update?: SortOrder
    lastUpdate?: SortOrder
    kills?: SortOrder
    deaths?: SortOrder
    assists?: SortOrder
    kda?: SortOrder
    winRate?: SortOrder
    csPerMinute?: SortOrder
    damagePerMinute?: SortOrder
    killsPerMinute?: SortOrder
    goldPerMinute?: SortOrder
    averageGameTime?: SortOrder
    averageTimeSpentDead?: SortOrder
    totalGameTime?: SortOrder
  }

  export type ProfileMinOrderByAggregateInput = {
    id?: SortOrder
    update?: SortOrder
    lastUpdate?: SortOrder
    kills?: SortOrder
    deaths?: SortOrder
    assists?: SortOrder
    kda?: SortOrder
    winRate?: SortOrder
    csPerMinute?: SortOrder
    damagePerMinute?: SortOrder
    killsPerMinute?: SortOrder
    goldPerMinute?: SortOrder
    averageGameTime?: SortOrder
    averageTimeSpentDead?: SortOrder
    totalGameTime?: SortOrder
  }

  export type ProfileSumOrderByAggregateInput = {
    kills?: SortOrder
    deaths?: SortOrder
    assists?: SortOrder
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type SeedIdentifierCountOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    type?: SortOrder
    timestamp?: SortOrder
    priority?: SortOrder
    retrieved?: SortOrder
  }

  export type SeedIdentifierMaxOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    type?: SortOrder
    timestamp?: SortOrder
    priority?: SortOrder
    retrieved?: SortOrder
  }

  export type SeedIdentifierMinOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    type?: SortOrder
    timestamp?: SortOrder
    priority?: SortOrder
    retrieved?: SortOrder
  }

  export type GameListRelationFilter = {
    every?: GameWhereInput
    some?: GameWhereInput
    none?: GameWhereInput
  }

  export type GameOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SourceCountOrderByAggregateInput = {
    id?: SortOrder
    api?: SortOrder
  }

  export type SourceMaxOrderByAggregateInput = {
    id?: SortOrder
    api?: SortOrder
  }

  export type SourceMinOrderByAggregateInput = {
    id?: SortOrder
    api?: SortOrder
  }

  export type PickBanListRelationFilter = {
    every?: PickBanWhereInput
    some?: PickBanWhereInput
    none?: PickBanWhereInput
  }

  export type ObjectiveListRelationFilter = {
    every?: ObjectiveWhereInput
    some?: ObjectiveWhereInput
    none?: ObjectiveWhereInput
  }

  export type PickBanOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ObjectiveOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeamCountOrderByAggregateInput = {
    id?: SortOrder
    gameId?: SortOrder
    teamId?: SortOrder
    teamMatchId?: SortOrder
    win?: SortOrder
  }

  export type TeamAvgOrderByAggregateInput = {
    teamId?: SortOrder
  }

  export type TeamMaxOrderByAggregateInput = {
    id?: SortOrder
    gameId?: SortOrder
    teamId?: SortOrder
    teamMatchId?: SortOrder
    win?: SortOrder
  }

  export type TeamMinOrderByAggregateInput = {
    id?: SortOrder
    gameId?: SortOrder
    teamId?: SortOrder
    teamMatchId?: SortOrder
    win?: SortOrder
  }

  export type TeamSumOrderByAggregateInput = {
    teamId?: SortOrder
  }

  export type TeamBuildingKillCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    lane?: SortOrder
    side?: SortOrder
    towerLocation?: SortOrder
  }

  export type TeamBuildingKillMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    lane?: SortOrder
    side?: SortOrder
    towerLocation?: SortOrder
  }

  export type TeamBuildingKillMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    lane?: SortOrder
    side?: SortOrder
    towerLocation?: SortOrder
  }

  export type TeamMonsterKillCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    subType?: SortOrder
  }

  export type TeamMonsterKillMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    subType?: SortOrder
  }

  export type TeamMonsterKillMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    subType?: SortOrder
  }

  export type RuneStyleRelationFilter = {
    is?: RuneStyleWhereInput | null
    isNot?: RuneStyleWhereInput | null
  }

  export type RuneSelectionCountOrderByAggregateInput = {
    id?: SortOrder
    runeStyleId?: SortOrder
    perk?: SortOrder
    var1?: SortOrder
    var2?: SortOrder
    var3?: SortOrder
  }

  export type RuneSelectionAvgOrderByAggregateInput = {
    perk?: SortOrder
    var1?: SortOrder
    var2?: SortOrder
    var3?: SortOrder
  }

  export type RuneSelectionMaxOrderByAggregateInput = {
    id?: SortOrder
    runeStyleId?: SortOrder
    perk?: SortOrder
    var1?: SortOrder
    var2?: SortOrder
    var3?: SortOrder
  }

  export type RuneSelectionMinOrderByAggregateInput = {
    id?: SortOrder
    runeStyleId?: SortOrder
    perk?: SortOrder
    var1?: SortOrder
    var2?: SortOrder
    var3?: SortOrder
  }

  export type RuneSelectionSumOrderByAggregateInput = {
    perk?: SortOrder
    var1?: SortOrder
    var2?: SortOrder
    var3?: SortOrder
  }

  export type RuneSelectionListRelationFilter = {
    every?: RuneSelectionWhereInput
    some?: RuneSelectionWhereInput
    none?: RuneSelectionWhereInput
  }

  export type RuneSelectionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RuneStyleCountOrderByAggregateInput = {
    id?: SortOrder
    playerRunesId?: SortOrder
    description?: SortOrder
    style?: SortOrder
  }

  export type RuneStyleAvgOrderByAggregateInput = {
    style?: SortOrder
  }

  export type RuneStyleMaxOrderByAggregateInput = {
    id?: SortOrder
    playerRunesId?: SortOrder
    description?: SortOrder
    style?: SortOrder
  }

  export type RuneStyleMinOrderByAggregateInput = {
    id?: SortOrder
    playerRunesId?: SortOrder
    description?: SortOrder
    style?: SortOrder
  }

  export type RuneStyleSumOrderByAggregateInput = {
    style?: SortOrder
  }

  export type ProfileCreateNestedOneWithoutActivityInput = {
    create?: XOR<ProfileCreateWithoutActivityInput, ProfileUncheckedCreateWithoutActivityInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutActivityInput
    connect?: ProfileWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type ProfileUpdateOneWithoutActivityInput = {
    create?: XOR<ProfileCreateWithoutActivityInput, ProfileUncheckedCreateWithoutActivityInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutActivityInput
    upsert?: ProfileUpsertWithoutActivityInput
    disconnect?: boolean
    delete?: boolean
    connect?: ProfileWhereUniqueInput
    update?: XOR<ProfileUpdateWithoutActivityInput, ProfileUncheckedUpdateWithoutActivityInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type ProfileCreateNestedOneWithoutChampionWinrateInput = {
    create?: XOR<ProfileCreateWithoutChampionWinrateInput, ProfileUncheckedCreateWithoutChampionWinrateInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutChampionWinrateInput
    connect?: ProfileWhereUniqueInput
  }

  export type ProfileUpdateOneWithoutChampionWinrateInput = {
    create?: XOR<ProfileCreateWithoutChampionWinrateInput, ProfileUncheckedCreateWithoutChampionWinrateInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutChampionWinrateInput
    upsert?: ProfileUpsertWithoutChampionWinrateInput
    disconnect?: boolean
    delete?: boolean
    connect?: ProfileWhereUniqueInput
    update?: XOR<ProfileUpdateWithoutChampionWinrateInput, ProfileUncheckedUpdateWithoutChampionWinrateInput>
  }

  export type ProfileCreateNestedOneWithoutDuosInput = {
    create?: XOR<ProfileCreateWithoutDuosInput, ProfileUncheckedCreateWithoutDuosInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutDuosInput
    connect?: ProfileWhereUniqueInput
  }

  export type ProfileUpdateOneWithoutDuosInput = {
    create?: XOR<ProfileCreateWithoutDuosInput, ProfileUncheckedCreateWithoutDuosInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutDuosInput
    upsert?: ProfileUpsertWithoutDuosInput
    disconnect?: boolean
    delete?: boolean
    connect?: ProfileWhereUniqueInput
    update?: XOR<ProfileUpdateWithoutDuosInput, ProfileUncheckedUpdateWithoutDuosInput>
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type PositionCreateNestedManyWithoutEventInput = {
    create?: XOR<Enumerable<PositionCreateWithoutEventInput>, Enumerable<PositionUncheckedCreateWithoutEventInput>>
    connectOrCreate?: Enumerable<PositionCreateOrConnectWithoutEventInput>
    connect?: Enumerable<PositionWhereUniqueInput>
  }

  export type PositionUncheckedCreateNestedManyWithoutEventInput = {
    create?: XOR<Enumerable<PositionCreateWithoutEventInput>, Enumerable<PositionUncheckedCreateWithoutEventInput>>
    connectOrCreate?: Enumerable<PositionCreateOrConnectWithoutEventInput>
    connect?: Enumerable<PositionWhereUniqueInput>
  }

  export type PositionUpdateManyWithoutEventInput = {
    create?: XOR<Enumerable<PositionCreateWithoutEventInput>, Enumerable<PositionUncheckedCreateWithoutEventInput>>
    connectOrCreate?: Enumerable<PositionCreateOrConnectWithoutEventInput>
    upsert?: Enumerable<PositionUpsertWithWhereUniqueWithoutEventInput>
    set?: Enumerable<PositionWhereUniqueInput>
    disconnect?: Enumerable<PositionWhereUniqueInput>
    delete?: Enumerable<PositionWhereUniqueInput>
    connect?: Enumerable<PositionWhereUniqueInput>
    update?: Enumerable<PositionUpdateWithWhereUniqueWithoutEventInput>
    updateMany?: Enumerable<PositionUpdateManyWithWhereWithoutEventInput>
    deleteMany?: Enumerable<PositionScalarWhereInput>
  }

  export type PositionUncheckedUpdateManyWithoutEventInput = {
    create?: XOR<Enumerable<PositionCreateWithoutEventInput>, Enumerable<PositionUncheckedCreateWithoutEventInput>>
    connectOrCreate?: Enumerable<PositionCreateOrConnectWithoutEventInput>
    upsert?: Enumerable<PositionUpsertWithWhereUniqueWithoutEventInput>
    set?: Enumerable<PositionWhereUniqueInput>
    disconnect?: Enumerable<PositionWhereUniqueInput>
    delete?: Enumerable<PositionWhereUniqueInput>
    connect?: Enumerable<PositionWhereUniqueInput>
    update?: Enumerable<PositionUpdateWithWhereUniqueWithoutEventInput>
    updateMany?: Enumerable<PositionUpdateManyWithWhereWithoutEventInput>
    deleteMany?: Enumerable<PositionScalarWhereInput>
  }

  export type TeamCreateNestedOneWithoutFrom_Game_blueTeamInput = {
    create?: XOR<TeamCreateWithoutFrom_Game_blueTeamInput, TeamUncheckedCreateWithoutFrom_Game_blueTeamInput>
    connectOrCreate?: TeamCreateOrConnectWithoutFrom_Game_blueTeamInput
    connect?: TeamWhereUniqueInput
  }

  export type TeamCreateNestedOneWithoutFrom_Game_redTeamInput = {
    create?: XOR<TeamCreateWithoutFrom_Game_redTeamInput, TeamUncheckedCreateWithoutFrom_Game_redTeamInput>
    connectOrCreate?: TeamCreateOrConnectWithoutFrom_Game_redTeamInput
    connect?: TeamWhereUniqueInput
  }

  export type SourceCreateNestedManyWithoutGameInput = {
    create?: XOR<Enumerable<SourceCreateWithoutGameInput>, Enumerable<SourceUncheckedCreateWithoutGameInput>>
    connectOrCreate?: Enumerable<SourceCreateOrConnectWithoutGameInput>
    connect?: Enumerable<SourceWhereUniqueInput>
  }

  export type PlayerEndOfGameStatCreateNestedManyWithoutGameInput = {
    create?: XOR<Enumerable<PlayerEndOfGameStatCreateWithoutGameInput>, Enumerable<PlayerEndOfGameStatUncheckedCreateWithoutGameInput>>
    connectOrCreate?: Enumerable<PlayerEndOfGameStatCreateOrConnectWithoutGameInput>
    createMany?: PlayerEndOfGameStatCreateManyGameInputEnvelope
    connect?: Enumerable<PlayerEndOfGameStatWhereUniqueInput>
  }

  export type TeamCreateNestedManyWithoutGameInput = {
    create?: XOR<Enumerable<TeamCreateWithoutGameInput>, Enumerable<TeamUncheckedCreateWithoutGameInput>>
    connectOrCreate?: Enumerable<TeamCreateOrConnectWithoutGameInput>
    createMany?: TeamCreateManyGameInputEnvelope
    connect?: Enumerable<TeamWhereUniqueInput>
  }

  export type SourceUncheckedCreateNestedManyWithoutGameInput = {
    create?: XOR<Enumerable<SourceCreateWithoutGameInput>, Enumerable<SourceUncheckedCreateWithoutGameInput>>
    connectOrCreate?: Enumerable<SourceCreateOrConnectWithoutGameInput>
    connect?: Enumerable<SourceWhereUniqueInput>
  }

  export type PlayerEndOfGameStatUncheckedCreateNestedManyWithoutGameInput = {
    create?: XOR<Enumerable<PlayerEndOfGameStatCreateWithoutGameInput>, Enumerable<PlayerEndOfGameStatUncheckedCreateWithoutGameInput>>
    connectOrCreate?: Enumerable<PlayerEndOfGameStatCreateOrConnectWithoutGameInput>
    createMany?: PlayerEndOfGameStatCreateManyGameInputEnvelope
    connect?: Enumerable<PlayerEndOfGameStatWhereUniqueInput>
  }

  export type TeamUncheckedCreateNestedManyWithoutGameInput = {
    create?: XOR<Enumerable<TeamCreateWithoutGameInput>, Enumerable<TeamUncheckedCreateWithoutGameInput>>
    connectOrCreate?: Enumerable<TeamCreateOrConnectWithoutGameInput>
    createMany?: TeamCreateManyGameInputEnvelope
    connect?: Enumerable<TeamWhereUniqueInput>
  }

  export type TeamUpdateOneWithoutFrom_Game_blueTeamInput = {
    create?: XOR<TeamCreateWithoutFrom_Game_blueTeamInput, TeamUncheckedCreateWithoutFrom_Game_blueTeamInput>
    connectOrCreate?: TeamCreateOrConnectWithoutFrom_Game_blueTeamInput
    upsert?: TeamUpsertWithoutFrom_Game_blueTeamInput
    disconnect?: boolean
    delete?: boolean
    connect?: TeamWhereUniqueInput
    update?: XOR<TeamUpdateWithoutFrom_Game_blueTeamInput, TeamUncheckedUpdateWithoutFrom_Game_blueTeamInput>
  }

  export type TeamUpdateOneWithoutFrom_Game_redTeamInput = {
    create?: XOR<TeamCreateWithoutFrom_Game_redTeamInput, TeamUncheckedCreateWithoutFrom_Game_redTeamInput>
    connectOrCreate?: TeamCreateOrConnectWithoutFrom_Game_redTeamInput
    upsert?: TeamUpsertWithoutFrom_Game_redTeamInput
    disconnect?: boolean
    delete?: boolean
    connect?: TeamWhereUniqueInput
    update?: XOR<TeamUpdateWithoutFrom_Game_redTeamInput, TeamUncheckedUpdateWithoutFrom_Game_redTeamInput>
  }

  export type SourceUpdateManyWithoutGameInput = {
    create?: XOR<Enumerable<SourceCreateWithoutGameInput>, Enumerable<SourceUncheckedCreateWithoutGameInput>>
    connectOrCreate?: Enumerable<SourceCreateOrConnectWithoutGameInput>
    upsert?: Enumerable<SourceUpsertWithWhereUniqueWithoutGameInput>
    set?: Enumerable<SourceWhereUniqueInput>
    disconnect?: Enumerable<SourceWhereUniqueInput>
    delete?: Enumerable<SourceWhereUniqueInput>
    connect?: Enumerable<SourceWhereUniqueInput>
    update?: Enumerable<SourceUpdateWithWhereUniqueWithoutGameInput>
    updateMany?: Enumerable<SourceUpdateManyWithWhereWithoutGameInput>
    deleteMany?: Enumerable<SourceScalarWhereInput>
  }

  export type PlayerEndOfGameStatUpdateManyWithoutGameInput = {
    create?: XOR<Enumerable<PlayerEndOfGameStatCreateWithoutGameInput>, Enumerable<PlayerEndOfGameStatUncheckedCreateWithoutGameInput>>
    connectOrCreate?: Enumerable<PlayerEndOfGameStatCreateOrConnectWithoutGameInput>
    upsert?: Enumerable<PlayerEndOfGameStatUpsertWithWhereUniqueWithoutGameInput>
    createMany?: PlayerEndOfGameStatCreateManyGameInputEnvelope
    set?: Enumerable<PlayerEndOfGameStatWhereUniqueInput>
    disconnect?: Enumerable<PlayerEndOfGameStatWhereUniqueInput>
    delete?: Enumerable<PlayerEndOfGameStatWhereUniqueInput>
    connect?: Enumerable<PlayerEndOfGameStatWhereUniqueInput>
    update?: Enumerable<PlayerEndOfGameStatUpdateWithWhereUniqueWithoutGameInput>
    updateMany?: Enumerable<PlayerEndOfGameStatUpdateManyWithWhereWithoutGameInput>
    deleteMany?: Enumerable<PlayerEndOfGameStatScalarWhereInput>
  }

  export type TeamUpdateManyWithoutGameInput = {
    create?: XOR<Enumerable<TeamCreateWithoutGameInput>, Enumerable<TeamUncheckedCreateWithoutGameInput>>
    connectOrCreate?: Enumerable<TeamCreateOrConnectWithoutGameInput>
    upsert?: Enumerable<TeamUpsertWithWhereUniqueWithoutGameInput>
    createMany?: TeamCreateManyGameInputEnvelope
    set?: Enumerable<TeamWhereUniqueInput>
    disconnect?: Enumerable<TeamWhereUniqueInput>
    delete?: Enumerable<TeamWhereUniqueInput>
    connect?: Enumerable<TeamWhereUniqueInput>
    update?: Enumerable<TeamUpdateWithWhereUniqueWithoutGameInput>
    updateMany?: Enumerable<TeamUpdateManyWithWhereWithoutGameInput>
    deleteMany?: Enumerable<TeamScalarWhereInput>
  }

  export type SourceUncheckedUpdateManyWithoutGameInput = {
    create?: XOR<Enumerable<SourceCreateWithoutGameInput>, Enumerable<SourceUncheckedCreateWithoutGameInput>>
    connectOrCreate?: Enumerable<SourceCreateOrConnectWithoutGameInput>
    upsert?: Enumerable<SourceUpsertWithWhereUniqueWithoutGameInput>
    set?: Enumerable<SourceWhereUniqueInput>
    disconnect?: Enumerable<SourceWhereUniqueInput>
    delete?: Enumerable<SourceWhereUniqueInput>
    connect?: Enumerable<SourceWhereUniqueInput>
    update?: Enumerable<SourceUpdateWithWhereUniqueWithoutGameInput>
    updateMany?: Enumerable<SourceUpdateManyWithWhereWithoutGameInput>
    deleteMany?: Enumerable<SourceScalarWhereInput>
  }

  export type PlayerEndOfGameStatUncheckedUpdateManyWithoutGameInput = {
    create?: XOR<Enumerable<PlayerEndOfGameStatCreateWithoutGameInput>, Enumerable<PlayerEndOfGameStatUncheckedCreateWithoutGameInput>>
    connectOrCreate?: Enumerable<PlayerEndOfGameStatCreateOrConnectWithoutGameInput>
    upsert?: Enumerable<PlayerEndOfGameStatUpsertWithWhereUniqueWithoutGameInput>
    createMany?: PlayerEndOfGameStatCreateManyGameInputEnvelope
    set?: Enumerable<PlayerEndOfGameStatWhereUniqueInput>
    disconnect?: Enumerable<PlayerEndOfGameStatWhereUniqueInput>
    delete?: Enumerable<PlayerEndOfGameStatWhereUniqueInput>
    connect?: Enumerable<PlayerEndOfGameStatWhereUniqueInput>
    update?: Enumerable<PlayerEndOfGameStatUpdateWithWhereUniqueWithoutGameInput>
    updateMany?: Enumerable<PlayerEndOfGameStatUpdateManyWithWhereWithoutGameInput>
    deleteMany?: Enumerable<PlayerEndOfGameStatScalarWhereInput>
  }

  export type TeamUncheckedUpdateManyWithoutGameInput = {
    create?: XOR<Enumerable<TeamCreateWithoutGameInput>, Enumerable<TeamUncheckedCreateWithoutGameInput>>
    connectOrCreate?: Enumerable<TeamCreateOrConnectWithoutGameInput>
    upsert?: Enumerable<TeamUpsertWithWhereUniqueWithoutGameInput>
    createMany?: TeamCreateManyGameInputEnvelope
    set?: Enumerable<TeamWhereUniqueInput>
    disconnect?: Enumerable<TeamWhereUniqueInput>
    delete?: Enumerable<TeamWhereUniqueInput>
    connect?: Enumerable<TeamWhereUniqueInput>
    update?: Enumerable<TeamUpdateWithWhereUniqueWithoutGameInput>
    updateMany?: Enumerable<TeamUpdateManyWithWhereWithoutGameInput>
    deleteMany?: Enumerable<TeamScalarWhereInput>
  }

  export type TeamCreateNestedOneWithoutObjectivesInput = {
    create?: XOR<TeamCreateWithoutObjectivesInput, TeamUncheckedCreateWithoutObjectivesInput>
    connectOrCreate?: TeamCreateOrConnectWithoutObjectivesInput
    connect?: TeamWhereUniqueInput
  }

  export type TeamUpdateOneWithoutObjectivesInput = {
    create?: XOR<TeamCreateWithoutObjectivesInput, TeamUncheckedCreateWithoutObjectivesInput>
    connectOrCreate?: TeamCreateOrConnectWithoutObjectivesInput
    upsert?: TeamUpsertWithoutObjectivesInput
    disconnect?: boolean
    delete?: boolean
    connect?: TeamWhereUniqueInput
    update?: XOR<TeamUpdateWithoutObjectivesInput, TeamUncheckedUpdateWithoutObjectivesInput>
  }

  export type TeamCreateNestedOneWithoutPickBanInput = {
    create?: XOR<TeamCreateWithoutPickBanInput, TeamUncheckedCreateWithoutPickBanInput>
    connectOrCreate?: TeamCreateOrConnectWithoutPickBanInput
    connect?: TeamWhereUniqueInput
  }

  export type TeamUpdateOneWithoutPickBanInput = {
    create?: XOR<TeamCreateWithoutPickBanInput, TeamUncheckedCreateWithoutPickBanInput>
    connectOrCreate?: TeamCreateOrConnectWithoutPickBanInput
    upsert?: TeamUpsertWithoutPickBanInput
    disconnect?: boolean
    delete?: boolean
    connect?: TeamWhereUniqueInput
    update?: XOR<TeamUpdateWithoutPickBanInput, TeamUncheckedUpdateWithoutPickBanInput>
  }

  export type PlayerKillCreateNestedManyWithoutKillerInput = {
    create?: XOR<Enumerable<PlayerKillCreateWithoutKillerInput>, Enumerable<PlayerKillUncheckedCreateWithoutKillerInput>>
    connectOrCreate?: Enumerable<PlayerKillCreateOrConnectWithoutKillerInput>
    connect?: Enumerable<PlayerKillWhereUniqueInput>
  }

  export type PlayerKillCreateNestedManyWithoutVictimInput = {
    create?: XOR<Enumerable<PlayerKillCreateWithoutVictimInput>, Enumerable<PlayerKillUncheckedCreateWithoutVictimInput>>
    connectOrCreate?: Enumerable<PlayerKillCreateOrConnectWithoutVictimInput>
    connect?: Enumerable<PlayerKillWhereUniqueInput>
  }

  export type TeamCreateNestedManyWithoutPlayersInput = {
    create?: XOR<Enumerable<TeamCreateWithoutPlayersInput>, Enumerable<TeamUncheckedCreateWithoutPlayersInput>>
    connectOrCreate?: Enumerable<TeamCreateOrConnectWithoutPlayersInput>
    connect?: Enumerable<TeamWhereUniqueInput>
  }

  export type ProfileCreateNestedOneWithoutPlayerInput = {
    create?: XOR<ProfileCreateWithoutPlayerInput, ProfileUncheckedCreateWithoutPlayerInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutPlayerInput
    connect?: ProfileWhereUniqueInput
  }

  export type TeamMonsterKillCreateNestedManyWithoutKillerInput = {
    create?: XOR<Enumerable<TeamMonsterKillCreateWithoutKillerInput>, Enumerable<TeamMonsterKillUncheckedCreateWithoutKillerInput>>
    connectOrCreate?: Enumerable<TeamMonsterKillCreateOrConnectWithoutKillerInput>
    connect?: Enumerable<TeamMonsterKillWhereUniqueInput>
  }

  export type TeamBuildingKillCreateNestedManyWithoutKillerInput = {
    create?: XOR<Enumerable<TeamBuildingKillCreateWithoutKillerInput>, Enumerable<TeamBuildingKillUncheckedCreateWithoutKillerInput>>
    connectOrCreate?: Enumerable<TeamBuildingKillCreateOrConnectWithoutKillerInput>
    connect?: Enumerable<TeamBuildingKillWhereUniqueInput>
  }

  export type PlayerItemEventCreateNestedManyWithoutPlayerInput = {
    create?: XOR<Enumerable<PlayerItemEventCreateWithoutPlayerInput>, Enumerable<PlayerItemEventUncheckedCreateWithoutPlayerInput>>
    connectOrCreate?: Enumerable<PlayerItemEventCreateOrConnectWithoutPlayerInput>
    connect?: Enumerable<PlayerItemEventWhereUniqueInput>
  }

  export type PlayerEndOfGameStatCreateNestedManyWithoutPlayerInput = {
    create?: XOR<Enumerable<PlayerEndOfGameStatCreateWithoutPlayerInput>, Enumerable<PlayerEndOfGameStatUncheckedCreateWithoutPlayerInput>>
    connectOrCreate?: Enumerable<PlayerEndOfGameStatCreateOrConnectWithoutPlayerInput>
    createMany?: PlayerEndOfGameStatCreateManyPlayerInputEnvelope
    connect?: Enumerable<PlayerEndOfGameStatWhereUniqueInput>
  }

  export type PlayerSnapshotCreateNestedManyWithoutPlayerInput = {
    create?: XOR<Enumerable<PlayerSnapshotCreateWithoutPlayerInput>, Enumerable<PlayerSnapshotUncheckedCreateWithoutPlayerInput>>
    connectOrCreate?: Enumerable<PlayerSnapshotCreateOrConnectWithoutPlayerInput>
    connect?: Enumerable<PlayerSnapshotWhereUniqueInput>
  }

  export type PlayerWardEventCreateNestedManyWithoutPlayerInput = {
    create?: XOR<Enumerable<PlayerWardEventCreateWithoutPlayerInput>, Enumerable<PlayerWardEventUncheckedCreateWithoutPlayerInput>>
    connectOrCreate?: Enumerable<PlayerWardEventCreateOrConnectWithoutPlayerInput>
    connect?: Enumerable<PlayerWardEventWhereUniqueInput>
  }

  export type PlayerSkillLevelUpEventCreateNestedManyWithoutPlayerInput = {
    create?: XOR<Enumerable<PlayerSkillLevelUpEventCreateWithoutPlayerInput>, Enumerable<PlayerSkillLevelUpEventUncheckedCreateWithoutPlayerInput>>
    connectOrCreate?: Enumerable<PlayerSkillLevelUpEventCreateOrConnectWithoutPlayerInput>
    connect?: Enumerable<PlayerSkillLevelUpEventWhereUniqueInput>
  }

  export type PlayerKillUncheckedCreateNestedManyWithoutKillerInput = {
    create?: XOR<Enumerable<PlayerKillCreateWithoutKillerInput>, Enumerable<PlayerKillUncheckedCreateWithoutKillerInput>>
    connectOrCreate?: Enumerable<PlayerKillCreateOrConnectWithoutKillerInput>
    connect?: Enumerable<PlayerKillWhereUniqueInput>
  }

  export type PlayerKillUncheckedCreateNestedManyWithoutVictimInput = {
    create?: XOR<Enumerable<PlayerKillCreateWithoutVictimInput>, Enumerable<PlayerKillUncheckedCreateWithoutVictimInput>>
    connectOrCreate?: Enumerable<PlayerKillCreateOrConnectWithoutVictimInput>
    connect?: Enumerable<PlayerKillWhereUniqueInput>
  }

  export type TeamUncheckedCreateNestedManyWithoutPlayersInput = {
    create?: XOR<Enumerable<TeamCreateWithoutPlayersInput>, Enumerable<TeamUncheckedCreateWithoutPlayersInput>>
    connectOrCreate?: Enumerable<TeamCreateOrConnectWithoutPlayersInput>
    connect?: Enumerable<TeamWhereUniqueInput>
  }

  export type TeamMonsterKillUncheckedCreateNestedManyWithoutKillerInput = {
    create?: XOR<Enumerable<TeamMonsterKillCreateWithoutKillerInput>, Enumerable<TeamMonsterKillUncheckedCreateWithoutKillerInput>>
    connectOrCreate?: Enumerable<TeamMonsterKillCreateOrConnectWithoutKillerInput>
    connect?: Enumerable<TeamMonsterKillWhereUniqueInput>
  }

  export type TeamBuildingKillUncheckedCreateNestedManyWithoutKillerInput = {
    create?: XOR<Enumerable<TeamBuildingKillCreateWithoutKillerInput>, Enumerable<TeamBuildingKillUncheckedCreateWithoutKillerInput>>
    connectOrCreate?: Enumerable<TeamBuildingKillCreateOrConnectWithoutKillerInput>
    connect?: Enumerable<TeamBuildingKillWhereUniqueInput>
  }

  export type PlayerItemEventUncheckedCreateNestedManyWithoutPlayerInput = {
    create?: XOR<Enumerable<PlayerItemEventCreateWithoutPlayerInput>, Enumerable<PlayerItemEventUncheckedCreateWithoutPlayerInput>>
    connectOrCreate?: Enumerable<PlayerItemEventCreateOrConnectWithoutPlayerInput>
    connect?: Enumerable<PlayerItemEventWhereUniqueInput>
  }

  export type PlayerEndOfGameStatUncheckedCreateNestedManyWithoutPlayerInput = {
    create?: XOR<Enumerable<PlayerEndOfGameStatCreateWithoutPlayerInput>, Enumerable<PlayerEndOfGameStatUncheckedCreateWithoutPlayerInput>>
    connectOrCreate?: Enumerable<PlayerEndOfGameStatCreateOrConnectWithoutPlayerInput>
    createMany?: PlayerEndOfGameStatCreateManyPlayerInputEnvelope
    connect?: Enumerable<PlayerEndOfGameStatWhereUniqueInput>
  }

  export type PlayerSnapshotUncheckedCreateNestedManyWithoutPlayerInput = {
    create?: XOR<Enumerable<PlayerSnapshotCreateWithoutPlayerInput>, Enumerable<PlayerSnapshotUncheckedCreateWithoutPlayerInput>>
    connectOrCreate?: Enumerable<PlayerSnapshotCreateOrConnectWithoutPlayerInput>
    connect?: Enumerable<PlayerSnapshotWhereUniqueInput>
  }

  export type PlayerWardEventUncheckedCreateNestedManyWithoutPlayerInput = {
    create?: XOR<Enumerable<PlayerWardEventCreateWithoutPlayerInput>, Enumerable<PlayerWardEventUncheckedCreateWithoutPlayerInput>>
    connectOrCreate?: Enumerable<PlayerWardEventCreateOrConnectWithoutPlayerInput>
    connect?: Enumerable<PlayerWardEventWhereUniqueInput>
  }

  export type PlayerSkillLevelUpEventUncheckedCreateNestedManyWithoutPlayerInput = {
    create?: XOR<Enumerable<PlayerSkillLevelUpEventCreateWithoutPlayerInput>, Enumerable<PlayerSkillLevelUpEventUncheckedCreateWithoutPlayerInput>>
    connectOrCreate?: Enumerable<PlayerSkillLevelUpEventCreateOrConnectWithoutPlayerInput>
    connect?: Enumerable<PlayerSkillLevelUpEventWhereUniqueInput>
  }

  export type PlayerKillUpdateManyWithoutKillerInput = {
    create?: XOR<Enumerable<PlayerKillCreateWithoutKillerInput>, Enumerable<PlayerKillUncheckedCreateWithoutKillerInput>>
    connectOrCreate?: Enumerable<PlayerKillCreateOrConnectWithoutKillerInput>
    upsert?: Enumerable<PlayerKillUpsertWithWhereUniqueWithoutKillerInput>
    set?: Enumerable<PlayerKillWhereUniqueInput>
    disconnect?: Enumerable<PlayerKillWhereUniqueInput>
    delete?: Enumerable<PlayerKillWhereUniqueInput>
    connect?: Enumerable<PlayerKillWhereUniqueInput>
    update?: Enumerable<PlayerKillUpdateWithWhereUniqueWithoutKillerInput>
    updateMany?: Enumerable<PlayerKillUpdateManyWithWhereWithoutKillerInput>
    deleteMany?: Enumerable<PlayerKillScalarWhereInput>
  }

  export type PlayerKillUpdateManyWithoutVictimInput = {
    create?: XOR<Enumerable<PlayerKillCreateWithoutVictimInput>, Enumerable<PlayerKillUncheckedCreateWithoutVictimInput>>
    connectOrCreate?: Enumerable<PlayerKillCreateOrConnectWithoutVictimInput>
    upsert?: Enumerable<PlayerKillUpsertWithWhereUniqueWithoutVictimInput>
    set?: Enumerable<PlayerKillWhereUniqueInput>
    disconnect?: Enumerable<PlayerKillWhereUniqueInput>
    delete?: Enumerable<PlayerKillWhereUniqueInput>
    connect?: Enumerable<PlayerKillWhereUniqueInput>
    update?: Enumerable<PlayerKillUpdateWithWhereUniqueWithoutVictimInput>
    updateMany?: Enumerable<PlayerKillUpdateManyWithWhereWithoutVictimInput>
    deleteMany?: Enumerable<PlayerKillScalarWhereInput>
  }

  export type TeamUpdateManyWithoutPlayersInput = {
    create?: XOR<Enumerable<TeamCreateWithoutPlayersInput>, Enumerable<TeamUncheckedCreateWithoutPlayersInput>>
    connectOrCreate?: Enumerable<TeamCreateOrConnectWithoutPlayersInput>
    upsert?: Enumerable<TeamUpsertWithWhereUniqueWithoutPlayersInput>
    set?: Enumerable<TeamWhereUniqueInput>
    disconnect?: Enumerable<TeamWhereUniqueInput>
    delete?: Enumerable<TeamWhereUniqueInput>
    connect?: Enumerable<TeamWhereUniqueInput>
    update?: Enumerable<TeamUpdateWithWhereUniqueWithoutPlayersInput>
    updateMany?: Enumerable<TeamUpdateManyWithWhereWithoutPlayersInput>
    deleteMany?: Enumerable<TeamScalarWhereInput>
  }

  export type ProfileUpdateOneWithoutPlayerInput = {
    create?: XOR<ProfileCreateWithoutPlayerInput, ProfileUncheckedCreateWithoutPlayerInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutPlayerInput
    upsert?: ProfileUpsertWithoutPlayerInput
    disconnect?: boolean
    delete?: boolean
    connect?: ProfileWhereUniqueInput
    update?: XOR<ProfileUpdateWithoutPlayerInput, ProfileUncheckedUpdateWithoutPlayerInput>
  }

  export type TeamMonsterKillUpdateManyWithoutKillerInput = {
    create?: XOR<Enumerable<TeamMonsterKillCreateWithoutKillerInput>, Enumerable<TeamMonsterKillUncheckedCreateWithoutKillerInput>>
    connectOrCreate?: Enumerable<TeamMonsterKillCreateOrConnectWithoutKillerInput>
    upsert?: Enumerable<TeamMonsterKillUpsertWithWhereUniqueWithoutKillerInput>
    set?: Enumerable<TeamMonsterKillWhereUniqueInput>
    disconnect?: Enumerable<TeamMonsterKillWhereUniqueInput>
    delete?: Enumerable<TeamMonsterKillWhereUniqueInput>
    connect?: Enumerable<TeamMonsterKillWhereUniqueInput>
    update?: Enumerable<TeamMonsterKillUpdateWithWhereUniqueWithoutKillerInput>
    updateMany?: Enumerable<TeamMonsterKillUpdateManyWithWhereWithoutKillerInput>
    deleteMany?: Enumerable<TeamMonsterKillScalarWhereInput>
  }

  export type TeamBuildingKillUpdateManyWithoutKillerInput = {
    create?: XOR<Enumerable<TeamBuildingKillCreateWithoutKillerInput>, Enumerable<TeamBuildingKillUncheckedCreateWithoutKillerInput>>
    connectOrCreate?: Enumerable<TeamBuildingKillCreateOrConnectWithoutKillerInput>
    upsert?: Enumerable<TeamBuildingKillUpsertWithWhereUniqueWithoutKillerInput>
    set?: Enumerable<TeamBuildingKillWhereUniqueInput>
    disconnect?: Enumerable<TeamBuildingKillWhereUniqueInput>
    delete?: Enumerable<TeamBuildingKillWhereUniqueInput>
    connect?: Enumerable<TeamBuildingKillWhereUniqueInput>
    update?: Enumerable<TeamBuildingKillUpdateWithWhereUniqueWithoutKillerInput>
    updateMany?: Enumerable<TeamBuildingKillUpdateManyWithWhereWithoutKillerInput>
    deleteMany?: Enumerable<TeamBuildingKillScalarWhereInput>
  }

  export type PlayerItemEventUpdateManyWithoutPlayerInput = {
    create?: XOR<Enumerable<PlayerItemEventCreateWithoutPlayerInput>, Enumerable<PlayerItemEventUncheckedCreateWithoutPlayerInput>>
    connectOrCreate?: Enumerable<PlayerItemEventCreateOrConnectWithoutPlayerInput>
    upsert?: Enumerable<PlayerItemEventUpsertWithWhereUniqueWithoutPlayerInput>
    set?: Enumerable<PlayerItemEventWhereUniqueInput>
    disconnect?: Enumerable<PlayerItemEventWhereUniqueInput>
    delete?: Enumerable<PlayerItemEventWhereUniqueInput>
    connect?: Enumerable<PlayerItemEventWhereUniqueInput>
    update?: Enumerable<PlayerItemEventUpdateWithWhereUniqueWithoutPlayerInput>
    updateMany?: Enumerable<PlayerItemEventUpdateManyWithWhereWithoutPlayerInput>
    deleteMany?: Enumerable<PlayerItemEventScalarWhereInput>
  }

  export type PlayerEndOfGameStatUpdateManyWithoutPlayerInput = {
    create?: XOR<Enumerable<PlayerEndOfGameStatCreateWithoutPlayerInput>, Enumerable<PlayerEndOfGameStatUncheckedCreateWithoutPlayerInput>>
    connectOrCreate?: Enumerable<PlayerEndOfGameStatCreateOrConnectWithoutPlayerInput>
    upsert?: Enumerable<PlayerEndOfGameStatUpsertWithWhereUniqueWithoutPlayerInput>
    createMany?: PlayerEndOfGameStatCreateManyPlayerInputEnvelope
    set?: Enumerable<PlayerEndOfGameStatWhereUniqueInput>
    disconnect?: Enumerable<PlayerEndOfGameStatWhereUniqueInput>
    delete?: Enumerable<PlayerEndOfGameStatWhereUniqueInput>
    connect?: Enumerable<PlayerEndOfGameStatWhereUniqueInput>
    update?: Enumerable<PlayerEndOfGameStatUpdateWithWhereUniqueWithoutPlayerInput>
    updateMany?: Enumerable<PlayerEndOfGameStatUpdateManyWithWhereWithoutPlayerInput>
    deleteMany?: Enumerable<PlayerEndOfGameStatScalarWhereInput>
  }

  export type PlayerSnapshotUpdateManyWithoutPlayerInput = {
    create?: XOR<Enumerable<PlayerSnapshotCreateWithoutPlayerInput>, Enumerable<PlayerSnapshotUncheckedCreateWithoutPlayerInput>>
    connectOrCreate?: Enumerable<PlayerSnapshotCreateOrConnectWithoutPlayerInput>
    upsert?: Enumerable<PlayerSnapshotUpsertWithWhereUniqueWithoutPlayerInput>
    set?: Enumerable<PlayerSnapshotWhereUniqueInput>
    disconnect?: Enumerable<PlayerSnapshotWhereUniqueInput>
    delete?: Enumerable<PlayerSnapshotWhereUniqueInput>
    connect?: Enumerable<PlayerSnapshotWhereUniqueInput>
    update?: Enumerable<PlayerSnapshotUpdateWithWhereUniqueWithoutPlayerInput>
    updateMany?: Enumerable<PlayerSnapshotUpdateManyWithWhereWithoutPlayerInput>
    deleteMany?: Enumerable<PlayerSnapshotScalarWhereInput>
  }

  export type PlayerWardEventUpdateManyWithoutPlayerInput = {
    create?: XOR<Enumerable<PlayerWardEventCreateWithoutPlayerInput>, Enumerable<PlayerWardEventUncheckedCreateWithoutPlayerInput>>
    connectOrCreate?: Enumerable<PlayerWardEventCreateOrConnectWithoutPlayerInput>
    upsert?: Enumerable<PlayerWardEventUpsertWithWhereUniqueWithoutPlayerInput>
    set?: Enumerable<PlayerWardEventWhereUniqueInput>
    disconnect?: Enumerable<PlayerWardEventWhereUniqueInput>
    delete?: Enumerable<PlayerWardEventWhereUniqueInput>
    connect?: Enumerable<PlayerWardEventWhereUniqueInput>
    update?: Enumerable<PlayerWardEventUpdateWithWhereUniqueWithoutPlayerInput>
    updateMany?: Enumerable<PlayerWardEventUpdateManyWithWhereWithoutPlayerInput>
    deleteMany?: Enumerable<PlayerWardEventScalarWhereInput>
  }

  export type PlayerSkillLevelUpEventUpdateManyWithoutPlayerInput = {
    create?: XOR<Enumerable<PlayerSkillLevelUpEventCreateWithoutPlayerInput>, Enumerable<PlayerSkillLevelUpEventUncheckedCreateWithoutPlayerInput>>
    connectOrCreate?: Enumerable<PlayerSkillLevelUpEventCreateOrConnectWithoutPlayerInput>
    upsert?: Enumerable<PlayerSkillLevelUpEventUpsertWithWhereUniqueWithoutPlayerInput>
    set?: Enumerable<PlayerSkillLevelUpEventWhereUniqueInput>
    disconnect?: Enumerable<PlayerSkillLevelUpEventWhereUniqueInput>
    delete?: Enumerable<PlayerSkillLevelUpEventWhereUniqueInput>
    connect?: Enumerable<PlayerSkillLevelUpEventWhereUniqueInput>
    update?: Enumerable<PlayerSkillLevelUpEventUpdateWithWhereUniqueWithoutPlayerInput>
    updateMany?: Enumerable<PlayerSkillLevelUpEventUpdateManyWithWhereWithoutPlayerInput>
    deleteMany?: Enumerable<PlayerSkillLevelUpEventScalarWhereInput>
  }

  export type PlayerKillUncheckedUpdateManyWithoutKillerInput = {
    create?: XOR<Enumerable<PlayerKillCreateWithoutKillerInput>, Enumerable<PlayerKillUncheckedCreateWithoutKillerInput>>
    connectOrCreate?: Enumerable<PlayerKillCreateOrConnectWithoutKillerInput>
    upsert?: Enumerable<PlayerKillUpsertWithWhereUniqueWithoutKillerInput>
    set?: Enumerable<PlayerKillWhereUniqueInput>
    disconnect?: Enumerable<PlayerKillWhereUniqueInput>
    delete?: Enumerable<PlayerKillWhereUniqueInput>
    connect?: Enumerable<PlayerKillWhereUniqueInput>
    update?: Enumerable<PlayerKillUpdateWithWhereUniqueWithoutKillerInput>
    updateMany?: Enumerable<PlayerKillUpdateManyWithWhereWithoutKillerInput>
    deleteMany?: Enumerable<PlayerKillScalarWhereInput>
  }

  export type PlayerKillUncheckedUpdateManyWithoutVictimInput = {
    create?: XOR<Enumerable<PlayerKillCreateWithoutVictimInput>, Enumerable<PlayerKillUncheckedCreateWithoutVictimInput>>
    connectOrCreate?: Enumerable<PlayerKillCreateOrConnectWithoutVictimInput>
    upsert?: Enumerable<PlayerKillUpsertWithWhereUniqueWithoutVictimInput>
    set?: Enumerable<PlayerKillWhereUniqueInput>
    disconnect?: Enumerable<PlayerKillWhereUniqueInput>
    delete?: Enumerable<PlayerKillWhereUniqueInput>
    connect?: Enumerable<PlayerKillWhereUniqueInput>
    update?: Enumerable<PlayerKillUpdateWithWhereUniqueWithoutVictimInput>
    updateMany?: Enumerable<PlayerKillUpdateManyWithWhereWithoutVictimInput>
    deleteMany?: Enumerable<PlayerKillScalarWhereInput>
  }

  export type TeamUncheckedUpdateManyWithoutPlayersInput = {
    create?: XOR<Enumerable<TeamCreateWithoutPlayersInput>, Enumerable<TeamUncheckedCreateWithoutPlayersInput>>
    connectOrCreate?: Enumerable<TeamCreateOrConnectWithoutPlayersInput>
    upsert?: Enumerable<TeamUpsertWithWhereUniqueWithoutPlayersInput>
    set?: Enumerable<TeamWhereUniqueInput>
    disconnect?: Enumerable<TeamWhereUniqueInput>
    delete?: Enumerable<TeamWhereUniqueInput>
    connect?: Enumerable<TeamWhereUniqueInput>
    update?: Enumerable<TeamUpdateWithWhereUniqueWithoutPlayersInput>
    updateMany?: Enumerable<TeamUpdateManyWithWhereWithoutPlayersInput>
    deleteMany?: Enumerable<TeamScalarWhereInput>
  }

  export type TeamMonsterKillUncheckedUpdateManyWithoutKillerInput = {
    create?: XOR<Enumerable<TeamMonsterKillCreateWithoutKillerInput>, Enumerable<TeamMonsterKillUncheckedCreateWithoutKillerInput>>
    connectOrCreate?: Enumerable<TeamMonsterKillCreateOrConnectWithoutKillerInput>
    upsert?: Enumerable<TeamMonsterKillUpsertWithWhereUniqueWithoutKillerInput>
    set?: Enumerable<TeamMonsterKillWhereUniqueInput>
    disconnect?: Enumerable<TeamMonsterKillWhereUniqueInput>
    delete?: Enumerable<TeamMonsterKillWhereUniqueInput>
    connect?: Enumerable<TeamMonsterKillWhereUniqueInput>
    update?: Enumerable<TeamMonsterKillUpdateWithWhereUniqueWithoutKillerInput>
    updateMany?: Enumerable<TeamMonsterKillUpdateManyWithWhereWithoutKillerInput>
    deleteMany?: Enumerable<TeamMonsterKillScalarWhereInput>
  }

  export type TeamBuildingKillUncheckedUpdateManyWithoutKillerInput = {
    create?: XOR<Enumerable<TeamBuildingKillCreateWithoutKillerInput>, Enumerable<TeamBuildingKillUncheckedCreateWithoutKillerInput>>
    connectOrCreate?: Enumerable<TeamBuildingKillCreateOrConnectWithoutKillerInput>
    upsert?: Enumerable<TeamBuildingKillUpsertWithWhereUniqueWithoutKillerInput>
    set?: Enumerable<TeamBuildingKillWhereUniqueInput>
    disconnect?: Enumerable<TeamBuildingKillWhereUniqueInput>
    delete?: Enumerable<TeamBuildingKillWhereUniqueInput>
    connect?: Enumerable<TeamBuildingKillWhereUniqueInput>
    update?: Enumerable<TeamBuildingKillUpdateWithWhereUniqueWithoutKillerInput>
    updateMany?: Enumerable<TeamBuildingKillUpdateManyWithWhereWithoutKillerInput>
    deleteMany?: Enumerable<TeamBuildingKillScalarWhereInput>
  }

  export type PlayerItemEventUncheckedUpdateManyWithoutPlayerInput = {
    create?: XOR<Enumerable<PlayerItemEventCreateWithoutPlayerInput>, Enumerable<PlayerItemEventUncheckedCreateWithoutPlayerInput>>
    connectOrCreate?: Enumerable<PlayerItemEventCreateOrConnectWithoutPlayerInput>
    upsert?: Enumerable<PlayerItemEventUpsertWithWhereUniqueWithoutPlayerInput>
    set?: Enumerable<PlayerItemEventWhereUniqueInput>
    disconnect?: Enumerable<PlayerItemEventWhereUniqueInput>
    delete?: Enumerable<PlayerItemEventWhereUniqueInput>
    connect?: Enumerable<PlayerItemEventWhereUniqueInput>
    update?: Enumerable<PlayerItemEventUpdateWithWhereUniqueWithoutPlayerInput>
    updateMany?: Enumerable<PlayerItemEventUpdateManyWithWhereWithoutPlayerInput>
    deleteMany?: Enumerable<PlayerItemEventScalarWhereInput>
  }

  export type PlayerEndOfGameStatUncheckedUpdateManyWithoutPlayerInput = {
    create?: XOR<Enumerable<PlayerEndOfGameStatCreateWithoutPlayerInput>, Enumerable<PlayerEndOfGameStatUncheckedCreateWithoutPlayerInput>>
    connectOrCreate?: Enumerable<PlayerEndOfGameStatCreateOrConnectWithoutPlayerInput>
    upsert?: Enumerable<PlayerEndOfGameStatUpsertWithWhereUniqueWithoutPlayerInput>
    createMany?: PlayerEndOfGameStatCreateManyPlayerInputEnvelope
    set?: Enumerable<PlayerEndOfGameStatWhereUniqueInput>
    disconnect?: Enumerable<PlayerEndOfGameStatWhereUniqueInput>
    delete?: Enumerable<PlayerEndOfGameStatWhereUniqueInput>
    connect?: Enumerable<PlayerEndOfGameStatWhereUniqueInput>
    update?: Enumerable<PlayerEndOfGameStatUpdateWithWhereUniqueWithoutPlayerInput>
    updateMany?: Enumerable<PlayerEndOfGameStatUpdateManyWithWhereWithoutPlayerInput>
    deleteMany?: Enumerable<PlayerEndOfGameStatScalarWhereInput>
  }

  export type PlayerSnapshotUncheckedUpdateManyWithoutPlayerInput = {
    create?: XOR<Enumerable<PlayerSnapshotCreateWithoutPlayerInput>, Enumerable<PlayerSnapshotUncheckedCreateWithoutPlayerInput>>
    connectOrCreate?: Enumerable<PlayerSnapshotCreateOrConnectWithoutPlayerInput>
    upsert?: Enumerable<PlayerSnapshotUpsertWithWhereUniqueWithoutPlayerInput>
    set?: Enumerable<PlayerSnapshotWhereUniqueInput>
    disconnect?: Enumerable<PlayerSnapshotWhereUniqueInput>
    delete?: Enumerable<PlayerSnapshotWhereUniqueInput>
    connect?: Enumerable<PlayerSnapshotWhereUniqueInput>
    update?: Enumerable<PlayerSnapshotUpdateWithWhereUniqueWithoutPlayerInput>
    updateMany?: Enumerable<PlayerSnapshotUpdateManyWithWhereWithoutPlayerInput>
    deleteMany?: Enumerable<PlayerSnapshotScalarWhereInput>
  }

  export type PlayerWardEventUncheckedUpdateManyWithoutPlayerInput = {
    create?: XOR<Enumerable<PlayerWardEventCreateWithoutPlayerInput>, Enumerable<PlayerWardEventUncheckedCreateWithoutPlayerInput>>
    connectOrCreate?: Enumerable<PlayerWardEventCreateOrConnectWithoutPlayerInput>
    upsert?: Enumerable<PlayerWardEventUpsertWithWhereUniqueWithoutPlayerInput>
    set?: Enumerable<PlayerWardEventWhereUniqueInput>
    disconnect?: Enumerable<PlayerWardEventWhereUniqueInput>
    delete?: Enumerable<PlayerWardEventWhereUniqueInput>
    connect?: Enumerable<PlayerWardEventWhereUniqueInput>
    update?: Enumerable<PlayerWardEventUpdateWithWhereUniqueWithoutPlayerInput>
    updateMany?: Enumerable<PlayerWardEventUpdateManyWithWhereWithoutPlayerInput>
    deleteMany?: Enumerable<PlayerWardEventScalarWhereInput>
  }

  export type PlayerSkillLevelUpEventUncheckedUpdateManyWithoutPlayerInput = {
    create?: XOR<Enumerable<PlayerSkillLevelUpEventCreateWithoutPlayerInput>, Enumerable<PlayerSkillLevelUpEventUncheckedCreateWithoutPlayerInput>>
    connectOrCreate?: Enumerable<PlayerSkillLevelUpEventCreateOrConnectWithoutPlayerInput>
    upsert?: Enumerable<PlayerSkillLevelUpEventUpsertWithWhereUniqueWithoutPlayerInput>
    set?: Enumerable<PlayerSkillLevelUpEventWhereUniqueInput>
    disconnect?: Enumerable<PlayerSkillLevelUpEventWhereUniqueInput>
    delete?: Enumerable<PlayerSkillLevelUpEventWhereUniqueInput>
    connect?: Enumerable<PlayerSkillLevelUpEventWhereUniqueInput>
    update?: Enumerable<PlayerSkillLevelUpEventUpdateWithWhereUniqueWithoutPlayerInput>
    updateMany?: Enumerable<PlayerSkillLevelUpEventUpdateManyWithWhereWithoutPlayerInput>
    deleteMany?: Enumerable<PlayerSkillLevelUpEventScalarWhereInput>
  }

  export type PlayerCreateNestedOneWithoutEndOfGameStatsInput = {
    create?: XOR<PlayerCreateWithoutEndOfGameStatsInput, PlayerUncheckedCreateWithoutEndOfGameStatsInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutEndOfGameStatsInput
    connect?: PlayerWhereUniqueInput
  }

  export type GameCreateNestedOneWithoutFrom_PlayerEndOfGameStat_gameInput = {
    create?: XOR<GameCreateWithoutFrom_PlayerEndOfGameStat_gameInput, GameUncheckedCreateWithoutFrom_PlayerEndOfGameStat_gameInput>
    connectOrCreate?: GameCreateOrConnectWithoutFrom_PlayerEndOfGameStat_gameInput
    connect?: GameWhereUniqueInput
  }

  export type PlayerRuneCreateNestedOneWithoutPlayerEndOfGameStatInput = {
    create?: XOR<PlayerRuneCreateWithoutPlayerEndOfGameStatInput, PlayerRuneUncheckedCreateWithoutPlayerEndOfGameStatInput>
    connectOrCreate?: PlayerRuneCreateOrConnectWithoutPlayerEndOfGameStatInput
    connect?: PlayerRuneWhereUniqueInput
  }

  export type PlayerItemCreateNestedOneWithoutPlayerEndOfGameStatInput = {
    create?: XOR<PlayerItemCreateWithoutPlayerEndOfGameStatInput, PlayerItemUncheckedCreateWithoutPlayerEndOfGameStatInput>
    connectOrCreate?: PlayerItemCreateOrConnectWithoutPlayerEndOfGameStatInput
    connect?: PlayerItemWhereUniqueInput
  }

  export type PlayerUpdateOneWithoutEndOfGameStatsInput = {
    create?: XOR<PlayerCreateWithoutEndOfGameStatsInput, PlayerUncheckedCreateWithoutEndOfGameStatsInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutEndOfGameStatsInput
    upsert?: PlayerUpsertWithoutEndOfGameStatsInput
    disconnect?: boolean
    delete?: boolean
    connect?: PlayerWhereUniqueInput
    update?: XOR<PlayerUpdateWithoutEndOfGameStatsInput, PlayerUncheckedUpdateWithoutEndOfGameStatsInput>
  }

  export type GameUpdateOneWithoutFrom_PlayerEndOfGameStat_gameInput = {
    create?: XOR<GameCreateWithoutFrom_PlayerEndOfGameStat_gameInput, GameUncheckedCreateWithoutFrom_PlayerEndOfGameStat_gameInput>
    connectOrCreate?: GameCreateOrConnectWithoutFrom_PlayerEndOfGameStat_gameInput
    upsert?: GameUpsertWithoutFrom_PlayerEndOfGameStat_gameInput
    disconnect?: boolean
    delete?: boolean
    connect?: GameWhereUniqueInput
    update?: XOR<GameUpdateWithoutFrom_PlayerEndOfGameStat_gameInput, GameUncheckedUpdateWithoutFrom_PlayerEndOfGameStat_gameInput>
  }

  export type PlayerRuneUpdateOneWithoutPlayerEndOfGameStatInput = {
    create?: XOR<PlayerRuneCreateWithoutPlayerEndOfGameStatInput, PlayerRuneUncheckedCreateWithoutPlayerEndOfGameStatInput>
    connectOrCreate?: PlayerRuneCreateOrConnectWithoutPlayerEndOfGameStatInput
    upsert?: PlayerRuneUpsertWithoutPlayerEndOfGameStatInput
    disconnect?: boolean
    delete?: boolean
    connect?: PlayerRuneWhereUniqueInput
    update?: XOR<PlayerRuneUpdateWithoutPlayerEndOfGameStatInput, PlayerRuneUncheckedUpdateWithoutPlayerEndOfGameStatInput>
  }

  export type PlayerItemUpdateOneWithoutPlayerEndOfGameStatInput = {
    create?: XOR<PlayerItemCreateWithoutPlayerEndOfGameStatInput, PlayerItemUncheckedCreateWithoutPlayerEndOfGameStatInput>
    connectOrCreate?: PlayerItemCreateOrConnectWithoutPlayerEndOfGameStatInput
    upsert?: PlayerItemUpsertWithoutPlayerEndOfGameStatInput
    disconnect?: boolean
    delete?: boolean
    connect?: PlayerItemWhereUniqueInput
    update?: XOR<PlayerItemUpdateWithoutPlayerEndOfGameStatInput, PlayerItemUncheckedUpdateWithoutPlayerEndOfGameStatInput>
  }

  export type PlayerEndOfGameStatCreateNestedManyWithoutItemsInput = {
    create?: XOR<Enumerable<PlayerEndOfGameStatCreateWithoutItemsInput>, Enumerable<PlayerEndOfGameStatUncheckedCreateWithoutItemsInput>>
    connectOrCreate?: Enumerable<PlayerEndOfGameStatCreateOrConnectWithoutItemsInput>
    createMany?: PlayerEndOfGameStatCreateManyItemsInputEnvelope
    connect?: Enumerable<PlayerEndOfGameStatWhereUniqueInput>
  }

  export type PlayerEndOfGameStatUncheckedCreateNestedManyWithoutItemsInput = {
    create?: XOR<Enumerable<PlayerEndOfGameStatCreateWithoutItemsInput>, Enumerable<PlayerEndOfGameStatUncheckedCreateWithoutItemsInput>>
    connectOrCreate?: Enumerable<PlayerEndOfGameStatCreateOrConnectWithoutItemsInput>
    createMany?: PlayerEndOfGameStatCreateManyItemsInputEnvelope
    connect?: Enumerable<PlayerEndOfGameStatWhereUniqueInput>
  }

  export type PlayerEndOfGameStatUpdateManyWithoutItemsInput = {
    create?: XOR<Enumerable<PlayerEndOfGameStatCreateWithoutItemsInput>, Enumerable<PlayerEndOfGameStatUncheckedCreateWithoutItemsInput>>
    connectOrCreate?: Enumerable<PlayerEndOfGameStatCreateOrConnectWithoutItemsInput>
    upsert?: Enumerable<PlayerEndOfGameStatUpsertWithWhereUniqueWithoutItemsInput>
    createMany?: PlayerEndOfGameStatCreateManyItemsInputEnvelope
    set?: Enumerable<PlayerEndOfGameStatWhereUniqueInput>
    disconnect?: Enumerable<PlayerEndOfGameStatWhereUniqueInput>
    delete?: Enumerable<PlayerEndOfGameStatWhereUniqueInput>
    connect?: Enumerable<PlayerEndOfGameStatWhereUniqueInput>
    update?: Enumerable<PlayerEndOfGameStatUpdateWithWhereUniqueWithoutItemsInput>
    updateMany?: Enumerable<PlayerEndOfGameStatUpdateManyWithWhereWithoutItemsInput>
    deleteMany?: Enumerable<PlayerEndOfGameStatScalarWhereInput>
  }

  export type PlayerEndOfGameStatUncheckedUpdateManyWithoutItemsInput = {
    create?: XOR<Enumerable<PlayerEndOfGameStatCreateWithoutItemsInput>, Enumerable<PlayerEndOfGameStatUncheckedCreateWithoutItemsInput>>
    connectOrCreate?: Enumerable<PlayerEndOfGameStatCreateOrConnectWithoutItemsInput>
    upsert?: Enumerable<PlayerEndOfGameStatUpsertWithWhereUniqueWithoutItemsInput>
    createMany?: PlayerEndOfGameStatCreateManyItemsInputEnvelope
    set?: Enumerable<PlayerEndOfGameStatWhereUniqueInput>
    disconnect?: Enumerable<PlayerEndOfGameStatWhereUniqueInput>
    delete?: Enumerable<PlayerEndOfGameStatWhereUniqueInput>
    connect?: Enumerable<PlayerEndOfGameStatWhereUniqueInput>
    update?: Enumerable<PlayerEndOfGameStatUpdateWithWhereUniqueWithoutItemsInput>
    updateMany?: Enumerable<PlayerEndOfGameStatUpdateManyWithWhereWithoutItemsInput>
    deleteMany?: Enumerable<PlayerEndOfGameStatScalarWhereInput>
  }

  export type PlayerCreateNestedManyWithoutItemEventInput = {
    create?: XOR<Enumerable<PlayerCreateWithoutItemEventInput>, Enumerable<PlayerUncheckedCreateWithoutItemEventInput>>
    connectOrCreate?: Enumerable<PlayerCreateOrConnectWithoutItemEventInput>
    connect?: Enumerable<PlayerWhereUniqueInput>
  }

  export type PlayerUncheckedCreateNestedManyWithoutItemEventInput = {
    create?: XOR<Enumerable<PlayerCreateWithoutItemEventInput>, Enumerable<PlayerUncheckedCreateWithoutItemEventInput>>
    connectOrCreate?: Enumerable<PlayerCreateOrConnectWithoutItemEventInput>
    connect?: Enumerable<PlayerWhereUniqueInput>
  }

  export type PlayerUpdateManyWithoutItemEventInput = {
    create?: XOR<Enumerable<PlayerCreateWithoutItemEventInput>, Enumerable<PlayerUncheckedCreateWithoutItemEventInput>>
    connectOrCreate?: Enumerable<PlayerCreateOrConnectWithoutItemEventInput>
    upsert?: Enumerable<PlayerUpsertWithWhereUniqueWithoutItemEventInput>
    set?: Enumerable<PlayerWhereUniqueInput>
    disconnect?: Enumerable<PlayerWhereUniqueInput>
    delete?: Enumerable<PlayerWhereUniqueInput>
    connect?: Enumerable<PlayerWhereUniqueInput>
    update?: Enumerable<PlayerUpdateWithWhereUniqueWithoutItemEventInput>
    updateMany?: Enumerable<PlayerUpdateManyWithWhereWithoutItemEventInput>
    deleteMany?: Enumerable<PlayerScalarWhereInput>
  }

  export type PlayerUncheckedUpdateManyWithoutItemEventInput = {
    create?: XOR<Enumerable<PlayerCreateWithoutItemEventInput>, Enumerable<PlayerUncheckedCreateWithoutItemEventInput>>
    connectOrCreate?: Enumerable<PlayerCreateOrConnectWithoutItemEventInput>
    upsert?: Enumerable<PlayerUpsertWithWhereUniqueWithoutItemEventInput>
    set?: Enumerable<PlayerWhereUniqueInput>
    disconnect?: Enumerable<PlayerWhereUniqueInput>
    delete?: Enumerable<PlayerWhereUniqueInput>
    connect?: Enumerable<PlayerWhereUniqueInput>
    update?: Enumerable<PlayerUpdateWithWhereUniqueWithoutItemEventInput>
    updateMany?: Enumerable<PlayerUpdateManyWithWhereWithoutItemEventInput>
    deleteMany?: Enumerable<PlayerScalarWhereInput>
  }

  export type PlayerCreateNestedManyWithoutKillsInput = {
    create?: XOR<Enumerable<PlayerCreateWithoutKillsInput>, Enumerable<PlayerUncheckedCreateWithoutKillsInput>>
    connectOrCreate?: Enumerable<PlayerCreateOrConnectWithoutKillsInput>
    connect?: Enumerable<PlayerWhereUniqueInput>
  }

  export type PlayerCreateNestedManyWithoutDeathsInput = {
    create?: XOR<Enumerable<PlayerCreateWithoutDeathsInput>, Enumerable<PlayerUncheckedCreateWithoutDeathsInput>>
    connectOrCreate?: Enumerable<PlayerCreateOrConnectWithoutDeathsInput>
    connect?: Enumerable<PlayerWhereUniqueInput>
  }

  export type PlayerUncheckedCreateNestedManyWithoutKillsInput = {
    create?: XOR<Enumerable<PlayerCreateWithoutKillsInput>, Enumerable<PlayerUncheckedCreateWithoutKillsInput>>
    connectOrCreate?: Enumerable<PlayerCreateOrConnectWithoutKillsInput>
    connect?: Enumerable<PlayerWhereUniqueInput>
  }

  export type PlayerUncheckedCreateNestedManyWithoutDeathsInput = {
    create?: XOR<Enumerable<PlayerCreateWithoutDeathsInput>, Enumerable<PlayerUncheckedCreateWithoutDeathsInput>>
    connectOrCreate?: Enumerable<PlayerCreateOrConnectWithoutDeathsInput>
    connect?: Enumerable<PlayerWhereUniqueInput>
  }

  export type PlayerUpdateManyWithoutKillsInput = {
    create?: XOR<Enumerable<PlayerCreateWithoutKillsInput>, Enumerable<PlayerUncheckedCreateWithoutKillsInput>>
    connectOrCreate?: Enumerable<PlayerCreateOrConnectWithoutKillsInput>
    upsert?: Enumerable<PlayerUpsertWithWhereUniqueWithoutKillsInput>
    set?: Enumerable<PlayerWhereUniqueInput>
    disconnect?: Enumerable<PlayerWhereUniqueInput>
    delete?: Enumerable<PlayerWhereUniqueInput>
    connect?: Enumerable<PlayerWhereUniqueInput>
    update?: Enumerable<PlayerUpdateWithWhereUniqueWithoutKillsInput>
    updateMany?: Enumerable<PlayerUpdateManyWithWhereWithoutKillsInput>
    deleteMany?: Enumerable<PlayerScalarWhereInput>
  }

  export type PlayerUpdateManyWithoutDeathsInput = {
    create?: XOR<Enumerable<PlayerCreateWithoutDeathsInput>, Enumerable<PlayerUncheckedCreateWithoutDeathsInput>>
    connectOrCreate?: Enumerable<PlayerCreateOrConnectWithoutDeathsInput>
    upsert?: Enumerable<PlayerUpsertWithWhereUniqueWithoutDeathsInput>
    set?: Enumerable<PlayerWhereUniqueInput>
    disconnect?: Enumerable<PlayerWhereUniqueInput>
    delete?: Enumerable<PlayerWhereUniqueInput>
    connect?: Enumerable<PlayerWhereUniqueInput>
    update?: Enumerable<PlayerUpdateWithWhereUniqueWithoutDeathsInput>
    updateMany?: Enumerable<PlayerUpdateManyWithWhereWithoutDeathsInput>
    deleteMany?: Enumerable<PlayerScalarWhereInput>
  }

  export type PlayerUncheckedUpdateManyWithoutKillsInput = {
    create?: XOR<Enumerable<PlayerCreateWithoutKillsInput>, Enumerable<PlayerUncheckedCreateWithoutKillsInput>>
    connectOrCreate?: Enumerable<PlayerCreateOrConnectWithoutKillsInput>
    upsert?: Enumerable<PlayerUpsertWithWhereUniqueWithoutKillsInput>
    set?: Enumerable<PlayerWhereUniqueInput>
    disconnect?: Enumerable<PlayerWhereUniqueInput>
    delete?: Enumerable<PlayerWhereUniqueInput>
    connect?: Enumerable<PlayerWhereUniqueInput>
    update?: Enumerable<PlayerUpdateWithWhereUniqueWithoutKillsInput>
    updateMany?: Enumerable<PlayerUpdateManyWithWhereWithoutKillsInput>
    deleteMany?: Enumerable<PlayerScalarWhereInput>
  }

  export type PlayerUncheckedUpdateManyWithoutDeathsInput = {
    create?: XOR<Enumerable<PlayerCreateWithoutDeathsInput>, Enumerable<PlayerUncheckedCreateWithoutDeathsInput>>
    connectOrCreate?: Enumerable<PlayerCreateOrConnectWithoutDeathsInput>
    upsert?: Enumerable<PlayerUpsertWithWhereUniqueWithoutDeathsInput>
    set?: Enumerable<PlayerWhereUniqueInput>
    disconnect?: Enumerable<PlayerWhereUniqueInput>
    delete?: Enumerable<PlayerWhereUniqueInput>
    connect?: Enumerable<PlayerWhereUniqueInput>
    update?: Enumerable<PlayerUpdateWithWhereUniqueWithoutDeathsInput>
    updateMany?: Enumerable<PlayerUpdateManyWithWhereWithoutDeathsInput>
    deleteMany?: Enumerable<PlayerScalarWhereInput>
  }

  export type PlayerEndOfGameStatCreateNestedOneWithoutPerksInput = {
    create?: XOR<PlayerEndOfGameStatCreateWithoutPerksInput, PlayerEndOfGameStatUncheckedCreateWithoutPerksInput>
    connectOrCreate?: PlayerEndOfGameStatCreateOrConnectWithoutPerksInput
    connect?: PlayerEndOfGameStatWhereUniqueInput
  }

  export type RuneStyleCreateNestedManyWithoutPlayerRunesInput = {
    create?: XOR<Enumerable<RuneStyleCreateWithoutPlayerRunesInput>, Enumerable<RuneStyleUncheckedCreateWithoutPlayerRunesInput>>
    connectOrCreate?: Enumerable<RuneStyleCreateOrConnectWithoutPlayerRunesInput>
    createMany?: RuneStyleCreateManyPlayerRunesInputEnvelope
    connect?: Enumerable<RuneStyleWhereUniqueInput>
  }

  export type PlayerEndOfGameStatUncheckedCreateNestedOneWithoutPerksInput = {
    create?: XOR<PlayerEndOfGameStatCreateWithoutPerksInput, PlayerEndOfGameStatUncheckedCreateWithoutPerksInput>
    connectOrCreate?: PlayerEndOfGameStatCreateOrConnectWithoutPerksInput
    connect?: PlayerEndOfGameStatWhereUniqueInput
  }

  export type RuneStyleUncheckedCreateNestedManyWithoutPlayerRunesInput = {
    create?: XOR<Enumerable<RuneStyleCreateWithoutPlayerRunesInput>, Enumerable<RuneStyleUncheckedCreateWithoutPlayerRunesInput>>
    connectOrCreate?: Enumerable<RuneStyleCreateOrConnectWithoutPlayerRunesInput>
    createMany?: RuneStyleCreateManyPlayerRunesInputEnvelope
    connect?: Enumerable<RuneStyleWhereUniqueInput>
  }

  export type PlayerEndOfGameStatUpdateOneWithoutPerksInput = {
    create?: XOR<PlayerEndOfGameStatCreateWithoutPerksInput, PlayerEndOfGameStatUncheckedCreateWithoutPerksInput>
    connectOrCreate?: PlayerEndOfGameStatCreateOrConnectWithoutPerksInput
    upsert?: PlayerEndOfGameStatUpsertWithoutPerksInput
    disconnect?: boolean
    delete?: boolean
    connect?: PlayerEndOfGameStatWhereUniqueInput
    update?: XOR<PlayerEndOfGameStatUpdateWithoutPerksInput, PlayerEndOfGameStatUncheckedUpdateWithoutPerksInput>
  }

  export type RuneStyleUpdateManyWithoutPlayerRunesInput = {
    create?: XOR<Enumerable<RuneStyleCreateWithoutPlayerRunesInput>, Enumerable<RuneStyleUncheckedCreateWithoutPlayerRunesInput>>
    connectOrCreate?: Enumerable<RuneStyleCreateOrConnectWithoutPlayerRunesInput>
    upsert?: Enumerable<RuneStyleUpsertWithWhereUniqueWithoutPlayerRunesInput>
    createMany?: RuneStyleCreateManyPlayerRunesInputEnvelope
    set?: Enumerable<RuneStyleWhereUniqueInput>
    disconnect?: Enumerable<RuneStyleWhereUniqueInput>
    delete?: Enumerable<RuneStyleWhereUniqueInput>
    connect?: Enumerable<RuneStyleWhereUniqueInput>
    update?: Enumerable<RuneStyleUpdateWithWhereUniqueWithoutPlayerRunesInput>
    updateMany?: Enumerable<RuneStyleUpdateManyWithWhereWithoutPlayerRunesInput>
    deleteMany?: Enumerable<RuneStyleScalarWhereInput>
  }

  export type PlayerEndOfGameStatUncheckedUpdateOneWithoutPerksInput = {
    create?: XOR<PlayerEndOfGameStatCreateWithoutPerksInput, PlayerEndOfGameStatUncheckedCreateWithoutPerksInput>
    connectOrCreate?: PlayerEndOfGameStatCreateOrConnectWithoutPerksInput
    upsert?: PlayerEndOfGameStatUpsertWithoutPerksInput
    disconnect?: boolean
    delete?: boolean
    connect?: PlayerEndOfGameStatWhereUniqueInput
    update?: XOR<PlayerEndOfGameStatUpdateWithoutPerksInput, PlayerEndOfGameStatUncheckedUpdateWithoutPerksInput>
  }

  export type RuneStyleUncheckedUpdateManyWithoutPlayerRunesInput = {
    create?: XOR<Enumerable<RuneStyleCreateWithoutPlayerRunesInput>, Enumerable<RuneStyleUncheckedCreateWithoutPlayerRunesInput>>
    connectOrCreate?: Enumerable<RuneStyleCreateOrConnectWithoutPlayerRunesInput>
    upsert?: Enumerable<RuneStyleUpsertWithWhereUniqueWithoutPlayerRunesInput>
    createMany?: RuneStyleCreateManyPlayerRunesInputEnvelope
    set?: Enumerable<RuneStyleWhereUniqueInput>
    disconnect?: Enumerable<RuneStyleWhereUniqueInput>
    delete?: Enumerable<RuneStyleWhereUniqueInput>
    connect?: Enumerable<RuneStyleWhereUniqueInput>
    update?: Enumerable<RuneStyleUpdateWithWhereUniqueWithoutPlayerRunesInput>
    updateMany?: Enumerable<RuneStyleUpdateManyWithWhereWithoutPlayerRunesInput>
    deleteMany?: Enumerable<RuneStyleScalarWhereInput>
  }

  export type PlayerCreateNestedManyWithoutSkillLevelUpEventsInput = {
    create?: XOR<Enumerable<PlayerCreateWithoutSkillLevelUpEventsInput>, Enumerable<PlayerUncheckedCreateWithoutSkillLevelUpEventsInput>>
    connectOrCreate?: Enumerable<PlayerCreateOrConnectWithoutSkillLevelUpEventsInput>
    connect?: Enumerable<PlayerWhereUniqueInput>
  }

  export type PlayerUncheckedCreateNestedManyWithoutSkillLevelUpEventsInput = {
    create?: XOR<Enumerable<PlayerCreateWithoutSkillLevelUpEventsInput>, Enumerable<PlayerUncheckedCreateWithoutSkillLevelUpEventsInput>>
    connectOrCreate?: Enumerable<PlayerCreateOrConnectWithoutSkillLevelUpEventsInput>
    connect?: Enumerable<PlayerWhereUniqueInput>
  }

  export type PlayerUpdateManyWithoutSkillLevelUpEventsInput = {
    create?: XOR<Enumerable<PlayerCreateWithoutSkillLevelUpEventsInput>, Enumerable<PlayerUncheckedCreateWithoutSkillLevelUpEventsInput>>
    connectOrCreate?: Enumerable<PlayerCreateOrConnectWithoutSkillLevelUpEventsInput>
    upsert?: Enumerable<PlayerUpsertWithWhereUniqueWithoutSkillLevelUpEventsInput>
    set?: Enumerable<PlayerWhereUniqueInput>
    disconnect?: Enumerable<PlayerWhereUniqueInput>
    delete?: Enumerable<PlayerWhereUniqueInput>
    connect?: Enumerable<PlayerWhereUniqueInput>
    update?: Enumerable<PlayerUpdateWithWhereUniqueWithoutSkillLevelUpEventsInput>
    updateMany?: Enumerable<PlayerUpdateManyWithWhereWithoutSkillLevelUpEventsInput>
    deleteMany?: Enumerable<PlayerScalarWhereInput>
  }

  export type PlayerUncheckedUpdateManyWithoutSkillLevelUpEventsInput = {
    create?: XOR<Enumerable<PlayerCreateWithoutSkillLevelUpEventsInput>, Enumerable<PlayerUncheckedCreateWithoutSkillLevelUpEventsInput>>
    connectOrCreate?: Enumerable<PlayerCreateOrConnectWithoutSkillLevelUpEventsInput>
    upsert?: Enumerable<PlayerUpsertWithWhereUniqueWithoutSkillLevelUpEventsInput>
    set?: Enumerable<PlayerWhereUniqueInput>
    disconnect?: Enumerable<PlayerWhereUniqueInput>
    delete?: Enumerable<PlayerWhereUniqueInput>
    connect?: Enumerable<PlayerWhereUniqueInput>
    update?: Enumerable<PlayerUpdateWithWhereUniqueWithoutSkillLevelUpEventsInput>
    updateMany?: Enumerable<PlayerUpdateManyWithWhereWithoutSkillLevelUpEventsInput>
    deleteMany?: Enumerable<PlayerScalarWhereInput>
  }

  export type PositionCreateNestedManyWithoutPlayerSnapshotInput = {
    create?: XOR<Enumerable<PositionCreateWithoutPlayerSnapshotInput>, Enumerable<PositionUncheckedCreateWithoutPlayerSnapshotInput>>
    connectOrCreate?: Enumerable<PositionCreateOrConnectWithoutPlayerSnapshotInput>
    connect?: Enumerable<PositionWhereUniqueInput>
  }

  export type PlayerCreateNestedManyWithoutSnapshotsInput = {
    create?: XOR<Enumerable<PlayerCreateWithoutSnapshotsInput>, Enumerable<PlayerUncheckedCreateWithoutSnapshotsInput>>
    connectOrCreate?: Enumerable<PlayerCreateOrConnectWithoutSnapshotsInput>
    connect?: Enumerable<PlayerWhereUniqueInput>
  }

  export type PositionUncheckedCreateNestedManyWithoutPlayerSnapshotInput = {
    create?: XOR<Enumerable<PositionCreateWithoutPlayerSnapshotInput>, Enumerable<PositionUncheckedCreateWithoutPlayerSnapshotInput>>
    connectOrCreate?: Enumerable<PositionCreateOrConnectWithoutPlayerSnapshotInput>
    connect?: Enumerable<PositionWhereUniqueInput>
  }

  export type PlayerUncheckedCreateNestedManyWithoutSnapshotsInput = {
    create?: XOR<Enumerable<PlayerCreateWithoutSnapshotsInput>, Enumerable<PlayerUncheckedCreateWithoutSnapshotsInput>>
    connectOrCreate?: Enumerable<PlayerCreateOrConnectWithoutSnapshotsInput>
    connect?: Enumerable<PlayerWhereUniqueInput>
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type PositionUpdateManyWithoutPlayerSnapshotInput = {
    create?: XOR<Enumerable<PositionCreateWithoutPlayerSnapshotInput>, Enumerable<PositionUncheckedCreateWithoutPlayerSnapshotInput>>
    connectOrCreate?: Enumerable<PositionCreateOrConnectWithoutPlayerSnapshotInput>
    upsert?: Enumerable<PositionUpsertWithWhereUniqueWithoutPlayerSnapshotInput>
    set?: Enumerable<PositionWhereUniqueInput>
    disconnect?: Enumerable<PositionWhereUniqueInput>
    delete?: Enumerable<PositionWhereUniqueInput>
    connect?: Enumerable<PositionWhereUniqueInput>
    update?: Enumerable<PositionUpdateWithWhereUniqueWithoutPlayerSnapshotInput>
    updateMany?: Enumerable<PositionUpdateManyWithWhereWithoutPlayerSnapshotInput>
    deleteMany?: Enumerable<PositionScalarWhereInput>
  }

  export type PlayerUpdateManyWithoutSnapshotsInput = {
    create?: XOR<Enumerable<PlayerCreateWithoutSnapshotsInput>, Enumerable<PlayerUncheckedCreateWithoutSnapshotsInput>>
    connectOrCreate?: Enumerable<PlayerCreateOrConnectWithoutSnapshotsInput>
    upsert?: Enumerable<PlayerUpsertWithWhereUniqueWithoutSnapshotsInput>
    set?: Enumerable<PlayerWhereUniqueInput>
    disconnect?: Enumerable<PlayerWhereUniqueInput>
    delete?: Enumerable<PlayerWhereUniqueInput>
    connect?: Enumerable<PlayerWhereUniqueInput>
    update?: Enumerable<PlayerUpdateWithWhereUniqueWithoutSnapshotsInput>
    updateMany?: Enumerable<PlayerUpdateManyWithWhereWithoutSnapshotsInput>
    deleteMany?: Enumerable<PlayerScalarWhereInput>
  }

  export type PositionUncheckedUpdateManyWithoutPlayerSnapshotInput = {
    create?: XOR<Enumerable<PositionCreateWithoutPlayerSnapshotInput>, Enumerable<PositionUncheckedCreateWithoutPlayerSnapshotInput>>
    connectOrCreate?: Enumerable<PositionCreateOrConnectWithoutPlayerSnapshotInput>
    upsert?: Enumerable<PositionUpsertWithWhereUniqueWithoutPlayerSnapshotInput>
    set?: Enumerable<PositionWhereUniqueInput>
    disconnect?: Enumerable<PositionWhereUniqueInput>
    delete?: Enumerable<PositionWhereUniqueInput>
    connect?: Enumerable<PositionWhereUniqueInput>
    update?: Enumerable<PositionUpdateWithWhereUniqueWithoutPlayerSnapshotInput>
    updateMany?: Enumerable<PositionUpdateManyWithWhereWithoutPlayerSnapshotInput>
    deleteMany?: Enumerable<PositionScalarWhereInput>
  }

  export type PlayerUncheckedUpdateManyWithoutSnapshotsInput = {
    create?: XOR<Enumerable<PlayerCreateWithoutSnapshotsInput>, Enumerable<PlayerUncheckedCreateWithoutSnapshotsInput>>
    connectOrCreate?: Enumerable<PlayerCreateOrConnectWithoutSnapshotsInput>
    upsert?: Enumerable<PlayerUpsertWithWhereUniqueWithoutSnapshotsInput>
    set?: Enumerable<PlayerWhereUniqueInput>
    disconnect?: Enumerable<PlayerWhereUniqueInput>
    delete?: Enumerable<PlayerWhereUniqueInput>
    connect?: Enumerable<PlayerWhereUniqueInput>
    update?: Enumerable<PlayerUpdateWithWhereUniqueWithoutSnapshotsInput>
    updateMany?: Enumerable<PlayerUpdateManyWithWhereWithoutSnapshotsInput>
    deleteMany?: Enumerable<PlayerScalarWhereInput>
  }

  export type PlayerCreateNestedManyWithoutWardEventsInput = {
    create?: XOR<Enumerable<PlayerCreateWithoutWardEventsInput>, Enumerable<PlayerUncheckedCreateWithoutWardEventsInput>>
    connectOrCreate?: Enumerable<PlayerCreateOrConnectWithoutWardEventsInput>
    connect?: Enumerable<PlayerWhereUniqueInput>
  }

  export type PlayerUncheckedCreateNestedManyWithoutWardEventsInput = {
    create?: XOR<Enumerable<PlayerCreateWithoutWardEventsInput>, Enumerable<PlayerUncheckedCreateWithoutWardEventsInput>>
    connectOrCreate?: Enumerable<PlayerCreateOrConnectWithoutWardEventsInput>
    connect?: Enumerable<PlayerWhereUniqueInput>
  }

  export type PlayerUpdateManyWithoutWardEventsInput = {
    create?: XOR<Enumerable<PlayerCreateWithoutWardEventsInput>, Enumerable<PlayerUncheckedCreateWithoutWardEventsInput>>
    connectOrCreate?: Enumerable<PlayerCreateOrConnectWithoutWardEventsInput>
    upsert?: Enumerable<PlayerUpsertWithWhereUniqueWithoutWardEventsInput>
    set?: Enumerable<PlayerWhereUniqueInput>
    disconnect?: Enumerable<PlayerWhereUniqueInput>
    delete?: Enumerable<PlayerWhereUniqueInput>
    connect?: Enumerable<PlayerWhereUniqueInput>
    update?: Enumerable<PlayerUpdateWithWhereUniqueWithoutWardEventsInput>
    updateMany?: Enumerable<PlayerUpdateManyWithWhereWithoutWardEventsInput>
    deleteMany?: Enumerable<PlayerScalarWhereInput>
  }

  export type NullableEnumPlayerWardEventWardTypeTypeFieldUpdateOperationsInput = {
    set?: PlayerWardEventWardTypeType | null
  }

  export type PlayerUncheckedUpdateManyWithoutWardEventsInput = {
    create?: XOR<Enumerable<PlayerCreateWithoutWardEventsInput>, Enumerable<PlayerUncheckedCreateWithoutWardEventsInput>>
    connectOrCreate?: Enumerable<PlayerCreateOrConnectWithoutWardEventsInput>
    upsert?: Enumerable<PlayerUpsertWithWhereUniqueWithoutWardEventsInput>
    set?: Enumerable<PlayerWhereUniqueInput>
    disconnect?: Enumerable<PlayerWhereUniqueInput>
    delete?: Enumerable<PlayerWhereUniqueInput>
    connect?: Enumerable<PlayerWhereUniqueInput>
    update?: Enumerable<PlayerUpdateWithWhereUniqueWithoutWardEventsInput>
    updateMany?: Enumerable<PlayerUpdateManyWithWhereWithoutWardEventsInput>
    deleteMany?: Enumerable<PlayerScalarWhereInput>
  }

  export type EventCreateNestedManyWithoutPositionInput = {
    create?: XOR<Enumerable<EventCreateWithoutPositionInput>, Enumerable<EventUncheckedCreateWithoutPositionInput>>
    connectOrCreate?: Enumerable<EventCreateOrConnectWithoutPositionInput>
    connect?: Enumerable<EventWhereUniqueInput>
  }

  export type PlayerSnapshotCreateNestedManyWithoutPositionInput = {
    create?: XOR<Enumerable<PlayerSnapshotCreateWithoutPositionInput>, Enumerable<PlayerSnapshotUncheckedCreateWithoutPositionInput>>
    connectOrCreate?: Enumerable<PlayerSnapshotCreateOrConnectWithoutPositionInput>
    connect?: Enumerable<PlayerSnapshotWhereUniqueInput>
  }

  export type EventUncheckedCreateNestedManyWithoutPositionInput = {
    create?: XOR<Enumerable<EventCreateWithoutPositionInput>, Enumerable<EventUncheckedCreateWithoutPositionInput>>
    connectOrCreate?: Enumerable<EventCreateOrConnectWithoutPositionInput>
    connect?: Enumerable<EventWhereUniqueInput>
  }

  export type PlayerSnapshotUncheckedCreateNestedManyWithoutPositionInput = {
    create?: XOR<Enumerable<PlayerSnapshotCreateWithoutPositionInput>, Enumerable<PlayerSnapshotUncheckedCreateWithoutPositionInput>>
    connectOrCreate?: Enumerable<PlayerSnapshotCreateOrConnectWithoutPositionInput>
    connect?: Enumerable<PlayerSnapshotWhereUniqueInput>
  }

  export type EventUpdateManyWithoutPositionInput = {
    create?: XOR<Enumerable<EventCreateWithoutPositionInput>, Enumerable<EventUncheckedCreateWithoutPositionInput>>
    connectOrCreate?: Enumerable<EventCreateOrConnectWithoutPositionInput>
    upsert?: Enumerable<EventUpsertWithWhereUniqueWithoutPositionInput>
    set?: Enumerable<EventWhereUniqueInput>
    disconnect?: Enumerable<EventWhereUniqueInput>
    delete?: Enumerable<EventWhereUniqueInput>
    connect?: Enumerable<EventWhereUniqueInput>
    update?: Enumerable<EventUpdateWithWhereUniqueWithoutPositionInput>
    updateMany?: Enumerable<EventUpdateManyWithWhereWithoutPositionInput>
    deleteMany?: Enumerable<EventScalarWhereInput>
  }

  export type PlayerSnapshotUpdateManyWithoutPositionInput = {
    create?: XOR<Enumerable<PlayerSnapshotCreateWithoutPositionInput>, Enumerable<PlayerSnapshotUncheckedCreateWithoutPositionInput>>
    connectOrCreate?: Enumerable<PlayerSnapshotCreateOrConnectWithoutPositionInput>
    upsert?: Enumerable<PlayerSnapshotUpsertWithWhereUniqueWithoutPositionInput>
    set?: Enumerable<PlayerSnapshotWhereUniqueInput>
    disconnect?: Enumerable<PlayerSnapshotWhereUniqueInput>
    delete?: Enumerable<PlayerSnapshotWhereUniqueInput>
    connect?: Enumerable<PlayerSnapshotWhereUniqueInput>
    update?: Enumerable<PlayerSnapshotUpdateWithWhereUniqueWithoutPositionInput>
    updateMany?: Enumerable<PlayerSnapshotUpdateManyWithWhereWithoutPositionInput>
    deleteMany?: Enumerable<PlayerSnapshotScalarWhereInput>
  }

  export type EventUncheckedUpdateManyWithoutPositionInput = {
    create?: XOR<Enumerable<EventCreateWithoutPositionInput>, Enumerable<EventUncheckedCreateWithoutPositionInput>>
    connectOrCreate?: Enumerable<EventCreateOrConnectWithoutPositionInput>
    upsert?: Enumerable<EventUpsertWithWhereUniqueWithoutPositionInput>
    set?: Enumerable<EventWhereUniqueInput>
    disconnect?: Enumerable<EventWhereUniqueInput>
    delete?: Enumerable<EventWhereUniqueInput>
    connect?: Enumerable<EventWhereUniqueInput>
    update?: Enumerable<EventUpdateWithWhereUniqueWithoutPositionInput>
    updateMany?: Enumerable<EventUpdateManyWithWhereWithoutPositionInput>
    deleteMany?: Enumerable<EventScalarWhereInput>
  }

  export type PlayerSnapshotUncheckedUpdateManyWithoutPositionInput = {
    create?: XOR<Enumerable<PlayerSnapshotCreateWithoutPositionInput>, Enumerable<PlayerSnapshotUncheckedCreateWithoutPositionInput>>
    connectOrCreate?: Enumerable<PlayerSnapshotCreateOrConnectWithoutPositionInput>
    upsert?: Enumerable<PlayerSnapshotUpsertWithWhereUniqueWithoutPositionInput>
    set?: Enumerable<PlayerSnapshotWhereUniqueInput>
    disconnect?: Enumerable<PlayerSnapshotWhereUniqueInput>
    delete?: Enumerable<PlayerSnapshotWhereUniqueInput>
    connect?: Enumerable<PlayerSnapshotWhereUniqueInput>
    update?: Enumerable<PlayerSnapshotUpdateWithWhereUniqueWithoutPositionInput>
    updateMany?: Enumerable<PlayerSnapshotUpdateManyWithWhereWithoutPositionInput>
    deleteMany?: Enumerable<PlayerSnapshotScalarWhereInput>
  }

  export type PlayerCreateNestedOneWithoutProfileInput = {
    create?: XOR<PlayerCreateWithoutProfileInput, PlayerUncheckedCreateWithoutProfileInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutProfileInput
    connect?: PlayerWhereUniqueInput
  }

  export type ActivityCreateNestedManyWithoutProfileInput = {
    create?: XOR<Enumerable<ActivityCreateWithoutProfileInput>, Enumerable<ActivityUncheckedCreateWithoutProfileInput>>
    connectOrCreate?: Enumerable<ActivityCreateOrConnectWithoutProfileInput>
    createMany?: ActivityCreateManyProfileInputEnvelope
    connect?: Enumerable<ActivityWhereUniqueInput>
  }

  export type ChampionWinrateCreateNestedManyWithoutProfileInput = {
    create?: XOR<Enumerable<ChampionWinrateCreateWithoutProfileInput>, Enumerable<ChampionWinrateUncheckedCreateWithoutProfileInput>>
    connectOrCreate?: Enumerable<ChampionWinrateCreateOrConnectWithoutProfileInput>
    createMany?: ChampionWinrateCreateManyProfileInputEnvelope
    connect?: Enumerable<ChampionWinrateWhereUniqueInput>
  }

  export type DuoCreateNestedManyWithoutProfileInput = {
    create?: XOR<Enumerable<DuoCreateWithoutProfileInput>, Enumerable<DuoUncheckedCreateWithoutProfileInput>>
    connectOrCreate?: Enumerable<DuoCreateOrConnectWithoutProfileInput>
    createMany?: DuoCreateManyProfileInputEnvelope
    connect?: Enumerable<DuoWhereUniqueInput>
  }

  export type PlayerUncheckedCreateNestedOneWithoutProfileInput = {
    create?: XOR<PlayerCreateWithoutProfileInput, PlayerUncheckedCreateWithoutProfileInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutProfileInput
    connect?: PlayerWhereUniqueInput
  }

  export type ActivityUncheckedCreateNestedManyWithoutProfileInput = {
    create?: XOR<Enumerable<ActivityCreateWithoutProfileInput>, Enumerable<ActivityUncheckedCreateWithoutProfileInput>>
    connectOrCreate?: Enumerable<ActivityCreateOrConnectWithoutProfileInput>
    createMany?: ActivityCreateManyProfileInputEnvelope
    connect?: Enumerable<ActivityWhereUniqueInput>
  }

  export type ChampionWinrateUncheckedCreateNestedManyWithoutProfileInput = {
    create?: XOR<Enumerable<ChampionWinrateCreateWithoutProfileInput>, Enumerable<ChampionWinrateUncheckedCreateWithoutProfileInput>>
    connectOrCreate?: Enumerable<ChampionWinrateCreateOrConnectWithoutProfileInput>
    createMany?: ChampionWinrateCreateManyProfileInputEnvelope
    connect?: Enumerable<ChampionWinrateWhereUniqueInput>
  }

  export type DuoUncheckedCreateNestedManyWithoutProfileInput = {
    create?: XOR<Enumerable<DuoCreateWithoutProfileInput>, Enumerable<DuoUncheckedCreateWithoutProfileInput>>
    connectOrCreate?: Enumerable<DuoCreateOrConnectWithoutProfileInput>
    createMany?: DuoCreateManyProfileInputEnvelope
    connect?: Enumerable<DuoWhereUniqueInput>
  }

  export type PlayerUpdateOneWithoutProfileInput = {
    create?: XOR<PlayerCreateWithoutProfileInput, PlayerUncheckedCreateWithoutProfileInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutProfileInput
    upsert?: PlayerUpsertWithoutProfileInput
    disconnect?: boolean
    delete?: boolean
    connect?: PlayerWhereUniqueInput
    update?: XOR<PlayerUpdateWithoutProfileInput, PlayerUncheckedUpdateWithoutProfileInput>
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type ActivityUpdateManyWithoutProfileInput = {
    create?: XOR<Enumerable<ActivityCreateWithoutProfileInput>, Enumerable<ActivityUncheckedCreateWithoutProfileInput>>
    connectOrCreate?: Enumerable<ActivityCreateOrConnectWithoutProfileInput>
    upsert?: Enumerable<ActivityUpsertWithWhereUniqueWithoutProfileInput>
    createMany?: ActivityCreateManyProfileInputEnvelope
    set?: Enumerable<ActivityWhereUniqueInput>
    disconnect?: Enumerable<ActivityWhereUniqueInput>
    delete?: Enumerable<ActivityWhereUniqueInput>
    connect?: Enumerable<ActivityWhereUniqueInput>
    update?: Enumerable<ActivityUpdateWithWhereUniqueWithoutProfileInput>
    updateMany?: Enumerable<ActivityUpdateManyWithWhereWithoutProfileInput>
    deleteMany?: Enumerable<ActivityScalarWhereInput>
  }

  export type ChampionWinrateUpdateManyWithoutProfileInput = {
    create?: XOR<Enumerable<ChampionWinrateCreateWithoutProfileInput>, Enumerable<ChampionWinrateUncheckedCreateWithoutProfileInput>>
    connectOrCreate?: Enumerable<ChampionWinrateCreateOrConnectWithoutProfileInput>
    upsert?: Enumerable<ChampionWinrateUpsertWithWhereUniqueWithoutProfileInput>
    createMany?: ChampionWinrateCreateManyProfileInputEnvelope
    set?: Enumerable<ChampionWinrateWhereUniqueInput>
    disconnect?: Enumerable<ChampionWinrateWhereUniqueInput>
    delete?: Enumerable<ChampionWinrateWhereUniqueInput>
    connect?: Enumerable<ChampionWinrateWhereUniqueInput>
    update?: Enumerable<ChampionWinrateUpdateWithWhereUniqueWithoutProfileInput>
    updateMany?: Enumerable<ChampionWinrateUpdateManyWithWhereWithoutProfileInput>
    deleteMany?: Enumerable<ChampionWinrateScalarWhereInput>
  }

  export type DuoUpdateManyWithoutProfileInput = {
    create?: XOR<Enumerable<DuoCreateWithoutProfileInput>, Enumerable<DuoUncheckedCreateWithoutProfileInput>>
    connectOrCreate?: Enumerable<DuoCreateOrConnectWithoutProfileInput>
    upsert?: Enumerable<DuoUpsertWithWhereUniqueWithoutProfileInput>
    createMany?: DuoCreateManyProfileInputEnvelope
    set?: Enumerable<DuoWhereUniqueInput>
    disconnect?: Enumerable<DuoWhereUniqueInput>
    delete?: Enumerable<DuoWhereUniqueInput>
    connect?: Enumerable<DuoWhereUniqueInput>
    update?: Enumerable<DuoUpdateWithWhereUniqueWithoutProfileInput>
    updateMany?: Enumerable<DuoUpdateManyWithWhereWithoutProfileInput>
    deleteMany?: Enumerable<DuoScalarWhereInput>
  }

  export type PlayerUncheckedUpdateOneWithoutProfileInput = {
    create?: XOR<PlayerCreateWithoutProfileInput, PlayerUncheckedCreateWithoutProfileInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutProfileInput
    upsert?: PlayerUpsertWithoutProfileInput
    disconnect?: boolean
    delete?: boolean
    connect?: PlayerWhereUniqueInput
    update?: XOR<PlayerUpdateWithoutProfileInput, PlayerUncheckedUpdateWithoutProfileInput>
  }

  export type ActivityUncheckedUpdateManyWithoutProfileInput = {
    create?: XOR<Enumerable<ActivityCreateWithoutProfileInput>, Enumerable<ActivityUncheckedCreateWithoutProfileInput>>
    connectOrCreate?: Enumerable<ActivityCreateOrConnectWithoutProfileInput>
    upsert?: Enumerable<ActivityUpsertWithWhereUniqueWithoutProfileInput>
    createMany?: ActivityCreateManyProfileInputEnvelope
    set?: Enumerable<ActivityWhereUniqueInput>
    disconnect?: Enumerable<ActivityWhereUniqueInput>
    delete?: Enumerable<ActivityWhereUniqueInput>
    connect?: Enumerable<ActivityWhereUniqueInput>
    update?: Enumerable<ActivityUpdateWithWhereUniqueWithoutProfileInput>
    updateMany?: Enumerable<ActivityUpdateManyWithWhereWithoutProfileInput>
    deleteMany?: Enumerable<ActivityScalarWhereInput>
  }

  export type ChampionWinrateUncheckedUpdateManyWithoutProfileInput = {
    create?: XOR<Enumerable<ChampionWinrateCreateWithoutProfileInput>, Enumerable<ChampionWinrateUncheckedCreateWithoutProfileInput>>
    connectOrCreate?: Enumerable<ChampionWinrateCreateOrConnectWithoutProfileInput>
    upsert?: Enumerable<ChampionWinrateUpsertWithWhereUniqueWithoutProfileInput>
    createMany?: ChampionWinrateCreateManyProfileInputEnvelope
    set?: Enumerable<ChampionWinrateWhereUniqueInput>
    disconnect?: Enumerable<ChampionWinrateWhereUniqueInput>
    delete?: Enumerable<ChampionWinrateWhereUniqueInput>
    connect?: Enumerable<ChampionWinrateWhereUniqueInput>
    update?: Enumerable<ChampionWinrateUpdateWithWhereUniqueWithoutProfileInput>
    updateMany?: Enumerable<ChampionWinrateUpdateManyWithWhereWithoutProfileInput>
    deleteMany?: Enumerable<ChampionWinrateScalarWhereInput>
  }

  export type DuoUncheckedUpdateManyWithoutProfileInput = {
    create?: XOR<Enumerable<DuoCreateWithoutProfileInput>, Enumerable<DuoUncheckedCreateWithoutProfileInput>>
    connectOrCreate?: Enumerable<DuoCreateOrConnectWithoutProfileInput>
    upsert?: Enumerable<DuoUpsertWithWhereUniqueWithoutProfileInput>
    createMany?: DuoCreateManyProfileInputEnvelope
    set?: Enumerable<DuoWhereUniqueInput>
    disconnect?: Enumerable<DuoWhereUniqueInput>
    delete?: Enumerable<DuoWhereUniqueInput>
    connect?: Enumerable<DuoWhereUniqueInput>
    update?: Enumerable<DuoUpdateWithWhereUniqueWithoutProfileInput>
    updateMany?: Enumerable<DuoUpdateManyWithWhereWithoutProfileInput>
    deleteMany?: Enumerable<DuoScalarWhereInput>
  }

  export type GameCreateNestedManyWithoutSourceInput = {
    create?: XOR<Enumerable<GameCreateWithoutSourceInput>, Enumerable<GameUncheckedCreateWithoutSourceInput>>
    connectOrCreate?: Enumerable<GameCreateOrConnectWithoutSourceInput>
    connect?: Enumerable<GameWhereUniqueInput>
  }

  export type GameUncheckedCreateNestedManyWithoutSourceInput = {
    create?: XOR<Enumerable<GameCreateWithoutSourceInput>, Enumerable<GameUncheckedCreateWithoutSourceInput>>
    connectOrCreate?: Enumerable<GameCreateOrConnectWithoutSourceInput>
    connect?: Enumerable<GameWhereUniqueInput>
  }

  export type GameUpdateManyWithoutSourceInput = {
    create?: XOR<Enumerable<GameCreateWithoutSourceInput>, Enumerable<GameUncheckedCreateWithoutSourceInput>>
    connectOrCreate?: Enumerable<GameCreateOrConnectWithoutSourceInput>
    upsert?: Enumerable<GameUpsertWithWhereUniqueWithoutSourceInput>
    set?: Enumerable<GameWhereUniqueInput>
    disconnect?: Enumerable<GameWhereUniqueInput>
    delete?: Enumerable<GameWhereUniqueInput>
    connect?: Enumerable<GameWhereUniqueInput>
    update?: Enumerable<GameUpdateWithWhereUniqueWithoutSourceInput>
    updateMany?: Enumerable<GameUpdateManyWithWhereWithoutSourceInput>
    deleteMany?: Enumerable<GameScalarWhereInput>
  }

  export type GameUncheckedUpdateManyWithoutSourceInput = {
    create?: XOR<Enumerable<GameCreateWithoutSourceInput>, Enumerable<GameUncheckedCreateWithoutSourceInput>>
    connectOrCreate?: Enumerable<GameCreateOrConnectWithoutSourceInput>
    upsert?: Enumerable<GameUpsertWithWhereUniqueWithoutSourceInput>
    set?: Enumerable<GameWhereUniqueInput>
    disconnect?: Enumerable<GameWhereUniqueInput>
    delete?: Enumerable<GameWhereUniqueInput>
    connect?: Enumerable<GameWhereUniqueInput>
    update?: Enumerable<GameUpdateWithWhereUniqueWithoutSourceInput>
    updateMany?: Enumerable<GameUpdateManyWithWhereWithoutSourceInput>
    deleteMany?: Enumerable<GameScalarWhereInput>
  }

  export type PickBanCreateNestedManyWithoutTeamInput = {
    create?: XOR<Enumerable<PickBanCreateWithoutTeamInput>, Enumerable<PickBanUncheckedCreateWithoutTeamInput>>
    connectOrCreate?: Enumerable<PickBanCreateOrConnectWithoutTeamInput>
    createMany?: PickBanCreateManyTeamInputEnvelope
    connect?: Enumerable<PickBanWhereUniqueInput>
  }

  export type GameCreateNestedOneWithoutFrom_Team_gameInput = {
    create?: XOR<GameCreateWithoutFrom_Team_gameInput, GameUncheckedCreateWithoutFrom_Team_gameInput>
    connectOrCreate?: GameCreateOrConnectWithoutFrom_Team_gameInput
    connect?: GameWhereUniqueInput
  }

  export type PlayerCreateNestedManyWithoutTeamsInput = {
    create?: XOR<Enumerable<PlayerCreateWithoutTeamsInput>, Enumerable<PlayerUncheckedCreateWithoutTeamsInput>>
    connectOrCreate?: Enumerable<PlayerCreateOrConnectWithoutTeamsInput>
    connect?: Enumerable<PlayerWhereUniqueInput>
  }

  export type ObjectiveCreateNestedManyWithoutTeamInput = {
    create?: XOR<Enumerable<ObjectiveCreateWithoutTeamInput>, Enumerable<ObjectiveUncheckedCreateWithoutTeamInput>>
    connectOrCreate?: Enumerable<ObjectiveCreateOrConnectWithoutTeamInput>
    createMany?: ObjectiveCreateManyTeamInputEnvelope
    connect?: Enumerable<ObjectiveWhereUniqueInput>
  }

  export type GameCreateNestedManyWithoutBlueTeamInput = {
    create?: XOR<Enumerable<GameCreateWithoutBlueTeamInput>, Enumerable<GameUncheckedCreateWithoutBlueTeamInput>>
    connectOrCreate?: Enumerable<GameCreateOrConnectWithoutBlueTeamInput>
    createMany?: GameCreateManyBlueTeamInputEnvelope
    connect?: Enumerable<GameWhereUniqueInput>
  }

  export type GameCreateNestedManyWithoutRedTeamInput = {
    create?: XOR<Enumerable<GameCreateWithoutRedTeamInput>, Enumerable<GameUncheckedCreateWithoutRedTeamInput>>
    connectOrCreate?: Enumerable<GameCreateOrConnectWithoutRedTeamInput>
    createMany?: GameCreateManyRedTeamInputEnvelope
    connect?: Enumerable<GameWhereUniqueInput>
  }

  export type PickBanUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<Enumerable<PickBanCreateWithoutTeamInput>, Enumerable<PickBanUncheckedCreateWithoutTeamInput>>
    connectOrCreate?: Enumerable<PickBanCreateOrConnectWithoutTeamInput>
    createMany?: PickBanCreateManyTeamInputEnvelope
    connect?: Enumerable<PickBanWhereUniqueInput>
  }

  export type PlayerUncheckedCreateNestedManyWithoutTeamsInput = {
    create?: XOR<Enumerable<PlayerCreateWithoutTeamsInput>, Enumerable<PlayerUncheckedCreateWithoutTeamsInput>>
    connectOrCreate?: Enumerable<PlayerCreateOrConnectWithoutTeamsInput>
    connect?: Enumerable<PlayerWhereUniqueInput>
  }

  export type ObjectiveUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<Enumerable<ObjectiveCreateWithoutTeamInput>, Enumerable<ObjectiveUncheckedCreateWithoutTeamInput>>
    connectOrCreate?: Enumerable<ObjectiveCreateOrConnectWithoutTeamInput>
    createMany?: ObjectiveCreateManyTeamInputEnvelope
    connect?: Enumerable<ObjectiveWhereUniqueInput>
  }

  export type GameUncheckedCreateNestedManyWithoutBlueTeamInput = {
    create?: XOR<Enumerable<GameCreateWithoutBlueTeamInput>, Enumerable<GameUncheckedCreateWithoutBlueTeamInput>>
    connectOrCreate?: Enumerable<GameCreateOrConnectWithoutBlueTeamInput>
    createMany?: GameCreateManyBlueTeamInputEnvelope
    connect?: Enumerable<GameWhereUniqueInput>
  }

  export type GameUncheckedCreateNestedManyWithoutRedTeamInput = {
    create?: XOR<Enumerable<GameCreateWithoutRedTeamInput>, Enumerable<GameUncheckedCreateWithoutRedTeamInput>>
    connectOrCreate?: Enumerable<GameCreateOrConnectWithoutRedTeamInput>
    createMany?: GameCreateManyRedTeamInputEnvelope
    connect?: Enumerable<GameWhereUniqueInput>
  }

  export type PickBanUpdateManyWithoutTeamInput = {
    create?: XOR<Enumerable<PickBanCreateWithoutTeamInput>, Enumerable<PickBanUncheckedCreateWithoutTeamInput>>
    connectOrCreate?: Enumerable<PickBanCreateOrConnectWithoutTeamInput>
    upsert?: Enumerable<PickBanUpsertWithWhereUniqueWithoutTeamInput>
    createMany?: PickBanCreateManyTeamInputEnvelope
    set?: Enumerable<PickBanWhereUniqueInput>
    disconnect?: Enumerable<PickBanWhereUniqueInput>
    delete?: Enumerable<PickBanWhereUniqueInput>
    connect?: Enumerable<PickBanWhereUniqueInput>
    update?: Enumerable<PickBanUpdateWithWhereUniqueWithoutTeamInput>
    updateMany?: Enumerable<PickBanUpdateManyWithWhereWithoutTeamInput>
    deleteMany?: Enumerable<PickBanScalarWhereInput>
  }

  export type GameUpdateOneWithoutFrom_Team_gameInput = {
    create?: XOR<GameCreateWithoutFrom_Team_gameInput, GameUncheckedCreateWithoutFrom_Team_gameInput>
    connectOrCreate?: GameCreateOrConnectWithoutFrom_Team_gameInput
    upsert?: GameUpsertWithoutFrom_Team_gameInput
    disconnect?: boolean
    delete?: boolean
    connect?: GameWhereUniqueInput
    update?: XOR<GameUpdateWithoutFrom_Team_gameInput, GameUncheckedUpdateWithoutFrom_Team_gameInput>
  }

  export type PlayerUpdateManyWithoutTeamsInput = {
    create?: XOR<Enumerable<PlayerCreateWithoutTeamsInput>, Enumerable<PlayerUncheckedCreateWithoutTeamsInput>>
    connectOrCreate?: Enumerable<PlayerCreateOrConnectWithoutTeamsInput>
    upsert?: Enumerable<PlayerUpsertWithWhereUniqueWithoutTeamsInput>
    set?: Enumerable<PlayerWhereUniqueInput>
    disconnect?: Enumerable<PlayerWhereUniqueInput>
    delete?: Enumerable<PlayerWhereUniqueInput>
    connect?: Enumerable<PlayerWhereUniqueInput>
    update?: Enumerable<PlayerUpdateWithWhereUniqueWithoutTeamsInput>
    updateMany?: Enumerable<PlayerUpdateManyWithWhereWithoutTeamsInput>
    deleteMany?: Enumerable<PlayerScalarWhereInput>
  }

  export type ObjectiveUpdateManyWithoutTeamInput = {
    create?: XOR<Enumerable<ObjectiveCreateWithoutTeamInput>, Enumerable<ObjectiveUncheckedCreateWithoutTeamInput>>
    connectOrCreate?: Enumerable<ObjectiveCreateOrConnectWithoutTeamInput>
    upsert?: Enumerable<ObjectiveUpsertWithWhereUniqueWithoutTeamInput>
    createMany?: ObjectiveCreateManyTeamInputEnvelope
    set?: Enumerable<ObjectiveWhereUniqueInput>
    disconnect?: Enumerable<ObjectiveWhereUniqueInput>
    delete?: Enumerable<ObjectiveWhereUniqueInput>
    connect?: Enumerable<ObjectiveWhereUniqueInput>
    update?: Enumerable<ObjectiveUpdateWithWhereUniqueWithoutTeamInput>
    updateMany?: Enumerable<ObjectiveUpdateManyWithWhereWithoutTeamInput>
    deleteMany?: Enumerable<ObjectiveScalarWhereInput>
  }

  export type GameUpdateManyWithoutBlueTeamInput = {
    create?: XOR<Enumerable<GameCreateWithoutBlueTeamInput>, Enumerable<GameUncheckedCreateWithoutBlueTeamInput>>
    connectOrCreate?: Enumerable<GameCreateOrConnectWithoutBlueTeamInput>
    upsert?: Enumerable<GameUpsertWithWhereUniqueWithoutBlueTeamInput>
    createMany?: GameCreateManyBlueTeamInputEnvelope
    set?: Enumerable<GameWhereUniqueInput>
    disconnect?: Enumerable<GameWhereUniqueInput>
    delete?: Enumerable<GameWhereUniqueInput>
    connect?: Enumerable<GameWhereUniqueInput>
    update?: Enumerable<GameUpdateWithWhereUniqueWithoutBlueTeamInput>
    updateMany?: Enumerable<GameUpdateManyWithWhereWithoutBlueTeamInput>
    deleteMany?: Enumerable<GameScalarWhereInput>
  }

  export type GameUpdateManyWithoutRedTeamInput = {
    create?: XOR<Enumerable<GameCreateWithoutRedTeamInput>, Enumerable<GameUncheckedCreateWithoutRedTeamInput>>
    connectOrCreate?: Enumerable<GameCreateOrConnectWithoutRedTeamInput>
    upsert?: Enumerable<GameUpsertWithWhereUniqueWithoutRedTeamInput>
    createMany?: GameCreateManyRedTeamInputEnvelope
    set?: Enumerable<GameWhereUniqueInput>
    disconnect?: Enumerable<GameWhereUniqueInput>
    delete?: Enumerable<GameWhereUniqueInput>
    connect?: Enumerable<GameWhereUniqueInput>
    update?: Enumerable<GameUpdateWithWhereUniqueWithoutRedTeamInput>
    updateMany?: Enumerable<GameUpdateManyWithWhereWithoutRedTeamInput>
    deleteMany?: Enumerable<GameScalarWhereInput>
  }

  export type PickBanUncheckedUpdateManyWithoutTeamInput = {
    create?: XOR<Enumerable<PickBanCreateWithoutTeamInput>, Enumerable<PickBanUncheckedCreateWithoutTeamInput>>
    connectOrCreate?: Enumerable<PickBanCreateOrConnectWithoutTeamInput>
    upsert?: Enumerable<PickBanUpsertWithWhereUniqueWithoutTeamInput>
    createMany?: PickBanCreateManyTeamInputEnvelope
    set?: Enumerable<PickBanWhereUniqueInput>
    disconnect?: Enumerable<PickBanWhereUniqueInput>
    delete?: Enumerable<PickBanWhereUniqueInput>
    connect?: Enumerable<PickBanWhereUniqueInput>
    update?: Enumerable<PickBanUpdateWithWhereUniqueWithoutTeamInput>
    updateMany?: Enumerable<PickBanUpdateManyWithWhereWithoutTeamInput>
    deleteMany?: Enumerable<PickBanScalarWhereInput>
  }

  export type PlayerUncheckedUpdateManyWithoutTeamsInput = {
    create?: XOR<Enumerable<PlayerCreateWithoutTeamsInput>, Enumerable<PlayerUncheckedCreateWithoutTeamsInput>>
    connectOrCreate?: Enumerable<PlayerCreateOrConnectWithoutTeamsInput>
    upsert?: Enumerable<PlayerUpsertWithWhereUniqueWithoutTeamsInput>
    set?: Enumerable<PlayerWhereUniqueInput>
    disconnect?: Enumerable<PlayerWhereUniqueInput>
    delete?: Enumerable<PlayerWhereUniqueInput>
    connect?: Enumerable<PlayerWhereUniqueInput>
    update?: Enumerable<PlayerUpdateWithWhereUniqueWithoutTeamsInput>
    updateMany?: Enumerable<PlayerUpdateManyWithWhereWithoutTeamsInput>
    deleteMany?: Enumerable<PlayerScalarWhereInput>
  }

  export type ObjectiveUncheckedUpdateManyWithoutTeamInput = {
    create?: XOR<Enumerable<ObjectiveCreateWithoutTeamInput>, Enumerable<ObjectiveUncheckedCreateWithoutTeamInput>>
    connectOrCreate?: Enumerable<ObjectiveCreateOrConnectWithoutTeamInput>
    upsert?: Enumerable<ObjectiveUpsertWithWhereUniqueWithoutTeamInput>
    createMany?: ObjectiveCreateManyTeamInputEnvelope
    set?: Enumerable<ObjectiveWhereUniqueInput>
    disconnect?: Enumerable<ObjectiveWhereUniqueInput>
    delete?: Enumerable<ObjectiveWhereUniqueInput>
    connect?: Enumerable<ObjectiveWhereUniqueInput>
    update?: Enumerable<ObjectiveUpdateWithWhereUniqueWithoutTeamInput>
    updateMany?: Enumerable<ObjectiveUpdateManyWithWhereWithoutTeamInput>
    deleteMany?: Enumerable<ObjectiveScalarWhereInput>
  }

  export type GameUncheckedUpdateManyWithoutBlueTeamInput = {
    create?: XOR<Enumerable<GameCreateWithoutBlueTeamInput>, Enumerable<GameUncheckedCreateWithoutBlueTeamInput>>
    connectOrCreate?: Enumerable<GameCreateOrConnectWithoutBlueTeamInput>
    upsert?: Enumerable<GameUpsertWithWhereUniqueWithoutBlueTeamInput>
    createMany?: GameCreateManyBlueTeamInputEnvelope
    set?: Enumerable<GameWhereUniqueInput>
    disconnect?: Enumerable<GameWhereUniqueInput>
    delete?: Enumerable<GameWhereUniqueInput>
    connect?: Enumerable<GameWhereUniqueInput>
    update?: Enumerable<GameUpdateWithWhereUniqueWithoutBlueTeamInput>
    updateMany?: Enumerable<GameUpdateManyWithWhereWithoutBlueTeamInput>
    deleteMany?: Enumerable<GameScalarWhereInput>
  }

  export type GameUncheckedUpdateManyWithoutRedTeamInput = {
    create?: XOR<Enumerable<GameCreateWithoutRedTeamInput>, Enumerable<GameUncheckedCreateWithoutRedTeamInput>>
    connectOrCreate?: Enumerable<GameCreateOrConnectWithoutRedTeamInput>
    upsert?: Enumerable<GameUpsertWithWhereUniqueWithoutRedTeamInput>
    createMany?: GameCreateManyRedTeamInputEnvelope
    set?: Enumerable<GameWhereUniqueInput>
    disconnect?: Enumerable<GameWhereUniqueInput>
    delete?: Enumerable<GameWhereUniqueInput>
    connect?: Enumerable<GameWhereUniqueInput>
    update?: Enumerable<GameUpdateWithWhereUniqueWithoutRedTeamInput>
    updateMany?: Enumerable<GameUpdateManyWithWhereWithoutRedTeamInput>
    deleteMany?: Enumerable<GameScalarWhereInput>
  }

  export type PlayerCreateNestedManyWithoutBuildingKillsInput = {
    create?: XOR<Enumerable<PlayerCreateWithoutBuildingKillsInput>, Enumerable<PlayerUncheckedCreateWithoutBuildingKillsInput>>
    connectOrCreate?: Enumerable<PlayerCreateOrConnectWithoutBuildingKillsInput>
    connect?: Enumerable<PlayerWhereUniqueInput>
  }

  export type PlayerUncheckedCreateNestedManyWithoutBuildingKillsInput = {
    create?: XOR<Enumerable<PlayerCreateWithoutBuildingKillsInput>, Enumerable<PlayerUncheckedCreateWithoutBuildingKillsInput>>
    connectOrCreate?: Enumerable<PlayerCreateOrConnectWithoutBuildingKillsInput>
    connect?: Enumerable<PlayerWhereUniqueInput>
  }

  export type PlayerUpdateManyWithoutBuildingKillsInput = {
    create?: XOR<Enumerable<PlayerCreateWithoutBuildingKillsInput>, Enumerable<PlayerUncheckedCreateWithoutBuildingKillsInput>>
    connectOrCreate?: Enumerable<PlayerCreateOrConnectWithoutBuildingKillsInput>
    upsert?: Enumerable<PlayerUpsertWithWhereUniqueWithoutBuildingKillsInput>
    set?: Enumerable<PlayerWhereUniqueInput>
    disconnect?: Enumerable<PlayerWhereUniqueInput>
    delete?: Enumerable<PlayerWhereUniqueInput>
    connect?: Enumerable<PlayerWhereUniqueInput>
    update?: Enumerable<PlayerUpdateWithWhereUniqueWithoutBuildingKillsInput>
    updateMany?: Enumerable<PlayerUpdateManyWithWhereWithoutBuildingKillsInput>
    deleteMany?: Enumerable<PlayerScalarWhereInput>
  }

  export type PlayerUncheckedUpdateManyWithoutBuildingKillsInput = {
    create?: XOR<Enumerable<PlayerCreateWithoutBuildingKillsInput>, Enumerable<PlayerUncheckedCreateWithoutBuildingKillsInput>>
    connectOrCreate?: Enumerable<PlayerCreateOrConnectWithoutBuildingKillsInput>
    upsert?: Enumerable<PlayerUpsertWithWhereUniqueWithoutBuildingKillsInput>
    set?: Enumerable<PlayerWhereUniqueInput>
    disconnect?: Enumerable<PlayerWhereUniqueInput>
    delete?: Enumerable<PlayerWhereUniqueInput>
    connect?: Enumerable<PlayerWhereUniqueInput>
    update?: Enumerable<PlayerUpdateWithWhereUniqueWithoutBuildingKillsInput>
    updateMany?: Enumerable<PlayerUpdateManyWithWhereWithoutBuildingKillsInput>
    deleteMany?: Enumerable<PlayerScalarWhereInput>
  }

  export type PlayerCreateNestedManyWithoutMonsterKillsInput = {
    create?: XOR<Enumerable<PlayerCreateWithoutMonsterKillsInput>, Enumerable<PlayerUncheckedCreateWithoutMonsterKillsInput>>
    connectOrCreate?: Enumerable<PlayerCreateOrConnectWithoutMonsterKillsInput>
    connect?: Enumerable<PlayerWhereUniqueInput>
  }

  export type PlayerUncheckedCreateNestedManyWithoutMonsterKillsInput = {
    create?: XOR<Enumerable<PlayerCreateWithoutMonsterKillsInput>, Enumerable<PlayerUncheckedCreateWithoutMonsterKillsInput>>
    connectOrCreate?: Enumerable<PlayerCreateOrConnectWithoutMonsterKillsInput>
    connect?: Enumerable<PlayerWhereUniqueInput>
  }

  export type PlayerUpdateManyWithoutMonsterKillsInput = {
    create?: XOR<Enumerable<PlayerCreateWithoutMonsterKillsInput>, Enumerable<PlayerUncheckedCreateWithoutMonsterKillsInput>>
    connectOrCreate?: Enumerable<PlayerCreateOrConnectWithoutMonsterKillsInput>
    upsert?: Enumerable<PlayerUpsertWithWhereUniqueWithoutMonsterKillsInput>
    set?: Enumerable<PlayerWhereUniqueInput>
    disconnect?: Enumerable<PlayerWhereUniqueInput>
    delete?: Enumerable<PlayerWhereUniqueInput>
    connect?: Enumerable<PlayerWhereUniqueInput>
    update?: Enumerable<PlayerUpdateWithWhereUniqueWithoutMonsterKillsInput>
    updateMany?: Enumerable<PlayerUpdateManyWithWhereWithoutMonsterKillsInput>
    deleteMany?: Enumerable<PlayerScalarWhereInput>
  }

  export type PlayerUncheckedUpdateManyWithoutMonsterKillsInput = {
    create?: XOR<Enumerable<PlayerCreateWithoutMonsterKillsInput>, Enumerable<PlayerUncheckedCreateWithoutMonsterKillsInput>>
    connectOrCreate?: Enumerable<PlayerCreateOrConnectWithoutMonsterKillsInput>
    upsert?: Enumerable<PlayerUpsertWithWhereUniqueWithoutMonsterKillsInput>
    set?: Enumerable<PlayerWhereUniqueInput>
    disconnect?: Enumerable<PlayerWhereUniqueInput>
    delete?: Enumerable<PlayerWhereUniqueInput>
    connect?: Enumerable<PlayerWhereUniqueInput>
    update?: Enumerable<PlayerUpdateWithWhereUniqueWithoutMonsterKillsInput>
    updateMany?: Enumerable<PlayerUpdateManyWithWhereWithoutMonsterKillsInput>
    deleteMany?: Enumerable<PlayerScalarWhereInput>
  }

  export type RuneStyleCreateNestedOneWithoutSelectionInput = {
    create?: XOR<RuneStyleCreateWithoutSelectionInput, RuneStyleUncheckedCreateWithoutSelectionInput>
    connectOrCreate?: RuneStyleCreateOrConnectWithoutSelectionInput
    connect?: RuneStyleWhereUniqueInput
  }

  export type RuneStyleUpdateOneWithoutSelectionInput = {
    create?: XOR<RuneStyleCreateWithoutSelectionInput, RuneStyleUncheckedCreateWithoutSelectionInput>
    connectOrCreate?: RuneStyleCreateOrConnectWithoutSelectionInput
    upsert?: RuneStyleUpsertWithoutSelectionInput
    disconnect?: boolean
    delete?: boolean
    connect?: RuneStyleWhereUniqueInput
    update?: XOR<RuneStyleUpdateWithoutSelectionInput, RuneStyleUncheckedUpdateWithoutSelectionInput>
  }

  export type PlayerRuneCreateNestedOneWithoutRuneStyleInput = {
    create?: XOR<PlayerRuneCreateWithoutRuneStyleInput, PlayerRuneUncheckedCreateWithoutRuneStyleInput>
    connectOrCreate?: PlayerRuneCreateOrConnectWithoutRuneStyleInput
    connect?: PlayerRuneWhereUniqueInput
  }

  export type RuneSelectionCreateNestedManyWithoutRuneStyleInput = {
    create?: XOR<Enumerable<RuneSelectionCreateWithoutRuneStyleInput>, Enumerable<RuneSelectionUncheckedCreateWithoutRuneStyleInput>>
    connectOrCreate?: Enumerable<RuneSelectionCreateOrConnectWithoutRuneStyleInput>
    createMany?: RuneSelectionCreateManyRuneStyleInputEnvelope
    connect?: Enumerable<RuneSelectionWhereUniqueInput>
  }

  export type RuneSelectionUncheckedCreateNestedManyWithoutRuneStyleInput = {
    create?: XOR<Enumerable<RuneSelectionCreateWithoutRuneStyleInput>, Enumerable<RuneSelectionUncheckedCreateWithoutRuneStyleInput>>
    connectOrCreate?: Enumerable<RuneSelectionCreateOrConnectWithoutRuneStyleInput>
    createMany?: RuneSelectionCreateManyRuneStyleInputEnvelope
    connect?: Enumerable<RuneSelectionWhereUniqueInput>
  }

  export type PlayerRuneUpdateOneWithoutRuneStyleInput = {
    create?: XOR<PlayerRuneCreateWithoutRuneStyleInput, PlayerRuneUncheckedCreateWithoutRuneStyleInput>
    connectOrCreate?: PlayerRuneCreateOrConnectWithoutRuneStyleInput
    upsert?: PlayerRuneUpsertWithoutRuneStyleInput
    disconnect?: boolean
    delete?: boolean
    connect?: PlayerRuneWhereUniqueInput
    update?: XOR<PlayerRuneUpdateWithoutRuneStyleInput, PlayerRuneUncheckedUpdateWithoutRuneStyleInput>
  }

  export type RuneSelectionUpdateManyWithoutRuneStyleInput = {
    create?: XOR<Enumerable<RuneSelectionCreateWithoutRuneStyleInput>, Enumerable<RuneSelectionUncheckedCreateWithoutRuneStyleInput>>
    connectOrCreate?: Enumerable<RuneSelectionCreateOrConnectWithoutRuneStyleInput>
    upsert?: Enumerable<RuneSelectionUpsertWithWhereUniqueWithoutRuneStyleInput>
    createMany?: RuneSelectionCreateManyRuneStyleInputEnvelope
    set?: Enumerable<RuneSelectionWhereUniqueInput>
    disconnect?: Enumerable<RuneSelectionWhereUniqueInput>
    delete?: Enumerable<RuneSelectionWhereUniqueInput>
    connect?: Enumerable<RuneSelectionWhereUniqueInput>
    update?: Enumerable<RuneSelectionUpdateWithWhereUniqueWithoutRuneStyleInput>
    updateMany?: Enumerable<RuneSelectionUpdateManyWithWhereWithoutRuneStyleInput>
    deleteMany?: Enumerable<RuneSelectionScalarWhereInput>
  }

  export type RuneSelectionUncheckedUpdateManyWithoutRuneStyleInput = {
    create?: XOR<Enumerable<RuneSelectionCreateWithoutRuneStyleInput>, Enumerable<RuneSelectionUncheckedCreateWithoutRuneStyleInput>>
    connectOrCreate?: Enumerable<RuneSelectionCreateOrConnectWithoutRuneStyleInput>
    upsert?: Enumerable<RuneSelectionUpsertWithWhereUniqueWithoutRuneStyleInput>
    createMany?: RuneSelectionCreateManyRuneStyleInputEnvelope
    set?: Enumerable<RuneSelectionWhereUniqueInput>
    disconnect?: Enumerable<RuneSelectionWhereUniqueInput>
    delete?: Enumerable<RuneSelectionWhereUniqueInput>
    connect?: Enumerable<RuneSelectionWhereUniqueInput>
    update?: Enumerable<RuneSelectionUpdateWithWhereUniqueWithoutRuneStyleInput>
    updateMany?: Enumerable<RuneSelectionUpdateManyWithWhereWithoutRuneStyleInput>
    deleteMany?: Enumerable<RuneSelectionScalarWhereInput>
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedIntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type NestedFloatNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedFloatNullableFilter
    _min?: NestedFloatNullableFilter
    _max?: NestedFloatNullableFilter
  }

  export type NestedEnumPlayerWardEventWardTypeTypeNullableFilter = {
    equals?: PlayerWardEventWardTypeType | null
    in?: Enumerable<PlayerWardEventWardTypeType> | null
    notIn?: Enumerable<PlayerWardEventWardTypeType> | null
    not?: NestedEnumPlayerWardEventWardTypeTypeNullableFilter | PlayerWardEventWardTypeType | null
  }

  export type NestedEnumPlayerWardEventWardTypeTypeNullableWithAggregatesFilter = {
    equals?: PlayerWardEventWardTypeType | null
    in?: Enumerable<PlayerWardEventWardTypeType> | null
    notIn?: Enumerable<PlayerWardEventWardTypeType> | null
    not?: NestedEnumPlayerWardEventWardTypeTypeNullableWithAggregatesFilter | PlayerWardEventWardTypeType | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumPlayerWardEventWardTypeTypeNullableFilter
    _max?: NestedEnumPlayerWardEventWardTypeTypeNullableFilter
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type ProfileCreateWithoutActivityInput = {
    id?: string
    update?: boolean
    player?: PlayerCreateNestedOneWithoutProfileInput
    lastUpdate?: Date | string
    kills?: number | null
    deaths?: number | null
    assists?: number | null
    kda?: string
    winRate?: string
    csPerMinute?: string
    damagePerMinute?: string
    killsPerMinute?: string
    goldPerMinute?: string
    averageGameTime?: string
    averageTimeSpentDead?: string
    totalGameTime?: string
    championWinrate?: ChampionWinrateCreateNestedManyWithoutProfileInput
    duos?: DuoCreateNestedManyWithoutProfileInput
  }

  export type ProfileUncheckedCreateWithoutActivityInput = {
    id?: string
    update?: boolean
    player?: PlayerUncheckedCreateNestedOneWithoutProfileInput
    lastUpdate?: Date | string
    kills?: number | null
    deaths?: number | null
    assists?: number | null
    kda?: string
    winRate?: string
    csPerMinute?: string
    damagePerMinute?: string
    killsPerMinute?: string
    goldPerMinute?: string
    averageGameTime?: string
    averageTimeSpentDead?: string
    totalGameTime?: string
    championWinrate?: ChampionWinrateUncheckedCreateNestedManyWithoutProfileInput
    duos?: DuoUncheckedCreateNestedManyWithoutProfileInput
  }

  export type ProfileCreateOrConnectWithoutActivityInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutActivityInput, ProfileUncheckedCreateWithoutActivityInput>
  }

  export type ProfileUpsertWithoutActivityInput = {
    update: XOR<ProfileUpdateWithoutActivityInput, ProfileUncheckedUpdateWithoutActivityInput>
    create: XOR<ProfileCreateWithoutActivityInput, ProfileUncheckedCreateWithoutActivityInput>
  }

  export type ProfileUpdateWithoutActivityInput = {
    id?: StringFieldUpdateOperationsInput | string
    update?: BoolFieldUpdateOperationsInput | boolean
    player?: PlayerUpdateOneWithoutProfileInput
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    kills?: NullableIntFieldUpdateOperationsInput | number | null
    deaths?: NullableIntFieldUpdateOperationsInput | number | null
    assists?: NullableIntFieldUpdateOperationsInput | number | null
    kda?: StringFieldUpdateOperationsInput | string
    winRate?: StringFieldUpdateOperationsInput | string
    csPerMinute?: StringFieldUpdateOperationsInput | string
    damagePerMinute?: StringFieldUpdateOperationsInput | string
    killsPerMinute?: StringFieldUpdateOperationsInput | string
    goldPerMinute?: StringFieldUpdateOperationsInput | string
    averageGameTime?: StringFieldUpdateOperationsInput | string
    averageTimeSpentDead?: StringFieldUpdateOperationsInput | string
    totalGameTime?: StringFieldUpdateOperationsInput | string
    championWinrate?: ChampionWinrateUpdateManyWithoutProfileInput
    duos?: DuoUpdateManyWithoutProfileInput
  }

  export type ProfileUncheckedUpdateWithoutActivityInput = {
    id?: StringFieldUpdateOperationsInput | string
    update?: BoolFieldUpdateOperationsInput | boolean
    player?: PlayerUncheckedUpdateOneWithoutProfileInput
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    kills?: NullableIntFieldUpdateOperationsInput | number | null
    deaths?: NullableIntFieldUpdateOperationsInput | number | null
    assists?: NullableIntFieldUpdateOperationsInput | number | null
    kda?: StringFieldUpdateOperationsInput | string
    winRate?: StringFieldUpdateOperationsInput | string
    csPerMinute?: StringFieldUpdateOperationsInput | string
    damagePerMinute?: StringFieldUpdateOperationsInput | string
    killsPerMinute?: StringFieldUpdateOperationsInput | string
    goldPerMinute?: StringFieldUpdateOperationsInput | string
    averageGameTime?: StringFieldUpdateOperationsInput | string
    averageTimeSpentDead?: StringFieldUpdateOperationsInput | string
    totalGameTime?: StringFieldUpdateOperationsInput | string
    championWinrate?: ChampionWinrateUncheckedUpdateManyWithoutProfileInput
    duos?: DuoUncheckedUpdateManyWithoutProfileInput
  }

  export type ProfileCreateWithoutChampionWinrateInput = {
    id?: string
    update?: boolean
    player?: PlayerCreateNestedOneWithoutProfileInput
    lastUpdate?: Date | string
    kills?: number | null
    deaths?: number | null
    assists?: number | null
    kda?: string
    winRate?: string
    csPerMinute?: string
    damagePerMinute?: string
    killsPerMinute?: string
    goldPerMinute?: string
    averageGameTime?: string
    averageTimeSpentDead?: string
    totalGameTime?: string
    activity?: ActivityCreateNestedManyWithoutProfileInput
    duos?: DuoCreateNestedManyWithoutProfileInput
  }

  export type ProfileUncheckedCreateWithoutChampionWinrateInput = {
    id?: string
    update?: boolean
    player?: PlayerUncheckedCreateNestedOneWithoutProfileInput
    lastUpdate?: Date | string
    kills?: number | null
    deaths?: number | null
    assists?: number | null
    kda?: string
    winRate?: string
    csPerMinute?: string
    damagePerMinute?: string
    killsPerMinute?: string
    goldPerMinute?: string
    averageGameTime?: string
    averageTimeSpentDead?: string
    totalGameTime?: string
    activity?: ActivityUncheckedCreateNestedManyWithoutProfileInput
    duos?: DuoUncheckedCreateNestedManyWithoutProfileInput
  }

  export type ProfileCreateOrConnectWithoutChampionWinrateInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutChampionWinrateInput, ProfileUncheckedCreateWithoutChampionWinrateInput>
  }

  export type ProfileUpsertWithoutChampionWinrateInput = {
    update: XOR<ProfileUpdateWithoutChampionWinrateInput, ProfileUncheckedUpdateWithoutChampionWinrateInput>
    create: XOR<ProfileCreateWithoutChampionWinrateInput, ProfileUncheckedCreateWithoutChampionWinrateInput>
  }

  export type ProfileUpdateWithoutChampionWinrateInput = {
    id?: StringFieldUpdateOperationsInput | string
    update?: BoolFieldUpdateOperationsInput | boolean
    player?: PlayerUpdateOneWithoutProfileInput
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    kills?: NullableIntFieldUpdateOperationsInput | number | null
    deaths?: NullableIntFieldUpdateOperationsInput | number | null
    assists?: NullableIntFieldUpdateOperationsInput | number | null
    kda?: StringFieldUpdateOperationsInput | string
    winRate?: StringFieldUpdateOperationsInput | string
    csPerMinute?: StringFieldUpdateOperationsInput | string
    damagePerMinute?: StringFieldUpdateOperationsInput | string
    killsPerMinute?: StringFieldUpdateOperationsInput | string
    goldPerMinute?: StringFieldUpdateOperationsInput | string
    averageGameTime?: StringFieldUpdateOperationsInput | string
    averageTimeSpentDead?: StringFieldUpdateOperationsInput | string
    totalGameTime?: StringFieldUpdateOperationsInput | string
    activity?: ActivityUpdateManyWithoutProfileInput
    duos?: DuoUpdateManyWithoutProfileInput
  }

  export type ProfileUncheckedUpdateWithoutChampionWinrateInput = {
    id?: StringFieldUpdateOperationsInput | string
    update?: BoolFieldUpdateOperationsInput | boolean
    player?: PlayerUncheckedUpdateOneWithoutProfileInput
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    kills?: NullableIntFieldUpdateOperationsInput | number | null
    deaths?: NullableIntFieldUpdateOperationsInput | number | null
    assists?: NullableIntFieldUpdateOperationsInput | number | null
    kda?: StringFieldUpdateOperationsInput | string
    winRate?: StringFieldUpdateOperationsInput | string
    csPerMinute?: StringFieldUpdateOperationsInput | string
    damagePerMinute?: StringFieldUpdateOperationsInput | string
    killsPerMinute?: StringFieldUpdateOperationsInput | string
    goldPerMinute?: StringFieldUpdateOperationsInput | string
    averageGameTime?: StringFieldUpdateOperationsInput | string
    averageTimeSpentDead?: StringFieldUpdateOperationsInput | string
    totalGameTime?: StringFieldUpdateOperationsInput | string
    activity?: ActivityUncheckedUpdateManyWithoutProfileInput
    duos?: DuoUncheckedUpdateManyWithoutProfileInput
  }

  export type ProfileCreateWithoutDuosInput = {
    id?: string
    update?: boolean
    player?: PlayerCreateNestedOneWithoutProfileInput
    lastUpdate?: Date | string
    kills?: number | null
    deaths?: number | null
    assists?: number | null
    kda?: string
    winRate?: string
    csPerMinute?: string
    damagePerMinute?: string
    killsPerMinute?: string
    goldPerMinute?: string
    averageGameTime?: string
    averageTimeSpentDead?: string
    totalGameTime?: string
    activity?: ActivityCreateNestedManyWithoutProfileInput
    championWinrate?: ChampionWinrateCreateNestedManyWithoutProfileInput
  }

  export type ProfileUncheckedCreateWithoutDuosInput = {
    id?: string
    update?: boolean
    player?: PlayerUncheckedCreateNestedOneWithoutProfileInput
    lastUpdate?: Date | string
    kills?: number | null
    deaths?: number | null
    assists?: number | null
    kda?: string
    winRate?: string
    csPerMinute?: string
    damagePerMinute?: string
    killsPerMinute?: string
    goldPerMinute?: string
    averageGameTime?: string
    averageTimeSpentDead?: string
    totalGameTime?: string
    activity?: ActivityUncheckedCreateNestedManyWithoutProfileInput
    championWinrate?: ChampionWinrateUncheckedCreateNestedManyWithoutProfileInput
  }

  export type ProfileCreateOrConnectWithoutDuosInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutDuosInput, ProfileUncheckedCreateWithoutDuosInput>
  }

  export type ProfileUpsertWithoutDuosInput = {
    update: XOR<ProfileUpdateWithoutDuosInput, ProfileUncheckedUpdateWithoutDuosInput>
    create: XOR<ProfileCreateWithoutDuosInput, ProfileUncheckedCreateWithoutDuosInput>
  }

  export type ProfileUpdateWithoutDuosInput = {
    id?: StringFieldUpdateOperationsInput | string
    update?: BoolFieldUpdateOperationsInput | boolean
    player?: PlayerUpdateOneWithoutProfileInput
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    kills?: NullableIntFieldUpdateOperationsInput | number | null
    deaths?: NullableIntFieldUpdateOperationsInput | number | null
    assists?: NullableIntFieldUpdateOperationsInput | number | null
    kda?: StringFieldUpdateOperationsInput | string
    winRate?: StringFieldUpdateOperationsInput | string
    csPerMinute?: StringFieldUpdateOperationsInput | string
    damagePerMinute?: StringFieldUpdateOperationsInput | string
    killsPerMinute?: StringFieldUpdateOperationsInput | string
    goldPerMinute?: StringFieldUpdateOperationsInput | string
    averageGameTime?: StringFieldUpdateOperationsInput | string
    averageTimeSpentDead?: StringFieldUpdateOperationsInput | string
    totalGameTime?: StringFieldUpdateOperationsInput | string
    activity?: ActivityUpdateManyWithoutProfileInput
    championWinrate?: ChampionWinrateUpdateManyWithoutProfileInput
  }

  export type ProfileUncheckedUpdateWithoutDuosInput = {
    id?: StringFieldUpdateOperationsInput | string
    update?: BoolFieldUpdateOperationsInput | boolean
    player?: PlayerUncheckedUpdateOneWithoutProfileInput
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    kills?: NullableIntFieldUpdateOperationsInput | number | null
    deaths?: NullableIntFieldUpdateOperationsInput | number | null
    assists?: NullableIntFieldUpdateOperationsInput | number | null
    kda?: StringFieldUpdateOperationsInput | string
    winRate?: StringFieldUpdateOperationsInput | string
    csPerMinute?: StringFieldUpdateOperationsInput | string
    damagePerMinute?: StringFieldUpdateOperationsInput | string
    killsPerMinute?: StringFieldUpdateOperationsInput | string
    goldPerMinute?: StringFieldUpdateOperationsInput | string
    averageGameTime?: StringFieldUpdateOperationsInput | string
    averageTimeSpentDead?: StringFieldUpdateOperationsInput | string
    totalGameTime?: StringFieldUpdateOperationsInput | string
    activity?: ActivityUncheckedUpdateManyWithoutProfileInput
    championWinrate?: ChampionWinrateUncheckedUpdateManyWithoutProfileInput
  }

  export type PositionCreateWithoutEventInput = {
    id?: string
    x?: number | null
    y?: number | null
    playerSnapshot?: PlayerSnapshotCreateNestedManyWithoutPositionInput
  }

  export type PositionUncheckedCreateWithoutEventInput = {
    id?: string
    x?: number | null
    y?: number | null
    playerSnapshot?: PlayerSnapshotUncheckedCreateNestedManyWithoutPositionInput
  }

  export type PositionCreateOrConnectWithoutEventInput = {
    where: PositionWhereUniqueInput
    create: XOR<PositionCreateWithoutEventInput, PositionUncheckedCreateWithoutEventInput>
  }

  export type PositionUpsertWithWhereUniqueWithoutEventInput = {
    where: PositionWhereUniqueInput
    update: XOR<PositionUpdateWithoutEventInput, PositionUncheckedUpdateWithoutEventInput>
    create: XOR<PositionCreateWithoutEventInput, PositionUncheckedCreateWithoutEventInput>
  }

  export type PositionUpdateWithWhereUniqueWithoutEventInput = {
    where: PositionWhereUniqueInput
    data: XOR<PositionUpdateWithoutEventInput, PositionUncheckedUpdateWithoutEventInput>
  }

  export type PositionUpdateManyWithWhereWithoutEventInput = {
    where: PositionScalarWhereInput
    data: XOR<PositionUpdateManyMutationInput, PositionUncheckedUpdateManyWithoutPositionInput>
  }

  export type PositionScalarWhereInput = {
    AND?: Enumerable<PositionScalarWhereInput>
    OR?: Enumerable<PositionScalarWhereInput>
    NOT?: Enumerable<PositionScalarWhereInput>
    id?: StringFilter | string
    x?: IntNullableFilter | number | null
    y?: IntNullableFilter | number | null
  }

  export type TeamCreateWithoutFrom_Game_blueTeamInput = {
    id?: string
    pickBan?: PickBanCreateNestedManyWithoutTeamInput
    game?: GameCreateNestedOneWithoutFrom_Team_gameInput
    players?: PlayerCreateNestedManyWithoutTeamsInput
    objectives?: ObjectiveCreateNestedManyWithoutTeamInput
    teamId?: number | null
    teamMatchId?: string
    win?: boolean
    from_Game_redTeam?: GameCreateNestedManyWithoutRedTeamInput
  }

  export type TeamUncheckedCreateWithoutFrom_Game_blueTeamInput = {
    id?: string
    pickBan?: PickBanUncheckedCreateNestedManyWithoutTeamInput
    gameId?: string | null
    players?: PlayerUncheckedCreateNestedManyWithoutTeamsInput
    objectives?: ObjectiveUncheckedCreateNestedManyWithoutTeamInput
    teamId?: number | null
    teamMatchId?: string
    win?: boolean
    from_Game_redTeam?: GameUncheckedCreateNestedManyWithoutRedTeamInput
  }

  export type TeamCreateOrConnectWithoutFrom_Game_blueTeamInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutFrom_Game_blueTeamInput, TeamUncheckedCreateWithoutFrom_Game_blueTeamInput>
  }

  export type TeamCreateWithoutFrom_Game_redTeamInput = {
    id?: string
    pickBan?: PickBanCreateNestedManyWithoutTeamInput
    game?: GameCreateNestedOneWithoutFrom_Team_gameInput
    players?: PlayerCreateNestedManyWithoutTeamsInput
    objectives?: ObjectiveCreateNestedManyWithoutTeamInput
    teamId?: number | null
    teamMatchId?: string
    win?: boolean
    from_Game_blueTeam?: GameCreateNestedManyWithoutBlueTeamInput
  }

  export type TeamUncheckedCreateWithoutFrom_Game_redTeamInput = {
    id?: string
    pickBan?: PickBanUncheckedCreateNestedManyWithoutTeamInput
    gameId?: string | null
    players?: PlayerUncheckedCreateNestedManyWithoutTeamsInput
    objectives?: ObjectiveUncheckedCreateNestedManyWithoutTeamInput
    teamId?: number | null
    teamMatchId?: string
    win?: boolean
    from_Game_blueTeam?: GameUncheckedCreateNestedManyWithoutBlueTeamInput
  }

  export type TeamCreateOrConnectWithoutFrom_Game_redTeamInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutFrom_Game_redTeamInput, TeamUncheckedCreateWithoutFrom_Game_redTeamInput>
  }

  export type SourceCreateWithoutGameInput = {
    id?: string
    api?: string
  }

  export type SourceUncheckedCreateWithoutGameInput = {
    id?: string
    api?: string
  }

  export type SourceCreateOrConnectWithoutGameInput = {
    where: SourceWhereUniqueInput
    create: XOR<SourceCreateWithoutGameInput, SourceUncheckedCreateWithoutGameInput>
  }

  export type PlayerEndOfGameStatCreateWithoutGameInput = {
    id?: string
    player?: PlayerCreateNestedOneWithoutEndOfGameStatsInput
    perks?: PlayerRuneCreateNestedOneWithoutPlayerEndOfGameStatInput
    items?: PlayerItemCreateNestedOneWithoutPlayerEndOfGameStatInput
    assists?: number | null
    baronKills?: number | null
    bountyLevel?: number | null
    championExperience?: number | null
    championLevel?: number | null
    championId?: number | null
    championName?: string
    championTransform?: number | null
    consumablesPurchased?: number | null
    damageDealtToBuildings?: number | null
    damageDealtToObjectives?: number | null
    damageDealtToTurrets?: number | null
    damageSelfMitigated?: number | null
    deaths?: number | null
    detectorWardsPlaced?: number | null
    doubleKills?: number | null
    dragonKills?: number | null
    firstBlood?: boolean
    firstBloodAssist?: boolean
    firstTowerKill?: boolean
    firstTowerAssist?: boolean
    gameEndedInEarlySurrender?: boolean
    gameEndedInSurrender?: boolean
    goldEarned?: number | null
    goldSpent?: number | null
    individualPosition?: string
    inhibitorKills?: number | null
    inhibitorTakedowns?: number | null
    inhibitorsLost?: number | null
    item0?: number | null
    item1?: number | null
    item2?: number | null
    item3?: number | null
    item4?: number | null
    item5?: number | null
    item6?: number | null
    itemsPurchased?: number | null
    killingSprees?: number | null
    kills?: number | null
    lane?: string
    largestCriticalStrike?: number | null
    largestKillingSpree?: number | null
    largestMultiKill?: number | null
    longestTimeSpentLiving?: number | null
    magicDamageDealt?: number | null
    magicDamageDealtToChampions?: number | null
    magicDamageTaken?: number | null
    neutralMinionsKilled?: number | null
    nexusKills?: number | null
    nexusLost?: number | null
    nexusTakedowns?: number | null
    objectivesStolen?: number | null
    objectivesStolenAssists?: number | null
    participantId?: number | null
    pentaKills?: number | null
    physicalDamageDealt?: number | null
    physicalDamageDealtToChampions?: number | null
    physicalDamageTaken?: number | null
    quadraKills?: number | null
    riotIdName?: string
    riotIdTagline?: string
    role?: string
    sightWardsBoughtInGame?: number | null
    spell1Casts?: number | null
    spell2Casts?: number | null
    spell3Casts?: number | null
    spell4Casts?: number | null
    summoner1Casts?: number | null
    summoner1Id?: number | null
    summoner2Casts?: number | null
    summoner2Id?: number | null
    summonerLevel?: number | null
    summonerName?: string
    teamEarlySurrendered?: boolean
    teamId?: number | null
    teamPosition?: string
    timeCCingOthers?: number | null
    timePlayed?: number | null
    totalDamageDealt?: number | null
    totalDamageDealtToChampions?: number | null
    totalDamageShieldedOnTeammates?: number | null
    totalDamageTaken?: number | null
    totalHeal?: number | null
    totalHealsOnTeammates?: number | null
    totalMinionsKilled?: number | null
    totalTimeCCDealt?: number | null
    totalTimeSpentDead?: number | null
    totalUnitsHealed?: number | null
    tripleKills?: number | null
    trueDamageDealt?: number | null
    trueDamageDealtToChampions?: number | null
    trueDamageTaken?: number | null
    turretsKilled?: number | null
    turretTakedowns?: number | null
    turretsLost?: number | null
    unrealKills?: number | null
    visionScore?: number | null
    visionWardsBoughtInGame?: number | null
    wardsKilled?: number | null
    wardsPlaced?: number | null
    win?: boolean
  }

  export type PlayerEndOfGameStatUncheckedCreateWithoutGameInput = {
    id?: string
    playerId?: string | null
    perksId?: string | null
    itemsId?: string | null
    assists?: number | null
    baronKills?: number | null
    bountyLevel?: number | null
    championExperience?: number | null
    championLevel?: number | null
    championId?: number | null
    championName?: string
    championTransform?: number | null
    consumablesPurchased?: number | null
    damageDealtToBuildings?: number | null
    damageDealtToObjectives?: number | null
    damageDealtToTurrets?: number | null
    damageSelfMitigated?: number | null
    deaths?: number | null
    detectorWardsPlaced?: number | null
    doubleKills?: number | null
    dragonKills?: number | null
    firstBlood?: boolean
    firstBloodAssist?: boolean
    firstTowerKill?: boolean
    firstTowerAssist?: boolean
    gameEndedInEarlySurrender?: boolean
    gameEndedInSurrender?: boolean
    goldEarned?: number | null
    goldSpent?: number | null
    individualPosition?: string
    inhibitorKills?: number | null
    inhibitorTakedowns?: number | null
    inhibitorsLost?: number | null
    item0?: number | null
    item1?: number | null
    item2?: number | null
    item3?: number | null
    item4?: number | null
    item5?: number | null
    item6?: number | null
    itemsPurchased?: number | null
    killingSprees?: number | null
    kills?: number | null
    lane?: string
    largestCriticalStrike?: number | null
    largestKillingSpree?: number | null
    largestMultiKill?: number | null
    longestTimeSpentLiving?: number | null
    magicDamageDealt?: number | null
    magicDamageDealtToChampions?: number | null
    magicDamageTaken?: number | null
    neutralMinionsKilled?: number | null
    nexusKills?: number | null
    nexusLost?: number | null
    nexusTakedowns?: number | null
    objectivesStolen?: number | null
    objectivesStolenAssists?: number | null
    participantId?: number | null
    pentaKills?: number | null
    physicalDamageDealt?: number | null
    physicalDamageDealtToChampions?: number | null
    physicalDamageTaken?: number | null
    quadraKills?: number | null
    riotIdName?: string
    riotIdTagline?: string
    role?: string
    sightWardsBoughtInGame?: number | null
    spell1Casts?: number | null
    spell2Casts?: number | null
    spell3Casts?: number | null
    spell4Casts?: number | null
    summoner1Casts?: number | null
    summoner1Id?: number | null
    summoner2Casts?: number | null
    summoner2Id?: number | null
    summonerLevel?: number | null
    summonerName?: string
    teamEarlySurrendered?: boolean
    teamId?: number | null
    teamPosition?: string
    timeCCingOthers?: number | null
    timePlayed?: number | null
    totalDamageDealt?: number | null
    totalDamageDealtToChampions?: number | null
    totalDamageShieldedOnTeammates?: number | null
    totalDamageTaken?: number | null
    totalHeal?: number | null
    totalHealsOnTeammates?: number | null
    totalMinionsKilled?: number | null
    totalTimeCCDealt?: number | null
    totalTimeSpentDead?: number | null
    totalUnitsHealed?: number | null
    tripleKills?: number | null
    trueDamageDealt?: number | null
    trueDamageDealtToChampions?: number | null
    trueDamageTaken?: number | null
    turretsKilled?: number | null
    turretTakedowns?: number | null
    turretsLost?: number | null
    unrealKills?: number | null
    visionScore?: number | null
    visionWardsBoughtInGame?: number | null
    wardsKilled?: number | null
    wardsPlaced?: number | null
    win?: boolean
  }

  export type PlayerEndOfGameStatCreateOrConnectWithoutGameInput = {
    where: PlayerEndOfGameStatWhereUniqueInput
    create: XOR<PlayerEndOfGameStatCreateWithoutGameInput, PlayerEndOfGameStatUncheckedCreateWithoutGameInput>
  }

  export type PlayerEndOfGameStatCreateManyGameInputEnvelope = {
    data: Enumerable<PlayerEndOfGameStatCreateManyGameInput>
    skipDuplicates?: boolean
  }

  export type TeamCreateWithoutGameInput = {
    id?: string
    pickBan?: PickBanCreateNestedManyWithoutTeamInput
    players?: PlayerCreateNestedManyWithoutTeamsInput
    objectives?: ObjectiveCreateNestedManyWithoutTeamInput
    teamId?: number | null
    teamMatchId?: string
    win?: boolean
    from_Game_blueTeam?: GameCreateNestedManyWithoutBlueTeamInput
    from_Game_redTeam?: GameCreateNestedManyWithoutRedTeamInput
  }

  export type TeamUncheckedCreateWithoutGameInput = {
    id?: string
    pickBan?: PickBanUncheckedCreateNestedManyWithoutTeamInput
    players?: PlayerUncheckedCreateNestedManyWithoutTeamsInput
    objectives?: ObjectiveUncheckedCreateNestedManyWithoutTeamInput
    teamId?: number | null
    teamMatchId?: string
    win?: boolean
    from_Game_blueTeam?: GameUncheckedCreateNestedManyWithoutBlueTeamInput
    from_Game_redTeam?: GameUncheckedCreateNestedManyWithoutRedTeamInput
  }

  export type TeamCreateOrConnectWithoutGameInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutGameInput, TeamUncheckedCreateWithoutGameInput>
  }

  export type TeamCreateManyGameInputEnvelope = {
    data: Enumerable<TeamCreateManyGameInput>
    skipDuplicates?: boolean
  }

  export type TeamUpsertWithoutFrom_Game_blueTeamInput = {
    update: XOR<TeamUpdateWithoutFrom_Game_blueTeamInput, TeamUncheckedUpdateWithoutFrom_Game_blueTeamInput>
    create: XOR<TeamCreateWithoutFrom_Game_blueTeamInput, TeamUncheckedCreateWithoutFrom_Game_blueTeamInput>
  }

  export type TeamUpdateWithoutFrom_Game_blueTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    pickBan?: PickBanUpdateManyWithoutTeamInput
    game?: GameUpdateOneWithoutFrom_Team_gameInput
    players?: PlayerUpdateManyWithoutTeamsInput
    objectives?: ObjectiveUpdateManyWithoutTeamInput
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    teamMatchId?: StringFieldUpdateOperationsInput | string
    win?: BoolFieldUpdateOperationsInput | boolean
    from_Game_redTeam?: GameUpdateManyWithoutRedTeamInput
  }

  export type TeamUncheckedUpdateWithoutFrom_Game_blueTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    pickBan?: PickBanUncheckedUpdateManyWithoutTeamInput
    gameId?: NullableStringFieldUpdateOperationsInput | string | null
    players?: PlayerUncheckedUpdateManyWithoutTeamsInput
    objectives?: ObjectiveUncheckedUpdateManyWithoutTeamInput
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    teamMatchId?: StringFieldUpdateOperationsInput | string
    win?: BoolFieldUpdateOperationsInput | boolean
    from_Game_redTeam?: GameUncheckedUpdateManyWithoutRedTeamInput
  }

  export type TeamUpsertWithoutFrom_Game_redTeamInput = {
    update: XOR<TeamUpdateWithoutFrom_Game_redTeamInput, TeamUncheckedUpdateWithoutFrom_Game_redTeamInput>
    create: XOR<TeamCreateWithoutFrom_Game_redTeamInput, TeamUncheckedCreateWithoutFrom_Game_redTeamInput>
  }

  export type TeamUpdateWithoutFrom_Game_redTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    pickBan?: PickBanUpdateManyWithoutTeamInput
    game?: GameUpdateOneWithoutFrom_Team_gameInput
    players?: PlayerUpdateManyWithoutTeamsInput
    objectives?: ObjectiveUpdateManyWithoutTeamInput
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    teamMatchId?: StringFieldUpdateOperationsInput | string
    win?: BoolFieldUpdateOperationsInput | boolean
    from_Game_blueTeam?: GameUpdateManyWithoutBlueTeamInput
  }

  export type TeamUncheckedUpdateWithoutFrom_Game_redTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    pickBan?: PickBanUncheckedUpdateManyWithoutTeamInput
    gameId?: NullableStringFieldUpdateOperationsInput | string | null
    players?: PlayerUncheckedUpdateManyWithoutTeamsInput
    objectives?: ObjectiveUncheckedUpdateManyWithoutTeamInput
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    teamMatchId?: StringFieldUpdateOperationsInput | string
    win?: BoolFieldUpdateOperationsInput | boolean
    from_Game_blueTeam?: GameUncheckedUpdateManyWithoutBlueTeamInput
  }

  export type SourceUpsertWithWhereUniqueWithoutGameInput = {
    where: SourceWhereUniqueInput
    update: XOR<SourceUpdateWithoutGameInput, SourceUncheckedUpdateWithoutGameInput>
    create: XOR<SourceCreateWithoutGameInput, SourceUncheckedCreateWithoutGameInput>
  }

  export type SourceUpdateWithWhereUniqueWithoutGameInput = {
    where: SourceWhereUniqueInput
    data: XOR<SourceUpdateWithoutGameInput, SourceUncheckedUpdateWithoutGameInput>
  }

  export type SourceUpdateManyWithWhereWithoutGameInput = {
    where: SourceScalarWhereInput
    data: XOR<SourceUpdateManyMutationInput, SourceUncheckedUpdateManyWithoutSourceInput>
  }

  export type SourceScalarWhereInput = {
    AND?: Enumerable<SourceScalarWhereInput>
    OR?: Enumerable<SourceScalarWhereInput>
    NOT?: Enumerable<SourceScalarWhereInput>
    id?: StringFilter | string
    api?: StringFilter | string
  }

  export type PlayerEndOfGameStatUpsertWithWhereUniqueWithoutGameInput = {
    where: PlayerEndOfGameStatWhereUniqueInput
    update: XOR<PlayerEndOfGameStatUpdateWithoutGameInput, PlayerEndOfGameStatUncheckedUpdateWithoutGameInput>
    create: XOR<PlayerEndOfGameStatCreateWithoutGameInput, PlayerEndOfGameStatUncheckedCreateWithoutGameInput>
  }

  export type PlayerEndOfGameStatUpdateWithWhereUniqueWithoutGameInput = {
    where: PlayerEndOfGameStatWhereUniqueInput
    data: XOR<PlayerEndOfGameStatUpdateWithoutGameInput, PlayerEndOfGameStatUncheckedUpdateWithoutGameInput>
  }

  export type PlayerEndOfGameStatUpdateManyWithWhereWithoutGameInput = {
    where: PlayerEndOfGameStatScalarWhereInput
    data: XOR<PlayerEndOfGameStatUpdateManyMutationInput, PlayerEndOfGameStatUncheckedUpdateManyWithoutFrom_PlayerEndOfGameStat_gameInput>
  }

  export type PlayerEndOfGameStatScalarWhereInput = {
    AND?: Enumerable<PlayerEndOfGameStatScalarWhereInput>
    OR?: Enumerable<PlayerEndOfGameStatScalarWhereInput>
    NOT?: Enumerable<PlayerEndOfGameStatScalarWhereInput>
    id?: StringFilter | string
    playerId?: StringNullableFilter | string | null
    gameId?: StringNullableFilter | string | null
    perksId?: StringNullableFilter | string | null
    itemsId?: StringNullableFilter | string | null
    assists?: IntNullableFilter | number | null
    baronKills?: IntNullableFilter | number | null
    bountyLevel?: IntNullableFilter | number | null
    championExperience?: IntNullableFilter | number | null
    championLevel?: IntNullableFilter | number | null
    championId?: IntNullableFilter | number | null
    championName?: StringFilter | string
    championTransform?: IntNullableFilter | number | null
    consumablesPurchased?: IntNullableFilter | number | null
    damageDealtToBuildings?: IntNullableFilter | number | null
    damageDealtToObjectives?: IntNullableFilter | number | null
    damageDealtToTurrets?: IntNullableFilter | number | null
    damageSelfMitigated?: IntNullableFilter | number | null
    deaths?: IntNullableFilter | number | null
    detectorWardsPlaced?: IntNullableFilter | number | null
    doubleKills?: IntNullableFilter | number | null
    dragonKills?: IntNullableFilter | number | null
    firstBlood?: BoolFilter | boolean
    firstBloodAssist?: BoolFilter | boolean
    firstTowerKill?: BoolFilter | boolean
    firstTowerAssist?: BoolFilter | boolean
    gameEndedInEarlySurrender?: BoolFilter | boolean
    gameEndedInSurrender?: BoolFilter | boolean
    goldEarned?: IntNullableFilter | number | null
    goldSpent?: IntNullableFilter | number | null
    individualPosition?: StringFilter | string
    inhibitorKills?: IntNullableFilter | number | null
    inhibitorTakedowns?: IntNullableFilter | number | null
    inhibitorsLost?: IntNullableFilter | number | null
    item0?: IntNullableFilter | number | null
    item1?: IntNullableFilter | number | null
    item2?: IntNullableFilter | number | null
    item3?: IntNullableFilter | number | null
    item4?: IntNullableFilter | number | null
    item5?: IntNullableFilter | number | null
    item6?: IntNullableFilter | number | null
    itemsPurchased?: IntNullableFilter | number | null
    killingSprees?: IntNullableFilter | number | null
    kills?: IntNullableFilter | number | null
    lane?: StringFilter | string
    largestCriticalStrike?: IntNullableFilter | number | null
    largestKillingSpree?: IntNullableFilter | number | null
    largestMultiKill?: IntNullableFilter | number | null
    longestTimeSpentLiving?: IntNullableFilter | number | null
    magicDamageDealt?: IntNullableFilter | number | null
    magicDamageDealtToChampions?: IntNullableFilter | number | null
    magicDamageTaken?: IntNullableFilter | number | null
    neutralMinionsKilled?: IntNullableFilter | number | null
    nexusKills?: IntNullableFilter | number | null
    nexusLost?: IntNullableFilter | number | null
    nexusTakedowns?: IntNullableFilter | number | null
    objectivesStolen?: IntNullableFilter | number | null
    objectivesStolenAssists?: IntNullableFilter | number | null
    participantId?: IntNullableFilter | number | null
    pentaKills?: IntNullableFilter | number | null
    physicalDamageDealt?: IntNullableFilter | number | null
    physicalDamageDealtToChampions?: IntNullableFilter | number | null
    physicalDamageTaken?: IntNullableFilter | number | null
    quadraKills?: IntNullableFilter | number | null
    riotIdName?: StringFilter | string
    riotIdTagline?: StringFilter | string
    role?: StringFilter | string
    sightWardsBoughtInGame?: IntNullableFilter | number | null
    spell1Casts?: IntNullableFilter | number | null
    spell2Casts?: IntNullableFilter | number | null
    spell3Casts?: IntNullableFilter | number | null
    spell4Casts?: IntNullableFilter | number | null
    summoner1Casts?: IntNullableFilter | number | null
    summoner1Id?: IntNullableFilter | number | null
    summoner2Casts?: IntNullableFilter | number | null
    summoner2Id?: IntNullableFilter | number | null
    summonerLevel?: IntNullableFilter | number | null
    summonerName?: StringFilter | string
    teamEarlySurrendered?: BoolFilter | boolean
    teamId?: IntNullableFilter | number | null
    teamPosition?: StringFilter | string
    timeCCingOthers?: IntNullableFilter | number | null
    timePlayed?: IntNullableFilter | number | null
    totalDamageDealt?: IntNullableFilter | number | null
    totalDamageDealtToChampions?: IntNullableFilter | number | null
    totalDamageShieldedOnTeammates?: IntNullableFilter | number | null
    totalDamageTaken?: IntNullableFilter | number | null
    totalHeal?: IntNullableFilter | number | null
    totalHealsOnTeammates?: IntNullableFilter | number | null
    totalMinionsKilled?: IntNullableFilter | number | null
    totalTimeCCDealt?: IntNullableFilter | number | null
    totalTimeSpentDead?: IntNullableFilter | number | null
    totalUnitsHealed?: IntNullableFilter | number | null
    tripleKills?: IntNullableFilter | number | null
    trueDamageDealt?: IntNullableFilter | number | null
    trueDamageDealtToChampions?: IntNullableFilter | number | null
    trueDamageTaken?: IntNullableFilter | number | null
    turretsKilled?: IntNullableFilter | number | null
    turretTakedowns?: IntNullableFilter | number | null
    turretsLost?: IntNullableFilter | number | null
    unrealKills?: IntNullableFilter | number | null
    visionScore?: IntNullableFilter | number | null
    visionWardsBoughtInGame?: IntNullableFilter | number | null
    wardsKilled?: IntNullableFilter | number | null
    wardsPlaced?: IntNullableFilter | number | null
    win?: BoolFilter | boolean
  }

  export type TeamUpsertWithWhereUniqueWithoutGameInput = {
    where: TeamWhereUniqueInput
    update: XOR<TeamUpdateWithoutGameInput, TeamUncheckedUpdateWithoutGameInput>
    create: XOR<TeamCreateWithoutGameInput, TeamUncheckedCreateWithoutGameInput>
  }

  export type TeamUpdateWithWhereUniqueWithoutGameInput = {
    where: TeamWhereUniqueInput
    data: XOR<TeamUpdateWithoutGameInput, TeamUncheckedUpdateWithoutGameInput>
  }

  export type TeamUpdateManyWithWhereWithoutGameInput = {
    where: TeamScalarWhereInput
    data: XOR<TeamUpdateManyMutationInput, TeamUncheckedUpdateManyWithoutFrom_Team_gameInput>
  }

  export type TeamScalarWhereInput = {
    AND?: Enumerable<TeamScalarWhereInput>
    OR?: Enumerable<TeamScalarWhereInput>
    NOT?: Enumerable<TeamScalarWhereInput>
    id?: StringFilter | string
    gameId?: StringNullableFilter | string | null
    teamId?: IntNullableFilter | number | null
    teamMatchId?: StringFilter | string
    win?: BoolFilter | boolean
  }

  export type TeamCreateWithoutObjectivesInput = {
    id?: string
    pickBan?: PickBanCreateNestedManyWithoutTeamInput
    game?: GameCreateNestedOneWithoutFrom_Team_gameInput
    players?: PlayerCreateNestedManyWithoutTeamsInput
    teamId?: number | null
    teamMatchId?: string
    win?: boolean
    from_Game_blueTeam?: GameCreateNestedManyWithoutBlueTeamInput
    from_Game_redTeam?: GameCreateNestedManyWithoutRedTeamInput
  }

  export type TeamUncheckedCreateWithoutObjectivesInput = {
    id?: string
    pickBan?: PickBanUncheckedCreateNestedManyWithoutTeamInput
    gameId?: string | null
    players?: PlayerUncheckedCreateNestedManyWithoutTeamsInput
    teamId?: number | null
    teamMatchId?: string
    win?: boolean
    from_Game_blueTeam?: GameUncheckedCreateNestedManyWithoutBlueTeamInput
    from_Game_redTeam?: GameUncheckedCreateNestedManyWithoutRedTeamInput
  }

  export type TeamCreateOrConnectWithoutObjectivesInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutObjectivesInput, TeamUncheckedCreateWithoutObjectivesInput>
  }

  export type TeamUpsertWithoutObjectivesInput = {
    update: XOR<TeamUpdateWithoutObjectivesInput, TeamUncheckedUpdateWithoutObjectivesInput>
    create: XOR<TeamCreateWithoutObjectivesInput, TeamUncheckedCreateWithoutObjectivesInput>
  }

  export type TeamUpdateWithoutObjectivesInput = {
    id?: StringFieldUpdateOperationsInput | string
    pickBan?: PickBanUpdateManyWithoutTeamInput
    game?: GameUpdateOneWithoutFrom_Team_gameInput
    players?: PlayerUpdateManyWithoutTeamsInput
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    teamMatchId?: StringFieldUpdateOperationsInput | string
    win?: BoolFieldUpdateOperationsInput | boolean
    from_Game_blueTeam?: GameUpdateManyWithoutBlueTeamInput
    from_Game_redTeam?: GameUpdateManyWithoutRedTeamInput
  }

  export type TeamUncheckedUpdateWithoutObjectivesInput = {
    id?: StringFieldUpdateOperationsInput | string
    pickBan?: PickBanUncheckedUpdateManyWithoutTeamInput
    gameId?: NullableStringFieldUpdateOperationsInput | string | null
    players?: PlayerUncheckedUpdateManyWithoutTeamsInput
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    teamMatchId?: StringFieldUpdateOperationsInput | string
    win?: BoolFieldUpdateOperationsInput | boolean
    from_Game_blueTeam?: GameUncheckedUpdateManyWithoutBlueTeamInput
    from_Game_redTeam?: GameUncheckedUpdateManyWithoutRedTeamInput
  }

  export type TeamCreateWithoutPickBanInput = {
    id?: string
    game?: GameCreateNestedOneWithoutFrom_Team_gameInput
    players?: PlayerCreateNestedManyWithoutTeamsInput
    objectives?: ObjectiveCreateNestedManyWithoutTeamInput
    teamId?: number | null
    teamMatchId?: string
    win?: boolean
    from_Game_blueTeam?: GameCreateNestedManyWithoutBlueTeamInput
    from_Game_redTeam?: GameCreateNestedManyWithoutRedTeamInput
  }

  export type TeamUncheckedCreateWithoutPickBanInput = {
    id?: string
    gameId?: string | null
    players?: PlayerUncheckedCreateNestedManyWithoutTeamsInput
    objectives?: ObjectiveUncheckedCreateNestedManyWithoutTeamInput
    teamId?: number | null
    teamMatchId?: string
    win?: boolean
    from_Game_blueTeam?: GameUncheckedCreateNestedManyWithoutBlueTeamInput
    from_Game_redTeam?: GameUncheckedCreateNestedManyWithoutRedTeamInput
  }

  export type TeamCreateOrConnectWithoutPickBanInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutPickBanInput, TeamUncheckedCreateWithoutPickBanInput>
  }

  export type TeamUpsertWithoutPickBanInput = {
    update: XOR<TeamUpdateWithoutPickBanInput, TeamUncheckedUpdateWithoutPickBanInput>
    create: XOR<TeamCreateWithoutPickBanInput, TeamUncheckedCreateWithoutPickBanInput>
  }

  export type TeamUpdateWithoutPickBanInput = {
    id?: StringFieldUpdateOperationsInput | string
    game?: GameUpdateOneWithoutFrom_Team_gameInput
    players?: PlayerUpdateManyWithoutTeamsInput
    objectives?: ObjectiveUpdateManyWithoutTeamInput
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    teamMatchId?: StringFieldUpdateOperationsInput | string
    win?: BoolFieldUpdateOperationsInput | boolean
    from_Game_blueTeam?: GameUpdateManyWithoutBlueTeamInput
    from_Game_redTeam?: GameUpdateManyWithoutRedTeamInput
  }

  export type TeamUncheckedUpdateWithoutPickBanInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: NullableStringFieldUpdateOperationsInput | string | null
    players?: PlayerUncheckedUpdateManyWithoutTeamsInput
    objectives?: ObjectiveUncheckedUpdateManyWithoutTeamInput
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    teamMatchId?: StringFieldUpdateOperationsInput | string
    win?: BoolFieldUpdateOperationsInput | boolean
    from_Game_blueTeam?: GameUncheckedUpdateManyWithoutBlueTeamInput
    from_Game_redTeam?: GameUncheckedUpdateManyWithoutRedTeamInput
  }

  export type PlayerKillCreateWithoutKillerInput = {
    id?: string
    victim?: PlayerCreateNestedManyWithoutDeathsInput
  }

  export type PlayerKillUncheckedCreateWithoutKillerInput = {
    id?: string
    victim?: PlayerUncheckedCreateNestedManyWithoutDeathsInput
  }

  export type PlayerKillCreateOrConnectWithoutKillerInput = {
    where: PlayerKillWhereUniqueInput
    create: XOR<PlayerKillCreateWithoutKillerInput, PlayerKillUncheckedCreateWithoutKillerInput>
  }

  export type PlayerKillCreateWithoutVictimInput = {
    id?: string
    killer?: PlayerCreateNestedManyWithoutKillsInput
  }

  export type PlayerKillUncheckedCreateWithoutVictimInput = {
    id?: string
    killer?: PlayerUncheckedCreateNestedManyWithoutKillsInput
  }

  export type PlayerKillCreateOrConnectWithoutVictimInput = {
    where: PlayerKillWhereUniqueInput
    create: XOR<PlayerKillCreateWithoutVictimInput, PlayerKillUncheckedCreateWithoutVictimInput>
  }

  export type TeamCreateWithoutPlayersInput = {
    id?: string
    pickBan?: PickBanCreateNestedManyWithoutTeamInput
    game?: GameCreateNestedOneWithoutFrom_Team_gameInput
    objectives?: ObjectiveCreateNestedManyWithoutTeamInput
    teamId?: number | null
    teamMatchId?: string
    win?: boolean
    from_Game_blueTeam?: GameCreateNestedManyWithoutBlueTeamInput
    from_Game_redTeam?: GameCreateNestedManyWithoutRedTeamInput
  }

  export type TeamUncheckedCreateWithoutPlayersInput = {
    id?: string
    pickBan?: PickBanUncheckedCreateNestedManyWithoutTeamInput
    gameId?: string | null
    objectives?: ObjectiveUncheckedCreateNestedManyWithoutTeamInput
    teamId?: number | null
    teamMatchId?: string
    win?: boolean
    from_Game_blueTeam?: GameUncheckedCreateNestedManyWithoutBlueTeamInput
    from_Game_redTeam?: GameUncheckedCreateNestedManyWithoutRedTeamInput
  }

  export type TeamCreateOrConnectWithoutPlayersInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutPlayersInput, TeamUncheckedCreateWithoutPlayersInput>
  }

  export type ProfileCreateWithoutPlayerInput = {
    id?: string
    update?: boolean
    lastUpdate?: Date | string
    kills?: number | null
    deaths?: number | null
    assists?: number | null
    kda?: string
    winRate?: string
    csPerMinute?: string
    damagePerMinute?: string
    killsPerMinute?: string
    goldPerMinute?: string
    averageGameTime?: string
    averageTimeSpentDead?: string
    totalGameTime?: string
    activity?: ActivityCreateNestedManyWithoutProfileInput
    championWinrate?: ChampionWinrateCreateNestedManyWithoutProfileInput
    duos?: DuoCreateNestedManyWithoutProfileInput
  }

  export type ProfileUncheckedCreateWithoutPlayerInput = {
    id?: string
    update?: boolean
    lastUpdate?: Date | string
    kills?: number | null
    deaths?: number | null
    assists?: number | null
    kda?: string
    winRate?: string
    csPerMinute?: string
    damagePerMinute?: string
    killsPerMinute?: string
    goldPerMinute?: string
    averageGameTime?: string
    averageTimeSpentDead?: string
    totalGameTime?: string
    activity?: ActivityUncheckedCreateNestedManyWithoutProfileInput
    championWinrate?: ChampionWinrateUncheckedCreateNestedManyWithoutProfileInput
    duos?: DuoUncheckedCreateNestedManyWithoutProfileInput
  }

  export type ProfileCreateOrConnectWithoutPlayerInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutPlayerInput, ProfileUncheckedCreateWithoutPlayerInput>
  }

  export type TeamMonsterKillCreateWithoutKillerInput = {
    id?: string
    type?: string
    subType?: string
  }

  export type TeamMonsterKillUncheckedCreateWithoutKillerInput = {
    id?: string
    type?: string
    subType?: string
  }

  export type TeamMonsterKillCreateOrConnectWithoutKillerInput = {
    where: TeamMonsterKillWhereUniqueInput
    create: XOR<TeamMonsterKillCreateWithoutKillerInput, TeamMonsterKillUncheckedCreateWithoutKillerInput>
  }

  export type TeamBuildingKillCreateWithoutKillerInput = {
    id?: string
    type?: string
    lane?: string
    side?: string
    towerLocation?: string
  }

  export type TeamBuildingKillUncheckedCreateWithoutKillerInput = {
    id?: string
    type?: string
    lane?: string
    side?: string
    towerLocation?: string
  }

  export type TeamBuildingKillCreateOrConnectWithoutKillerInput = {
    where: TeamBuildingKillWhereUniqueInput
    create: XOR<TeamBuildingKillCreateWithoutKillerInput, TeamBuildingKillUncheckedCreateWithoutKillerInput>
  }

  export type PlayerItemEventCreateWithoutPlayerInput = {
    id?: string
    type?: string
    itemId?: number | null
    name?: string
    undoId?: number | null
  }

  export type PlayerItemEventUncheckedCreateWithoutPlayerInput = {
    id?: string
    type?: string
    itemId?: number | null
    name?: string
    undoId?: number | null
  }

  export type PlayerItemEventCreateOrConnectWithoutPlayerInput = {
    where: PlayerItemEventWhereUniqueInput
    create: XOR<PlayerItemEventCreateWithoutPlayerInput, PlayerItemEventUncheckedCreateWithoutPlayerInput>
  }

  export type PlayerEndOfGameStatCreateWithoutPlayerInput = {
    id?: string
    game?: GameCreateNestedOneWithoutFrom_PlayerEndOfGameStat_gameInput
    perks?: PlayerRuneCreateNestedOneWithoutPlayerEndOfGameStatInput
    items?: PlayerItemCreateNestedOneWithoutPlayerEndOfGameStatInput
    assists?: number | null
    baronKills?: number | null
    bountyLevel?: number | null
    championExperience?: number | null
    championLevel?: number | null
    championId?: number | null
    championName?: string
    championTransform?: number | null
    consumablesPurchased?: number | null
    damageDealtToBuildings?: number | null
    damageDealtToObjectives?: number | null
    damageDealtToTurrets?: number | null
    damageSelfMitigated?: number | null
    deaths?: number | null
    detectorWardsPlaced?: number | null
    doubleKills?: number | null
    dragonKills?: number | null
    firstBlood?: boolean
    firstBloodAssist?: boolean
    firstTowerKill?: boolean
    firstTowerAssist?: boolean
    gameEndedInEarlySurrender?: boolean
    gameEndedInSurrender?: boolean
    goldEarned?: number | null
    goldSpent?: number | null
    individualPosition?: string
    inhibitorKills?: number | null
    inhibitorTakedowns?: number | null
    inhibitorsLost?: number | null
    item0?: number | null
    item1?: number | null
    item2?: number | null
    item3?: number | null
    item4?: number | null
    item5?: number | null
    item6?: number | null
    itemsPurchased?: number | null
    killingSprees?: number | null
    kills?: number | null
    lane?: string
    largestCriticalStrike?: number | null
    largestKillingSpree?: number | null
    largestMultiKill?: number | null
    longestTimeSpentLiving?: number | null
    magicDamageDealt?: number | null
    magicDamageDealtToChampions?: number | null
    magicDamageTaken?: number | null
    neutralMinionsKilled?: number | null
    nexusKills?: number | null
    nexusLost?: number | null
    nexusTakedowns?: number | null
    objectivesStolen?: number | null
    objectivesStolenAssists?: number | null
    participantId?: number | null
    pentaKills?: number | null
    physicalDamageDealt?: number | null
    physicalDamageDealtToChampions?: number | null
    physicalDamageTaken?: number | null
    quadraKills?: number | null
    riotIdName?: string
    riotIdTagline?: string
    role?: string
    sightWardsBoughtInGame?: number | null
    spell1Casts?: number | null
    spell2Casts?: number | null
    spell3Casts?: number | null
    spell4Casts?: number | null
    summoner1Casts?: number | null
    summoner1Id?: number | null
    summoner2Casts?: number | null
    summoner2Id?: number | null
    summonerLevel?: number | null
    summonerName?: string
    teamEarlySurrendered?: boolean
    teamId?: number | null
    teamPosition?: string
    timeCCingOthers?: number | null
    timePlayed?: number | null
    totalDamageDealt?: number | null
    totalDamageDealtToChampions?: number | null
    totalDamageShieldedOnTeammates?: number | null
    totalDamageTaken?: number | null
    totalHeal?: number | null
    totalHealsOnTeammates?: number | null
    totalMinionsKilled?: number | null
    totalTimeCCDealt?: number | null
    totalTimeSpentDead?: number | null
    totalUnitsHealed?: number | null
    tripleKills?: number | null
    trueDamageDealt?: number | null
    trueDamageDealtToChampions?: number | null
    trueDamageTaken?: number | null
    turretsKilled?: number | null
    turretTakedowns?: number | null
    turretsLost?: number | null
    unrealKills?: number | null
    visionScore?: number | null
    visionWardsBoughtInGame?: number | null
    wardsKilled?: number | null
    wardsPlaced?: number | null
    win?: boolean
  }

  export type PlayerEndOfGameStatUncheckedCreateWithoutPlayerInput = {
    id?: string
    gameId?: string | null
    perksId?: string | null
    itemsId?: string | null
    assists?: number | null
    baronKills?: number | null
    bountyLevel?: number | null
    championExperience?: number | null
    championLevel?: number | null
    championId?: number | null
    championName?: string
    championTransform?: number | null
    consumablesPurchased?: number | null
    damageDealtToBuildings?: number | null
    damageDealtToObjectives?: number | null
    damageDealtToTurrets?: number | null
    damageSelfMitigated?: number | null
    deaths?: number | null
    detectorWardsPlaced?: number | null
    doubleKills?: number | null
    dragonKills?: number | null
    firstBlood?: boolean
    firstBloodAssist?: boolean
    firstTowerKill?: boolean
    firstTowerAssist?: boolean
    gameEndedInEarlySurrender?: boolean
    gameEndedInSurrender?: boolean
    goldEarned?: number | null
    goldSpent?: number | null
    individualPosition?: string
    inhibitorKills?: number | null
    inhibitorTakedowns?: number | null
    inhibitorsLost?: number | null
    item0?: number | null
    item1?: number | null
    item2?: number | null
    item3?: number | null
    item4?: number | null
    item5?: number | null
    item6?: number | null
    itemsPurchased?: number | null
    killingSprees?: number | null
    kills?: number | null
    lane?: string
    largestCriticalStrike?: number | null
    largestKillingSpree?: number | null
    largestMultiKill?: number | null
    longestTimeSpentLiving?: number | null
    magicDamageDealt?: number | null
    magicDamageDealtToChampions?: number | null
    magicDamageTaken?: number | null
    neutralMinionsKilled?: number | null
    nexusKills?: number | null
    nexusLost?: number | null
    nexusTakedowns?: number | null
    objectivesStolen?: number | null
    objectivesStolenAssists?: number | null
    participantId?: number | null
    pentaKills?: number | null
    physicalDamageDealt?: number | null
    physicalDamageDealtToChampions?: number | null
    physicalDamageTaken?: number | null
    quadraKills?: number | null
    riotIdName?: string
    riotIdTagline?: string
    role?: string
    sightWardsBoughtInGame?: number | null
    spell1Casts?: number | null
    spell2Casts?: number | null
    spell3Casts?: number | null
    spell4Casts?: number | null
    summoner1Casts?: number | null
    summoner1Id?: number | null
    summoner2Casts?: number | null
    summoner2Id?: number | null
    summonerLevel?: number | null
    summonerName?: string
    teamEarlySurrendered?: boolean
    teamId?: number | null
    teamPosition?: string
    timeCCingOthers?: number | null
    timePlayed?: number | null
    totalDamageDealt?: number | null
    totalDamageDealtToChampions?: number | null
    totalDamageShieldedOnTeammates?: number | null
    totalDamageTaken?: number | null
    totalHeal?: number | null
    totalHealsOnTeammates?: number | null
    totalMinionsKilled?: number | null
    totalTimeCCDealt?: number | null
    totalTimeSpentDead?: number | null
    totalUnitsHealed?: number | null
    tripleKills?: number | null
    trueDamageDealt?: number | null
    trueDamageDealtToChampions?: number | null
    trueDamageTaken?: number | null
    turretsKilled?: number | null
    turretTakedowns?: number | null
    turretsLost?: number | null
    unrealKills?: number | null
    visionScore?: number | null
    visionWardsBoughtInGame?: number | null
    wardsKilled?: number | null
    wardsPlaced?: number | null
    win?: boolean
  }

  export type PlayerEndOfGameStatCreateOrConnectWithoutPlayerInput = {
    where: PlayerEndOfGameStatWhereUniqueInput
    create: XOR<PlayerEndOfGameStatCreateWithoutPlayerInput, PlayerEndOfGameStatUncheckedCreateWithoutPlayerInput>
  }

  export type PlayerEndOfGameStatCreateManyPlayerInputEnvelope = {
    data: Enumerable<PlayerEndOfGameStatCreateManyPlayerInput>
    skipDuplicates?: boolean
  }

  export type PlayerSnapshotCreateWithoutPlayerInput = {
    id?: string
    timestamp?: number | null
    currentGold?: number | null
    totalGold?: number | null
    totalGoldDiff?: number | null
    xp?: number | null
    xpDiff?: number | null
    level?: number | null
    cs?: number | null
    csDiff?: number | null
    monstersKilled?: number | null
    monstersKilledDiff?: number | null
    position?: PositionCreateNestedManyWithoutPlayerSnapshotInput
  }

  export type PlayerSnapshotUncheckedCreateWithoutPlayerInput = {
    id?: string
    timestamp?: number | null
    currentGold?: number | null
    totalGold?: number | null
    totalGoldDiff?: number | null
    xp?: number | null
    xpDiff?: number | null
    level?: number | null
    cs?: number | null
    csDiff?: number | null
    monstersKilled?: number | null
    monstersKilledDiff?: number | null
    position?: PositionUncheckedCreateNestedManyWithoutPlayerSnapshotInput
  }

  export type PlayerSnapshotCreateOrConnectWithoutPlayerInput = {
    where: PlayerSnapshotWhereUniqueInput
    create: XOR<PlayerSnapshotCreateWithoutPlayerInput, PlayerSnapshotUncheckedCreateWithoutPlayerInput>
  }

  export type PlayerWardEventCreateWithoutPlayerInput = {
    id?: string
    type?: string
    wardType?: PlayerWardEventWardTypeType | null
  }

  export type PlayerWardEventUncheckedCreateWithoutPlayerInput = {
    id?: string
    type?: string
    wardType?: PlayerWardEventWardTypeType | null
  }

  export type PlayerWardEventCreateOrConnectWithoutPlayerInput = {
    where: PlayerWardEventWhereUniqueInput
    create: XOR<PlayerWardEventCreateWithoutPlayerInput, PlayerWardEventUncheckedCreateWithoutPlayerInput>
  }

  export type PlayerSkillLevelUpEventCreateWithoutPlayerInput = {
    id?: string
    type?: string
    slot?: number | null
  }

  export type PlayerSkillLevelUpEventUncheckedCreateWithoutPlayerInput = {
    id?: string
    type?: string
    slot?: number | null
  }

  export type PlayerSkillLevelUpEventCreateOrConnectWithoutPlayerInput = {
    where: PlayerSkillLevelUpEventWhereUniqueInput
    create: XOR<PlayerSkillLevelUpEventCreateWithoutPlayerInput, PlayerSkillLevelUpEventUncheckedCreateWithoutPlayerInput>
  }

  export type PlayerKillUpsertWithWhereUniqueWithoutKillerInput = {
    where: PlayerKillWhereUniqueInput
    update: XOR<PlayerKillUpdateWithoutKillerInput, PlayerKillUncheckedUpdateWithoutKillerInput>
    create: XOR<PlayerKillCreateWithoutKillerInput, PlayerKillUncheckedCreateWithoutKillerInput>
  }

  export type PlayerKillUpdateWithWhereUniqueWithoutKillerInput = {
    where: PlayerKillWhereUniqueInput
    data: XOR<PlayerKillUpdateWithoutKillerInput, PlayerKillUncheckedUpdateWithoutKillerInput>
  }

  export type PlayerKillUpdateManyWithWhereWithoutKillerInput = {
    where: PlayerKillScalarWhereInput
    data: XOR<PlayerKillUpdateManyMutationInput, PlayerKillUncheckedUpdateManyWithoutKillsInput>
  }

  export type PlayerKillScalarWhereInput = {
    AND?: Enumerable<PlayerKillScalarWhereInput>
    OR?: Enumerable<PlayerKillScalarWhereInput>
    NOT?: Enumerable<PlayerKillScalarWhereInput>
    id?: StringFilter | string
  }

  export type PlayerKillUpsertWithWhereUniqueWithoutVictimInput = {
    where: PlayerKillWhereUniqueInput
    update: XOR<PlayerKillUpdateWithoutVictimInput, PlayerKillUncheckedUpdateWithoutVictimInput>
    create: XOR<PlayerKillCreateWithoutVictimInput, PlayerKillUncheckedCreateWithoutVictimInput>
  }

  export type PlayerKillUpdateWithWhereUniqueWithoutVictimInput = {
    where: PlayerKillWhereUniqueInput
    data: XOR<PlayerKillUpdateWithoutVictimInput, PlayerKillUncheckedUpdateWithoutVictimInput>
  }

  export type PlayerKillUpdateManyWithWhereWithoutVictimInput = {
    where: PlayerKillScalarWhereInput
    data: XOR<PlayerKillUpdateManyMutationInput, PlayerKillUncheckedUpdateManyWithoutDeathsInput>
  }

  export type TeamUpsertWithWhereUniqueWithoutPlayersInput = {
    where: TeamWhereUniqueInput
    update: XOR<TeamUpdateWithoutPlayersInput, TeamUncheckedUpdateWithoutPlayersInput>
    create: XOR<TeamCreateWithoutPlayersInput, TeamUncheckedCreateWithoutPlayersInput>
  }

  export type TeamUpdateWithWhereUniqueWithoutPlayersInput = {
    where: TeamWhereUniqueInput
    data: XOR<TeamUpdateWithoutPlayersInput, TeamUncheckedUpdateWithoutPlayersInput>
  }

  export type TeamUpdateManyWithWhereWithoutPlayersInput = {
    where: TeamScalarWhereInput
    data: XOR<TeamUpdateManyMutationInput, TeamUncheckedUpdateManyWithoutTeamsInput>
  }

  export type ProfileUpsertWithoutPlayerInput = {
    update: XOR<ProfileUpdateWithoutPlayerInput, ProfileUncheckedUpdateWithoutPlayerInput>
    create: XOR<ProfileCreateWithoutPlayerInput, ProfileUncheckedCreateWithoutPlayerInput>
  }

  export type ProfileUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    update?: BoolFieldUpdateOperationsInput | boolean
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    kills?: NullableIntFieldUpdateOperationsInput | number | null
    deaths?: NullableIntFieldUpdateOperationsInput | number | null
    assists?: NullableIntFieldUpdateOperationsInput | number | null
    kda?: StringFieldUpdateOperationsInput | string
    winRate?: StringFieldUpdateOperationsInput | string
    csPerMinute?: StringFieldUpdateOperationsInput | string
    damagePerMinute?: StringFieldUpdateOperationsInput | string
    killsPerMinute?: StringFieldUpdateOperationsInput | string
    goldPerMinute?: StringFieldUpdateOperationsInput | string
    averageGameTime?: StringFieldUpdateOperationsInput | string
    averageTimeSpentDead?: StringFieldUpdateOperationsInput | string
    totalGameTime?: StringFieldUpdateOperationsInput | string
    activity?: ActivityUpdateManyWithoutProfileInput
    championWinrate?: ChampionWinrateUpdateManyWithoutProfileInput
    duos?: DuoUpdateManyWithoutProfileInput
  }

  export type ProfileUncheckedUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    update?: BoolFieldUpdateOperationsInput | boolean
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    kills?: NullableIntFieldUpdateOperationsInput | number | null
    deaths?: NullableIntFieldUpdateOperationsInput | number | null
    assists?: NullableIntFieldUpdateOperationsInput | number | null
    kda?: StringFieldUpdateOperationsInput | string
    winRate?: StringFieldUpdateOperationsInput | string
    csPerMinute?: StringFieldUpdateOperationsInput | string
    damagePerMinute?: StringFieldUpdateOperationsInput | string
    killsPerMinute?: StringFieldUpdateOperationsInput | string
    goldPerMinute?: StringFieldUpdateOperationsInput | string
    averageGameTime?: StringFieldUpdateOperationsInput | string
    averageTimeSpentDead?: StringFieldUpdateOperationsInput | string
    totalGameTime?: StringFieldUpdateOperationsInput | string
    activity?: ActivityUncheckedUpdateManyWithoutProfileInput
    championWinrate?: ChampionWinrateUncheckedUpdateManyWithoutProfileInput
    duos?: DuoUncheckedUpdateManyWithoutProfileInput
  }

  export type TeamMonsterKillUpsertWithWhereUniqueWithoutKillerInput = {
    where: TeamMonsterKillWhereUniqueInput
    update: XOR<TeamMonsterKillUpdateWithoutKillerInput, TeamMonsterKillUncheckedUpdateWithoutKillerInput>
    create: XOR<TeamMonsterKillCreateWithoutKillerInput, TeamMonsterKillUncheckedCreateWithoutKillerInput>
  }

  export type TeamMonsterKillUpdateWithWhereUniqueWithoutKillerInput = {
    where: TeamMonsterKillWhereUniqueInput
    data: XOR<TeamMonsterKillUpdateWithoutKillerInput, TeamMonsterKillUncheckedUpdateWithoutKillerInput>
  }

  export type TeamMonsterKillUpdateManyWithWhereWithoutKillerInput = {
    where: TeamMonsterKillScalarWhereInput
    data: XOR<TeamMonsterKillUpdateManyMutationInput, TeamMonsterKillUncheckedUpdateManyWithoutMonsterKillsInput>
  }

  export type TeamMonsterKillScalarWhereInput = {
    AND?: Enumerable<TeamMonsterKillScalarWhereInput>
    OR?: Enumerable<TeamMonsterKillScalarWhereInput>
    NOT?: Enumerable<TeamMonsterKillScalarWhereInput>
    id?: StringFilter | string
    type?: StringFilter | string
    subType?: StringFilter | string
  }

  export type TeamBuildingKillUpsertWithWhereUniqueWithoutKillerInput = {
    where: TeamBuildingKillWhereUniqueInput
    update: XOR<TeamBuildingKillUpdateWithoutKillerInput, TeamBuildingKillUncheckedUpdateWithoutKillerInput>
    create: XOR<TeamBuildingKillCreateWithoutKillerInput, TeamBuildingKillUncheckedCreateWithoutKillerInput>
  }

  export type TeamBuildingKillUpdateWithWhereUniqueWithoutKillerInput = {
    where: TeamBuildingKillWhereUniqueInput
    data: XOR<TeamBuildingKillUpdateWithoutKillerInput, TeamBuildingKillUncheckedUpdateWithoutKillerInput>
  }

  export type TeamBuildingKillUpdateManyWithWhereWithoutKillerInput = {
    where: TeamBuildingKillScalarWhereInput
    data: XOR<TeamBuildingKillUpdateManyMutationInput, TeamBuildingKillUncheckedUpdateManyWithoutBuildingKillsInput>
  }

  export type TeamBuildingKillScalarWhereInput = {
    AND?: Enumerable<TeamBuildingKillScalarWhereInput>
    OR?: Enumerable<TeamBuildingKillScalarWhereInput>
    NOT?: Enumerable<TeamBuildingKillScalarWhereInput>
    id?: StringFilter | string
    type?: StringFilter | string
    lane?: StringFilter | string
    side?: StringFilter | string
    towerLocation?: StringFilter | string
  }

  export type PlayerItemEventUpsertWithWhereUniqueWithoutPlayerInput = {
    where: PlayerItemEventWhereUniqueInput
    update: XOR<PlayerItemEventUpdateWithoutPlayerInput, PlayerItemEventUncheckedUpdateWithoutPlayerInput>
    create: XOR<PlayerItemEventCreateWithoutPlayerInput, PlayerItemEventUncheckedCreateWithoutPlayerInput>
  }

  export type PlayerItemEventUpdateWithWhereUniqueWithoutPlayerInput = {
    where: PlayerItemEventWhereUniqueInput
    data: XOR<PlayerItemEventUpdateWithoutPlayerInput, PlayerItemEventUncheckedUpdateWithoutPlayerInput>
  }

  export type PlayerItemEventUpdateManyWithWhereWithoutPlayerInput = {
    where: PlayerItemEventScalarWhereInput
    data: XOR<PlayerItemEventUpdateManyMutationInput, PlayerItemEventUncheckedUpdateManyWithoutItemEventInput>
  }

  export type PlayerItemEventScalarWhereInput = {
    AND?: Enumerable<PlayerItemEventScalarWhereInput>
    OR?: Enumerable<PlayerItemEventScalarWhereInput>
    NOT?: Enumerable<PlayerItemEventScalarWhereInput>
    id?: StringFilter | string
    type?: StringFilter | string
    itemId?: IntNullableFilter | number | null
    name?: StringFilter | string
    undoId?: IntNullableFilter | number | null
  }

  export type PlayerEndOfGameStatUpsertWithWhereUniqueWithoutPlayerInput = {
    where: PlayerEndOfGameStatWhereUniqueInput
    update: XOR<PlayerEndOfGameStatUpdateWithoutPlayerInput, PlayerEndOfGameStatUncheckedUpdateWithoutPlayerInput>
    create: XOR<PlayerEndOfGameStatCreateWithoutPlayerInput, PlayerEndOfGameStatUncheckedCreateWithoutPlayerInput>
  }

  export type PlayerEndOfGameStatUpdateWithWhereUniqueWithoutPlayerInput = {
    where: PlayerEndOfGameStatWhereUniqueInput
    data: XOR<PlayerEndOfGameStatUpdateWithoutPlayerInput, PlayerEndOfGameStatUncheckedUpdateWithoutPlayerInput>
  }

  export type PlayerEndOfGameStatUpdateManyWithWhereWithoutPlayerInput = {
    where: PlayerEndOfGameStatScalarWhereInput
    data: XOR<PlayerEndOfGameStatUpdateManyMutationInput, PlayerEndOfGameStatUncheckedUpdateManyWithoutEndOfGameStatsInput>
  }

  export type PlayerSnapshotUpsertWithWhereUniqueWithoutPlayerInput = {
    where: PlayerSnapshotWhereUniqueInput
    update: XOR<PlayerSnapshotUpdateWithoutPlayerInput, PlayerSnapshotUncheckedUpdateWithoutPlayerInput>
    create: XOR<PlayerSnapshotCreateWithoutPlayerInput, PlayerSnapshotUncheckedCreateWithoutPlayerInput>
  }

  export type PlayerSnapshotUpdateWithWhereUniqueWithoutPlayerInput = {
    where: PlayerSnapshotWhereUniqueInput
    data: XOR<PlayerSnapshotUpdateWithoutPlayerInput, PlayerSnapshotUncheckedUpdateWithoutPlayerInput>
  }

  export type PlayerSnapshotUpdateManyWithWhereWithoutPlayerInput = {
    where: PlayerSnapshotScalarWhereInput
    data: XOR<PlayerSnapshotUpdateManyMutationInput, PlayerSnapshotUncheckedUpdateManyWithoutSnapshotsInput>
  }

  export type PlayerSnapshotScalarWhereInput = {
    AND?: Enumerable<PlayerSnapshotScalarWhereInput>
    OR?: Enumerable<PlayerSnapshotScalarWhereInput>
    NOT?: Enumerable<PlayerSnapshotScalarWhereInput>
    id?: StringFilter | string
    timestamp?: FloatNullableFilter | number | null
    currentGold?: IntNullableFilter | number | null
    totalGold?: IntNullableFilter | number | null
    totalGoldDiff?: IntNullableFilter | number | null
    xp?: IntNullableFilter | number | null
    xpDiff?: IntNullableFilter | number | null
    level?: IntNullableFilter | number | null
    cs?: IntNullableFilter | number | null
    csDiff?: IntNullableFilter | number | null
    monstersKilled?: IntNullableFilter | number | null
    monstersKilledDiff?: IntNullableFilter | number | null
  }

  export type PlayerWardEventUpsertWithWhereUniqueWithoutPlayerInput = {
    where: PlayerWardEventWhereUniqueInput
    update: XOR<PlayerWardEventUpdateWithoutPlayerInput, PlayerWardEventUncheckedUpdateWithoutPlayerInput>
    create: XOR<PlayerWardEventCreateWithoutPlayerInput, PlayerWardEventUncheckedCreateWithoutPlayerInput>
  }

  export type PlayerWardEventUpdateWithWhereUniqueWithoutPlayerInput = {
    where: PlayerWardEventWhereUniqueInput
    data: XOR<PlayerWardEventUpdateWithoutPlayerInput, PlayerWardEventUncheckedUpdateWithoutPlayerInput>
  }

  export type PlayerWardEventUpdateManyWithWhereWithoutPlayerInput = {
    where: PlayerWardEventScalarWhereInput
    data: XOR<PlayerWardEventUpdateManyMutationInput, PlayerWardEventUncheckedUpdateManyWithoutWardEventsInput>
  }

  export type PlayerWardEventScalarWhereInput = {
    AND?: Enumerable<PlayerWardEventScalarWhereInput>
    OR?: Enumerable<PlayerWardEventScalarWhereInput>
    NOT?: Enumerable<PlayerWardEventScalarWhereInput>
    id?: StringFilter | string
    type?: StringFilter | string
    wardType?: EnumPlayerWardEventWardTypeTypeNullableFilter | PlayerWardEventWardTypeType | null
  }

  export type PlayerSkillLevelUpEventUpsertWithWhereUniqueWithoutPlayerInput = {
    where: PlayerSkillLevelUpEventWhereUniqueInput
    update: XOR<PlayerSkillLevelUpEventUpdateWithoutPlayerInput, PlayerSkillLevelUpEventUncheckedUpdateWithoutPlayerInput>
    create: XOR<PlayerSkillLevelUpEventCreateWithoutPlayerInput, PlayerSkillLevelUpEventUncheckedCreateWithoutPlayerInput>
  }

  export type PlayerSkillLevelUpEventUpdateWithWhereUniqueWithoutPlayerInput = {
    where: PlayerSkillLevelUpEventWhereUniqueInput
    data: XOR<PlayerSkillLevelUpEventUpdateWithoutPlayerInput, PlayerSkillLevelUpEventUncheckedUpdateWithoutPlayerInput>
  }

  export type PlayerSkillLevelUpEventUpdateManyWithWhereWithoutPlayerInput = {
    where: PlayerSkillLevelUpEventScalarWhereInput
    data: XOR<PlayerSkillLevelUpEventUpdateManyMutationInput, PlayerSkillLevelUpEventUncheckedUpdateManyWithoutSkillLevelUpEventsInput>
  }

  export type PlayerSkillLevelUpEventScalarWhereInput = {
    AND?: Enumerable<PlayerSkillLevelUpEventScalarWhereInput>
    OR?: Enumerable<PlayerSkillLevelUpEventScalarWhereInput>
    NOT?: Enumerable<PlayerSkillLevelUpEventScalarWhereInput>
    id?: StringFilter | string
    type?: StringFilter | string
    slot?: IntNullableFilter | number | null
  }

  export type PlayerCreateWithoutEndOfGameStatsInput = {
    id?: string
    puuid?: string
    accountId?: string
    platformId?: string
    summonerId?: string
    summonerName?: string
    summonerLevel?: number | null
    profileIconId?: number | null
    revisionDate?: string
    kills?: PlayerKillCreateNestedManyWithoutKillerInput
    deaths?: PlayerKillCreateNestedManyWithoutVictimInput
    teams?: TeamCreateNestedManyWithoutPlayersInput
    profile?: ProfileCreateNestedOneWithoutPlayerInput
    monsterKills?: TeamMonsterKillCreateNestedManyWithoutKillerInput
    buildingKills?: TeamBuildingKillCreateNestedManyWithoutKillerInput
    itemEvent?: PlayerItemEventCreateNestedManyWithoutPlayerInput
    snapshots?: PlayerSnapshotCreateNestedManyWithoutPlayerInput
    wardEvents?: PlayerWardEventCreateNestedManyWithoutPlayerInput
    skillLevelUpEvents?: PlayerSkillLevelUpEventCreateNestedManyWithoutPlayerInput
  }

  export type PlayerUncheckedCreateWithoutEndOfGameStatsInput = {
    id?: string
    puuid?: string
    accountId?: string
    platformId?: string
    summonerId?: string
    summonerName?: string
    summonerLevel?: number | null
    profileIconId?: number | null
    revisionDate?: string
    kills?: PlayerKillUncheckedCreateNestedManyWithoutKillerInput
    deaths?: PlayerKillUncheckedCreateNestedManyWithoutVictimInput
    teams?: TeamUncheckedCreateNestedManyWithoutPlayersInput
    profileId?: string | null
    monsterKills?: TeamMonsterKillUncheckedCreateNestedManyWithoutKillerInput
    buildingKills?: TeamBuildingKillUncheckedCreateNestedManyWithoutKillerInput
    itemEvent?: PlayerItemEventUncheckedCreateNestedManyWithoutPlayerInput
    snapshots?: PlayerSnapshotUncheckedCreateNestedManyWithoutPlayerInput
    wardEvents?: PlayerWardEventUncheckedCreateNestedManyWithoutPlayerInput
    skillLevelUpEvents?: PlayerSkillLevelUpEventUncheckedCreateNestedManyWithoutPlayerInput
  }

  export type PlayerCreateOrConnectWithoutEndOfGameStatsInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutEndOfGameStatsInput, PlayerUncheckedCreateWithoutEndOfGameStatsInput>
  }

  export type GameCreateWithoutFrom_PlayerEndOfGameStat_gameInput = {
    id?: string
    matchId?: string
    gameId?: string
    gameCreation?: string
    gameStartTimestamp?: string
    gameEndTimestamp?: string
    duration?: number | null
    start?: string
    gameVersion?: string
    blueTeam?: TeamCreateNestedOneWithoutFrom_Game_blueTeamInput
    redTeam?: TeamCreateNestedOneWithoutFrom_Game_redTeamInput
    source?: SourceCreateNestedManyWithoutGameInput
    tournament?: string
    gameInSeries?: number | null
    vod?: string
    platformId?: string
    from_Team_game?: TeamCreateNestedManyWithoutGameInput
  }

  export type GameUncheckedCreateWithoutFrom_PlayerEndOfGameStat_gameInput = {
    id?: string
    matchId?: string
    gameId?: string
    gameCreation?: string
    gameStartTimestamp?: string
    gameEndTimestamp?: string
    duration?: number | null
    start?: string
    gameVersion?: string
    blueTeamId?: string | null
    redTeamId?: string | null
    source?: SourceUncheckedCreateNestedManyWithoutGameInput
    tournament?: string
    gameInSeries?: number | null
    vod?: string
    platformId?: string
    from_Team_game?: TeamUncheckedCreateNestedManyWithoutGameInput
  }

  export type GameCreateOrConnectWithoutFrom_PlayerEndOfGameStat_gameInput = {
    where: GameWhereUniqueInput
    create: XOR<GameCreateWithoutFrom_PlayerEndOfGameStat_gameInput, GameUncheckedCreateWithoutFrom_PlayerEndOfGameStat_gameInput>
  }

  export type PlayerRuneCreateWithoutPlayerEndOfGameStatInput = {
    id?: string
    runeStyle?: RuneStyleCreateNestedManyWithoutPlayerRunesInput
    defense?: number | null
    flex?: number | null
    offense?: number | null
  }

  export type PlayerRuneUncheckedCreateWithoutPlayerEndOfGameStatInput = {
    id?: string
    runeStyle?: RuneStyleUncheckedCreateNestedManyWithoutPlayerRunesInput
    defense?: number | null
    flex?: number | null
    offense?: number | null
  }

  export type PlayerRuneCreateOrConnectWithoutPlayerEndOfGameStatInput = {
    where: PlayerRuneWhereUniqueInput
    create: XOR<PlayerRuneCreateWithoutPlayerEndOfGameStatInput, PlayerRuneUncheckedCreateWithoutPlayerEndOfGameStatInput>
  }

  export type PlayerItemCreateWithoutPlayerEndOfGameStatInput = {
    id?: string
    slot?: number | null
    itemId?: number | null
    name?: string
  }

  export type PlayerItemUncheckedCreateWithoutPlayerEndOfGameStatInput = {
    id?: string
    slot?: number | null
    itemId?: number | null
    name?: string
  }

  export type PlayerItemCreateOrConnectWithoutPlayerEndOfGameStatInput = {
    where: PlayerItemWhereUniqueInput
    create: XOR<PlayerItemCreateWithoutPlayerEndOfGameStatInput, PlayerItemUncheckedCreateWithoutPlayerEndOfGameStatInput>
  }

  export type PlayerUpsertWithoutEndOfGameStatsInput = {
    update: XOR<PlayerUpdateWithoutEndOfGameStatsInput, PlayerUncheckedUpdateWithoutEndOfGameStatsInput>
    create: XOR<PlayerCreateWithoutEndOfGameStatsInput, PlayerUncheckedCreateWithoutEndOfGameStatsInput>
  }

  export type PlayerUpdateWithoutEndOfGameStatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    puuid?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    platformId?: StringFieldUpdateOperationsInput | string
    summonerId?: StringFieldUpdateOperationsInput | string
    summonerName?: StringFieldUpdateOperationsInput | string
    summonerLevel?: NullableIntFieldUpdateOperationsInput | number | null
    profileIconId?: NullableIntFieldUpdateOperationsInput | number | null
    revisionDate?: StringFieldUpdateOperationsInput | string
    kills?: PlayerKillUpdateManyWithoutKillerInput
    deaths?: PlayerKillUpdateManyWithoutVictimInput
    teams?: TeamUpdateManyWithoutPlayersInput
    profile?: ProfileUpdateOneWithoutPlayerInput
    monsterKills?: TeamMonsterKillUpdateManyWithoutKillerInput
    buildingKills?: TeamBuildingKillUpdateManyWithoutKillerInput
    itemEvent?: PlayerItemEventUpdateManyWithoutPlayerInput
    snapshots?: PlayerSnapshotUpdateManyWithoutPlayerInput
    wardEvents?: PlayerWardEventUpdateManyWithoutPlayerInput
    skillLevelUpEvents?: PlayerSkillLevelUpEventUpdateManyWithoutPlayerInput
  }

  export type PlayerUncheckedUpdateWithoutEndOfGameStatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    puuid?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    platformId?: StringFieldUpdateOperationsInput | string
    summonerId?: StringFieldUpdateOperationsInput | string
    summonerName?: StringFieldUpdateOperationsInput | string
    summonerLevel?: NullableIntFieldUpdateOperationsInput | number | null
    profileIconId?: NullableIntFieldUpdateOperationsInput | number | null
    revisionDate?: StringFieldUpdateOperationsInput | string
    kills?: PlayerKillUncheckedUpdateManyWithoutKillerInput
    deaths?: PlayerKillUncheckedUpdateManyWithoutVictimInput
    teams?: TeamUncheckedUpdateManyWithoutPlayersInput
    profileId?: NullableStringFieldUpdateOperationsInput | string | null
    monsterKills?: TeamMonsterKillUncheckedUpdateManyWithoutKillerInput
    buildingKills?: TeamBuildingKillUncheckedUpdateManyWithoutKillerInput
    itemEvent?: PlayerItemEventUncheckedUpdateManyWithoutPlayerInput
    snapshots?: PlayerSnapshotUncheckedUpdateManyWithoutPlayerInput
    wardEvents?: PlayerWardEventUncheckedUpdateManyWithoutPlayerInput
    skillLevelUpEvents?: PlayerSkillLevelUpEventUncheckedUpdateManyWithoutPlayerInput
  }

  export type GameUpsertWithoutFrom_PlayerEndOfGameStat_gameInput = {
    update: XOR<GameUpdateWithoutFrom_PlayerEndOfGameStat_gameInput, GameUncheckedUpdateWithoutFrom_PlayerEndOfGameStat_gameInput>
    create: XOR<GameCreateWithoutFrom_PlayerEndOfGameStat_gameInput, GameUncheckedCreateWithoutFrom_PlayerEndOfGameStat_gameInput>
  }

  export type GameUpdateWithoutFrom_PlayerEndOfGameStat_gameInput = {
    id?: StringFieldUpdateOperationsInput | string
    matchId?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    gameCreation?: StringFieldUpdateOperationsInput | string
    gameStartTimestamp?: StringFieldUpdateOperationsInput | string
    gameEndTimestamp?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    start?: StringFieldUpdateOperationsInput | string
    gameVersion?: StringFieldUpdateOperationsInput | string
    blueTeam?: TeamUpdateOneWithoutFrom_Game_blueTeamInput
    redTeam?: TeamUpdateOneWithoutFrom_Game_redTeamInput
    source?: SourceUpdateManyWithoutGameInput
    tournament?: StringFieldUpdateOperationsInput | string
    gameInSeries?: NullableIntFieldUpdateOperationsInput | number | null
    vod?: StringFieldUpdateOperationsInput | string
    platformId?: StringFieldUpdateOperationsInput | string
    from_Team_game?: TeamUpdateManyWithoutGameInput
  }

  export type GameUncheckedUpdateWithoutFrom_PlayerEndOfGameStat_gameInput = {
    id?: StringFieldUpdateOperationsInput | string
    matchId?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    gameCreation?: StringFieldUpdateOperationsInput | string
    gameStartTimestamp?: StringFieldUpdateOperationsInput | string
    gameEndTimestamp?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    start?: StringFieldUpdateOperationsInput | string
    gameVersion?: StringFieldUpdateOperationsInput | string
    blueTeamId?: NullableStringFieldUpdateOperationsInput | string | null
    redTeamId?: NullableStringFieldUpdateOperationsInput | string | null
    source?: SourceUncheckedUpdateManyWithoutGameInput
    tournament?: StringFieldUpdateOperationsInput | string
    gameInSeries?: NullableIntFieldUpdateOperationsInput | number | null
    vod?: StringFieldUpdateOperationsInput | string
    platformId?: StringFieldUpdateOperationsInput | string
    from_Team_game?: TeamUncheckedUpdateManyWithoutGameInput
  }

  export type PlayerRuneUpsertWithoutPlayerEndOfGameStatInput = {
    update: XOR<PlayerRuneUpdateWithoutPlayerEndOfGameStatInput, PlayerRuneUncheckedUpdateWithoutPlayerEndOfGameStatInput>
    create: XOR<PlayerRuneCreateWithoutPlayerEndOfGameStatInput, PlayerRuneUncheckedCreateWithoutPlayerEndOfGameStatInput>
  }

  export type PlayerRuneUpdateWithoutPlayerEndOfGameStatInput = {
    id?: StringFieldUpdateOperationsInput | string
    runeStyle?: RuneStyleUpdateManyWithoutPlayerRunesInput
    defense?: NullableIntFieldUpdateOperationsInput | number | null
    flex?: NullableIntFieldUpdateOperationsInput | number | null
    offense?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PlayerRuneUncheckedUpdateWithoutPlayerEndOfGameStatInput = {
    id?: StringFieldUpdateOperationsInput | string
    runeStyle?: RuneStyleUncheckedUpdateManyWithoutPlayerRunesInput
    defense?: NullableIntFieldUpdateOperationsInput | number | null
    flex?: NullableIntFieldUpdateOperationsInput | number | null
    offense?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PlayerItemUpsertWithoutPlayerEndOfGameStatInput = {
    update: XOR<PlayerItemUpdateWithoutPlayerEndOfGameStatInput, PlayerItemUncheckedUpdateWithoutPlayerEndOfGameStatInput>
    create: XOR<PlayerItemCreateWithoutPlayerEndOfGameStatInput, PlayerItemUncheckedCreateWithoutPlayerEndOfGameStatInput>
  }

  export type PlayerItemUpdateWithoutPlayerEndOfGameStatInput = {
    id?: StringFieldUpdateOperationsInput | string
    slot?: NullableIntFieldUpdateOperationsInput | number | null
    itemId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
  }

  export type PlayerItemUncheckedUpdateWithoutPlayerEndOfGameStatInput = {
    id?: StringFieldUpdateOperationsInput | string
    slot?: NullableIntFieldUpdateOperationsInput | number | null
    itemId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
  }

  export type PlayerEndOfGameStatCreateWithoutItemsInput = {
    id?: string
    player?: PlayerCreateNestedOneWithoutEndOfGameStatsInput
    game?: GameCreateNestedOneWithoutFrom_PlayerEndOfGameStat_gameInput
    perks?: PlayerRuneCreateNestedOneWithoutPlayerEndOfGameStatInput
    assists?: number | null
    baronKills?: number | null
    bountyLevel?: number | null
    championExperience?: number | null
    championLevel?: number | null
    championId?: number | null
    championName?: string
    championTransform?: number | null
    consumablesPurchased?: number | null
    damageDealtToBuildings?: number | null
    damageDealtToObjectives?: number | null
    damageDealtToTurrets?: number | null
    damageSelfMitigated?: number | null
    deaths?: number | null
    detectorWardsPlaced?: number | null
    doubleKills?: number | null
    dragonKills?: number | null
    firstBlood?: boolean
    firstBloodAssist?: boolean
    firstTowerKill?: boolean
    firstTowerAssist?: boolean
    gameEndedInEarlySurrender?: boolean
    gameEndedInSurrender?: boolean
    goldEarned?: number | null
    goldSpent?: number | null
    individualPosition?: string
    inhibitorKills?: number | null
    inhibitorTakedowns?: number | null
    inhibitorsLost?: number | null
    item0?: number | null
    item1?: number | null
    item2?: number | null
    item3?: number | null
    item4?: number | null
    item5?: number | null
    item6?: number | null
    itemsPurchased?: number | null
    killingSprees?: number | null
    kills?: number | null
    lane?: string
    largestCriticalStrike?: number | null
    largestKillingSpree?: number | null
    largestMultiKill?: number | null
    longestTimeSpentLiving?: number | null
    magicDamageDealt?: number | null
    magicDamageDealtToChampions?: number | null
    magicDamageTaken?: number | null
    neutralMinionsKilled?: number | null
    nexusKills?: number | null
    nexusLost?: number | null
    nexusTakedowns?: number | null
    objectivesStolen?: number | null
    objectivesStolenAssists?: number | null
    participantId?: number | null
    pentaKills?: number | null
    physicalDamageDealt?: number | null
    physicalDamageDealtToChampions?: number | null
    physicalDamageTaken?: number | null
    quadraKills?: number | null
    riotIdName?: string
    riotIdTagline?: string
    role?: string
    sightWardsBoughtInGame?: number | null
    spell1Casts?: number | null
    spell2Casts?: number | null
    spell3Casts?: number | null
    spell4Casts?: number | null
    summoner1Casts?: number | null
    summoner1Id?: number | null
    summoner2Casts?: number | null
    summoner2Id?: number | null
    summonerLevel?: number | null
    summonerName?: string
    teamEarlySurrendered?: boolean
    teamId?: number | null
    teamPosition?: string
    timeCCingOthers?: number | null
    timePlayed?: number | null
    totalDamageDealt?: number | null
    totalDamageDealtToChampions?: number | null
    totalDamageShieldedOnTeammates?: number | null
    totalDamageTaken?: number | null
    totalHeal?: number | null
    totalHealsOnTeammates?: number | null
    totalMinionsKilled?: number | null
    totalTimeCCDealt?: number | null
    totalTimeSpentDead?: number | null
    totalUnitsHealed?: number | null
    tripleKills?: number | null
    trueDamageDealt?: number | null
    trueDamageDealtToChampions?: number | null
    trueDamageTaken?: number | null
    turretsKilled?: number | null
    turretTakedowns?: number | null
    turretsLost?: number | null
    unrealKills?: number | null
    visionScore?: number | null
    visionWardsBoughtInGame?: number | null
    wardsKilled?: number | null
    wardsPlaced?: number | null
    win?: boolean
  }

  export type PlayerEndOfGameStatUncheckedCreateWithoutItemsInput = {
    id?: string
    playerId?: string | null
    gameId?: string | null
    perksId?: string | null
    assists?: number | null
    baronKills?: number | null
    bountyLevel?: number | null
    championExperience?: number | null
    championLevel?: number | null
    championId?: number | null
    championName?: string
    championTransform?: number | null
    consumablesPurchased?: number | null
    damageDealtToBuildings?: number | null
    damageDealtToObjectives?: number | null
    damageDealtToTurrets?: number | null
    damageSelfMitigated?: number | null
    deaths?: number | null
    detectorWardsPlaced?: number | null
    doubleKills?: number | null
    dragonKills?: number | null
    firstBlood?: boolean
    firstBloodAssist?: boolean
    firstTowerKill?: boolean
    firstTowerAssist?: boolean
    gameEndedInEarlySurrender?: boolean
    gameEndedInSurrender?: boolean
    goldEarned?: number | null
    goldSpent?: number | null
    individualPosition?: string
    inhibitorKills?: number | null
    inhibitorTakedowns?: number | null
    inhibitorsLost?: number | null
    item0?: number | null
    item1?: number | null
    item2?: number | null
    item3?: number | null
    item4?: number | null
    item5?: number | null
    item6?: number | null
    itemsPurchased?: number | null
    killingSprees?: number | null
    kills?: number | null
    lane?: string
    largestCriticalStrike?: number | null
    largestKillingSpree?: number | null
    largestMultiKill?: number | null
    longestTimeSpentLiving?: number | null
    magicDamageDealt?: number | null
    magicDamageDealtToChampions?: number | null
    magicDamageTaken?: number | null
    neutralMinionsKilled?: number | null
    nexusKills?: number | null
    nexusLost?: number | null
    nexusTakedowns?: number | null
    objectivesStolen?: number | null
    objectivesStolenAssists?: number | null
    participantId?: number | null
    pentaKills?: number | null
    physicalDamageDealt?: number | null
    physicalDamageDealtToChampions?: number | null
    physicalDamageTaken?: number | null
    quadraKills?: number | null
    riotIdName?: string
    riotIdTagline?: string
    role?: string
    sightWardsBoughtInGame?: number | null
    spell1Casts?: number | null
    spell2Casts?: number | null
    spell3Casts?: number | null
    spell4Casts?: number | null
    summoner1Casts?: number | null
    summoner1Id?: number | null
    summoner2Casts?: number | null
    summoner2Id?: number | null
    summonerLevel?: number | null
    summonerName?: string
    teamEarlySurrendered?: boolean
    teamId?: number | null
    teamPosition?: string
    timeCCingOthers?: number | null
    timePlayed?: number | null
    totalDamageDealt?: number | null
    totalDamageDealtToChampions?: number | null
    totalDamageShieldedOnTeammates?: number | null
    totalDamageTaken?: number | null
    totalHeal?: number | null
    totalHealsOnTeammates?: number | null
    totalMinionsKilled?: number | null
    totalTimeCCDealt?: number | null
    totalTimeSpentDead?: number | null
    totalUnitsHealed?: number | null
    tripleKills?: number | null
    trueDamageDealt?: number | null
    trueDamageDealtToChampions?: number | null
    trueDamageTaken?: number | null
    turretsKilled?: number | null
    turretTakedowns?: number | null
    turretsLost?: number | null
    unrealKills?: number | null
    visionScore?: number | null
    visionWardsBoughtInGame?: number | null
    wardsKilled?: number | null
    wardsPlaced?: number | null
    win?: boolean
  }

  export type PlayerEndOfGameStatCreateOrConnectWithoutItemsInput = {
    where: PlayerEndOfGameStatWhereUniqueInput
    create: XOR<PlayerEndOfGameStatCreateWithoutItemsInput, PlayerEndOfGameStatUncheckedCreateWithoutItemsInput>
  }

  export type PlayerEndOfGameStatCreateManyItemsInputEnvelope = {
    data: Enumerable<PlayerEndOfGameStatCreateManyItemsInput>
    skipDuplicates?: boolean
  }

  export type PlayerEndOfGameStatUpsertWithWhereUniqueWithoutItemsInput = {
    where: PlayerEndOfGameStatWhereUniqueInput
    update: XOR<PlayerEndOfGameStatUpdateWithoutItemsInput, PlayerEndOfGameStatUncheckedUpdateWithoutItemsInput>
    create: XOR<PlayerEndOfGameStatCreateWithoutItemsInput, PlayerEndOfGameStatUncheckedCreateWithoutItemsInput>
  }

  export type PlayerEndOfGameStatUpdateWithWhereUniqueWithoutItemsInput = {
    where: PlayerEndOfGameStatWhereUniqueInput
    data: XOR<PlayerEndOfGameStatUpdateWithoutItemsInput, PlayerEndOfGameStatUncheckedUpdateWithoutItemsInput>
  }

  export type PlayerEndOfGameStatUpdateManyWithWhereWithoutItemsInput = {
    where: PlayerEndOfGameStatScalarWhereInput
    data: XOR<PlayerEndOfGameStatUpdateManyMutationInput, PlayerEndOfGameStatUncheckedUpdateManyWithoutPlayerEndOfGameStatInput>
  }

  export type PlayerCreateWithoutItemEventInput = {
    id?: string
    puuid?: string
    accountId?: string
    platformId?: string
    summonerId?: string
    summonerName?: string
    summonerLevel?: number | null
    profileIconId?: number | null
    revisionDate?: string
    kills?: PlayerKillCreateNestedManyWithoutKillerInput
    deaths?: PlayerKillCreateNestedManyWithoutVictimInput
    teams?: TeamCreateNestedManyWithoutPlayersInput
    profile?: ProfileCreateNestedOneWithoutPlayerInput
    monsterKills?: TeamMonsterKillCreateNestedManyWithoutKillerInput
    buildingKills?: TeamBuildingKillCreateNestedManyWithoutKillerInput
    endOfGameStats?: PlayerEndOfGameStatCreateNestedManyWithoutPlayerInput
    snapshots?: PlayerSnapshotCreateNestedManyWithoutPlayerInput
    wardEvents?: PlayerWardEventCreateNestedManyWithoutPlayerInput
    skillLevelUpEvents?: PlayerSkillLevelUpEventCreateNestedManyWithoutPlayerInput
  }

  export type PlayerUncheckedCreateWithoutItemEventInput = {
    id?: string
    puuid?: string
    accountId?: string
    platformId?: string
    summonerId?: string
    summonerName?: string
    summonerLevel?: number | null
    profileIconId?: number | null
    revisionDate?: string
    kills?: PlayerKillUncheckedCreateNestedManyWithoutKillerInput
    deaths?: PlayerKillUncheckedCreateNestedManyWithoutVictimInput
    teams?: TeamUncheckedCreateNestedManyWithoutPlayersInput
    profileId?: string | null
    monsterKills?: TeamMonsterKillUncheckedCreateNestedManyWithoutKillerInput
    buildingKills?: TeamBuildingKillUncheckedCreateNestedManyWithoutKillerInput
    endOfGameStats?: PlayerEndOfGameStatUncheckedCreateNestedManyWithoutPlayerInput
    snapshots?: PlayerSnapshotUncheckedCreateNestedManyWithoutPlayerInput
    wardEvents?: PlayerWardEventUncheckedCreateNestedManyWithoutPlayerInput
    skillLevelUpEvents?: PlayerSkillLevelUpEventUncheckedCreateNestedManyWithoutPlayerInput
  }

  export type PlayerCreateOrConnectWithoutItemEventInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutItemEventInput, PlayerUncheckedCreateWithoutItemEventInput>
  }

  export type PlayerUpsertWithWhereUniqueWithoutItemEventInput = {
    where: PlayerWhereUniqueInput
    update: XOR<PlayerUpdateWithoutItemEventInput, PlayerUncheckedUpdateWithoutItemEventInput>
    create: XOR<PlayerCreateWithoutItemEventInput, PlayerUncheckedCreateWithoutItemEventInput>
  }

  export type PlayerUpdateWithWhereUniqueWithoutItemEventInput = {
    where: PlayerWhereUniqueInput
    data: XOR<PlayerUpdateWithoutItemEventInput, PlayerUncheckedUpdateWithoutItemEventInput>
  }

  export type PlayerUpdateManyWithWhereWithoutItemEventInput = {
    where: PlayerScalarWhereInput
    data: XOR<PlayerUpdateManyMutationInput, PlayerUncheckedUpdateManyWithoutPlayerInput>
  }

  export type PlayerScalarWhereInput = {
    AND?: Enumerable<PlayerScalarWhereInput>
    OR?: Enumerable<PlayerScalarWhereInput>
    NOT?: Enumerable<PlayerScalarWhereInput>
    id?: StringFilter | string
    puuid?: StringFilter | string
    accountId?: StringFilter | string
    platformId?: StringFilter | string
    summonerId?: StringFilter | string
    summonerName?: StringFilter | string
    summonerLevel?: IntNullableFilter | number | null
    profileIconId?: IntNullableFilter | number | null
    revisionDate?: StringFilter | string
    profileId?: StringNullableFilter | string | null
  }

  export type PlayerCreateWithoutKillsInput = {
    id?: string
    puuid?: string
    accountId?: string
    platformId?: string
    summonerId?: string
    summonerName?: string
    summonerLevel?: number | null
    profileIconId?: number | null
    revisionDate?: string
    deaths?: PlayerKillCreateNestedManyWithoutVictimInput
    teams?: TeamCreateNestedManyWithoutPlayersInput
    profile?: ProfileCreateNestedOneWithoutPlayerInput
    monsterKills?: TeamMonsterKillCreateNestedManyWithoutKillerInput
    buildingKills?: TeamBuildingKillCreateNestedManyWithoutKillerInput
    itemEvent?: PlayerItemEventCreateNestedManyWithoutPlayerInput
    endOfGameStats?: PlayerEndOfGameStatCreateNestedManyWithoutPlayerInput
    snapshots?: PlayerSnapshotCreateNestedManyWithoutPlayerInput
    wardEvents?: PlayerWardEventCreateNestedManyWithoutPlayerInput
    skillLevelUpEvents?: PlayerSkillLevelUpEventCreateNestedManyWithoutPlayerInput
  }

  export type PlayerUncheckedCreateWithoutKillsInput = {
    id?: string
    puuid?: string
    accountId?: string
    platformId?: string
    summonerId?: string
    summonerName?: string
    summonerLevel?: number | null
    profileIconId?: number | null
    revisionDate?: string
    deaths?: PlayerKillUncheckedCreateNestedManyWithoutVictimInput
    teams?: TeamUncheckedCreateNestedManyWithoutPlayersInput
    profileId?: string | null
    monsterKills?: TeamMonsterKillUncheckedCreateNestedManyWithoutKillerInput
    buildingKills?: TeamBuildingKillUncheckedCreateNestedManyWithoutKillerInput
    itemEvent?: PlayerItemEventUncheckedCreateNestedManyWithoutPlayerInput
    endOfGameStats?: PlayerEndOfGameStatUncheckedCreateNestedManyWithoutPlayerInput
    snapshots?: PlayerSnapshotUncheckedCreateNestedManyWithoutPlayerInput
    wardEvents?: PlayerWardEventUncheckedCreateNestedManyWithoutPlayerInput
    skillLevelUpEvents?: PlayerSkillLevelUpEventUncheckedCreateNestedManyWithoutPlayerInput
  }

  export type PlayerCreateOrConnectWithoutKillsInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutKillsInput, PlayerUncheckedCreateWithoutKillsInput>
  }

  export type PlayerCreateWithoutDeathsInput = {
    id?: string
    puuid?: string
    accountId?: string
    platformId?: string
    summonerId?: string
    summonerName?: string
    summonerLevel?: number | null
    profileIconId?: number | null
    revisionDate?: string
    kills?: PlayerKillCreateNestedManyWithoutKillerInput
    teams?: TeamCreateNestedManyWithoutPlayersInput
    profile?: ProfileCreateNestedOneWithoutPlayerInput
    monsterKills?: TeamMonsterKillCreateNestedManyWithoutKillerInput
    buildingKills?: TeamBuildingKillCreateNestedManyWithoutKillerInput
    itemEvent?: PlayerItemEventCreateNestedManyWithoutPlayerInput
    endOfGameStats?: PlayerEndOfGameStatCreateNestedManyWithoutPlayerInput
    snapshots?: PlayerSnapshotCreateNestedManyWithoutPlayerInput
    wardEvents?: PlayerWardEventCreateNestedManyWithoutPlayerInput
    skillLevelUpEvents?: PlayerSkillLevelUpEventCreateNestedManyWithoutPlayerInput
  }

  export type PlayerUncheckedCreateWithoutDeathsInput = {
    id?: string
    puuid?: string
    accountId?: string
    platformId?: string
    summonerId?: string
    summonerName?: string
    summonerLevel?: number | null
    profileIconId?: number | null
    revisionDate?: string
    kills?: PlayerKillUncheckedCreateNestedManyWithoutKillerInput
    teams?: TeamUncheckedCreateNestedManyWithoutPlayersInput
    profileId?: string | null
    monsterKills?: TeamMonsterKillUncheckedCreateNestedManyWithoutKillerInput
    buildingKills?: TeamBuildingKillUncheckedCreateNestedManyWithoutKillerInput
    itemEvent?: PlayerItemEventUncheckedCreateNestedManyWithoutPlayerInput
    endOfGameStats?: PlayerEndOfGameStatUncheckedCreateNestedManyWithoutPlayerInput
    snapshots?: PlayerSnapshotUncheckedCreateNestedManyWithoutPlayerInput
    wardEvents?: PlayerWardEventUncheckedCreateNestedManyWithoutPlayerInput
    skillLevelUpEvents?: PlayerSkillLevelUpEventUncheckedCreateNestedManyWithoutPlayerInput
  }

  export type PlayerCreateOrConnectWithoutDeathsInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutDeathsInput, PlayerUncheckedCreateWithoutDeathsInput>
  }

  export type PlayerUpsertWithWhereUniqueWithoutKillsInput = {
    where: PlayerWhereUniqueInput
    update: XOR<PlayerUpdateWithoutKillsInput, PlayerUncheckedUpdateWithoutKillsInput>
    create: XOR<PlayerCreateWithoutKillsInput, PlayerUncheckedCreateWithoutKillsInput>
  }

  export type PlayerUpdateWithWhereUniqueWithoutKillsInput = {
    where: PlayerWhereUniqueInput
    data: XOR<PlayerUpdateWithoutKillsInput, PlayerUncheckedUpdateWithoutKillsInput>
  }

  export type PlayerUpdateManyWithWhereWithoutKillsInput = {
    where: PlayerScalarWhereInput
    data: XOR<PlayerUpdateManyMutationInput, PlayerUncheckedUpdateManyWithoutKillerInput>
  }

  export type PlayerUpsertWithWhereUniqueWithoutDeathsInput = {
    where: PlayerWhereUniqueInput
    update: XOR<PlayerUpdateWithoutDeathsInput, PlayerUncheckedUpdateWithoutDeathsInput>
    create: XOR<PlayerCreateWithoutDeathsInput, PlayerUncheckedCreateWithoutDeathsInput>
  }

  export type PlayerUpdateWithWhereUniqueWithoutDeathsInput = {
    where: PlayerWhereUniqueInput
    data: XOR<PlayerUpdateWithoutDeathsInput, PlayerUncheckedUpdateWithoutDeathsInput>
  }

  export type PlayerUpdateManyWithWhereWithoutDeathsInput = {
    where: PlayerScalarWhereInput
    data: XOR<PlayerUpdateManyMutationInput, PlayerUncheckedUpdateManyWithoutVictimInput>
  }

  export type PlayerEndOfGameStatCreateWithoutPerksInput = {
    id?: string
    player?: PlayerCreateNestedOneWithoutEndOfGameStatsInput
    game?: GameCreateNestedOneWithoutFrom_PlayerEndOfGameStat_gameInput
    items?: PlayerItemCreateNestedOneWithoutPlayerEndOfGameStatInput
    assists?: number | null
    baronKills?: number | null
    bountyLevel?: number | null
    championExperience?: number | null
    championLevel?: number | null
    championId?: number | null
    championName?: string
    championTransform?: number | null
    consumablesPurchased?: number | null
    damageDealtToBuildings?: number | null
    damageDealtToObjectives?: number | null
    damageDealtToTurrets?: number | null
    damageSelfMitigated?: number | null
    deaths?: number | null
    detectorWardsPlaced?: number | null
    doubleKills?: number | null
    dragonKills?: number | null
    firstBlood?: boolean
    firstBloodAssist?: boolean
    firstTowerKill?: boolean
    firstTowerAssist?: boolean
    gameEndedInEarlySurrender?: boolean
    gameEndedInSurrender?: boolean
    goldEarned?: number | null
    goldSpent?: number | null
    individualPosition?: string
    inhibitorKills?: number | null
    inhibitorTakedowns?: number | null
    inhibitorsLost?: number | null
    item0?: number | null
    item1?: number | null
    item2?: number | null
    item3?: number | null
    item4?: number | null
    item5?: number | null
    item6?: number | null
    itemsPurchased?: number | null
    killingSprees?: number | null
    kills?: number | null
    lane?: string
    largestCriticalStrike?: number | null
    largestKillingSpree?: number | null
    largestMultiKill?: number | null
    longestTimeSpentLiving?: number | null
    magicDamageDealt?: number | null
    magicDamageDealtToChampions?: number | null
    magicDamageTaken?: number | null
    neutralMinionsKilled?: number | null
    nexusKills?: number | null
    nexusLost?: number | null
    nexusTakedowns?: number | null
    objectivesStolen?: number | null
    objectivesStolenAssists?: number | null
    participantId?: number | null
    pentaKills?: number | null
    physicalDamageDealt?: number | null
    physicalDamageDealtToChampions?: number | null
    physicalDamageTaken?: number | null
    quadraKills?: number | null
    riotIdName?: string
    riotIdTagline?: string
    role?: string
    sightWardsBoughtInGame?: number | null
    spell1Casts?: number | null
    spell2Casts?: number | null
    spell3Casts?: number | null
    spell4Casts?: number | null
    summoner1Casts?: number | null
    summoner1Id?: number | null
    summoner2Casts?: number | null
    summoner2Id?: number | null
    summonerLevel?: number | null
    summonerName?: string
    teamEarlySurrendered?: boolean
    teamId?: number | null
    teamPosition?: string
    timeCCingOthers?: number | null
    timePlayed?: number | null
    totalDamageDealt?: number | null
    totalDamageDealtToChampions?: number | null
    totalDamageShieldedOnTeammates?: number | null
    totalDamageTaken?: number | null
    totalHeal?: number | null
    totalHealsOnTeammates?: number | null
    totalMinionsKilled?: number | null
    totalTimeCCDealt?: number | null
    totalTimeSpentDead?: number | null
    totalUnitsHealed?: number | null
    tripleKills?: number | null
    trueDamageDealt?: number | null
    trueDamageDealtToChampions?: number | null
    trueDamageTaken?: number | null
    turretsKilled?: number | null
    turretTakedowns?: number | null
    turretsLost?: number | null
    unrealKills?: number | null
    visionScore?: number | null
    visionWardsBoughtInGame?: number | null
    wardsKilled?: number | null
    wardsPlaced?: number | null
    win?: boolean
  }

  export type PlayerEndOfGameStatUncheckedCreateWithoutPerksInput = {
    id?: string
    playerId?: string | null
    gameId?: string | null
    itemsId?: string | null
    assists?: number | null
    baronKills?: number | null
    bountyLevel?: number | null
    championExperience?: number | null
    championLevel?: number | null
    championId?: number | null
    championName?: string
    championTransform?: number | null
    consumablesPurchased?: number | null
    damageDealtToBuildings?: number | null
    damageDealtToObjectives?: number | null
    damageDealtToTurrets?: number | null
    damageSelfMitigated?: number | null
    deaths?: number | null
    detectorWardsPlaced?: number | null
    doubleKills?: number | null
    dragonKills?: number | null
    firstBlood?: boolean
    firstBloodAssist?: boolean
    firstTowerKill?: boolean
    firstTowerAssist?: boolean
    gameEndedInEarlySurrender?: boolean
    gameEndedInSurrender?: boolean
    goldEarned?: number | null
    goldSpent?: number | null
    individualPosition?: string
    inhibitorKills?: number | null
    inhibitorTakedowns?: number | null
    inhibitorsLost?: number | null
    item0?: number | null
    item1?: number | null
    item2?: number | null
    item3?: number | null
    item4?: number | null
    item5?: number | null
    item6?: number | null
    itemsPurchased?: number | null
    killingSprees?: number | null
    kills?: number | null
    lane?: string
    largestCriticalStrike?: number | null
    largestKillingSpree?: number | null
    largestMultiKill?: number | null
    longestTimeSpentLiving?: number | null
    magicDamageDealt?: number | null
    magicDamageDealtToChampions?: number | null
    magicDamageTaken?: number | null
    neutralMinionsKilled?: number | null
    nexusKills?: number | null
    nexusLost?: number | null
    nexusTakedowns?: number | null
    objectivesStolen?: number | null
    objectivesStolenAssists?: number | null
    participantId?: number | null
    pentaKills?: number | null
    physicalDamageDealt?: number | null
    physicalDamageDealtToChampions?: number | null
    physicalDamageTaken?: number | null
    quadraKills?: number | null
    riotIdName?: string
    riotIdTagline?: string
    role?: string
    sightWardsBoughtInGame?: number | null
    spell1Casts?: number | null
    spell2Casts?: number | null
    spell3Casts?: number | null
    spell4Casts?: number | null
    summoner1Casts?: number | null
    summoner1Id?: number | null
    summoner2Casts?: number | null
    summoner2Id?: number | null
    summonerLevel?: number | null
    summonerName?: string
    teamEarlySurrendered?: boolean
    teamId?: number | null
    teamPosition?: string
    timeCCingOthers?: number | null
    timePlayed?: number | null
    totalDamageDealt?: number | null
    totalDamageDealtToChampions?: number | null
    totalDamageShieldedOnTeammates?: number | null
    totalDamageTaken?: number | null
    totalHeal?: number | null
    totalHealsOnTeammates?: number | null
    totalMinionsKilled?: number | null
    totalTimeCCDealt?: number | null
    totalTimeSpentDead?: number | null
    totalUnitsHealed?: number | null
    tripleKills?: number | null
    trueDamageDealt?: number | null
    trueDamageDealtToChampions?: number | null
    trueDamageTaken?: number | null
    turretsKilled?: number | null
    turretTakedowns?: number | null
    turretsLost?: number | null
    unrealKills?: number | null
    visionScore?: number | null
    visionWardsBoughtInGame?: number | null
    wardsKilled?: number | null
    wardsPlaced?: number | null
    win?: boolean
  }

  export type PlayerEndOfGameStatCreateOrConnectWithoutPerksInput = {
    where: PlayerEndOfGameStatWhereUniqueInput
    create: XOR<PlayerEndOfGameStatCreateWithoutPerksInput, PlayerEndOfGameStatUncheckedCreateWithoutPerksInput>
  }

  export type RuneStyleCreateWithoutPlayerRunesInput = {
    id?: string
    selection?: RuneSelectionCreateNestedManyWithoutRuneStyleInput
    description?: string
    style?: number | null
  }

  export type RuneStyleUncheckedCreateWithoutPlayerRunesInput = {
    id?: string
    selection?: RuneSelectionUncheckedCreateNestedManyWithoutRuneStyleInput
    description?: string
    style?: number | null
  }

  export type RuneStyleCreateOrConnectWithoutPlayerRunesInput = {
    where: RuneStyleWhereUniqueInput
    create: XOR<RuneStyleCreateWithoutPlayerRunesInput, RuneStyleUncheckedCreateWithoutPlayerRunesInput>
  }

  export type RuneStyleCreateManyPlayerRunesInputEnvelope = {
    data: Enumerable<RuneStyleCreateManyPlayerRunesInput>
    skipDuplicates?: boolean
  }

  export type PlayerEndOfGameStatUpsertWithoutPerksInput = {
    update: XOR<PlayerEndOfGameStatUpdateWithoutPerksInput, PlayerEndOfGameStatUncheckedUpdateWithoutPerksInput>
    create: XOR<PlayerEndOfGameStatCreateWithoutPerksInput, PlayerEndOfGameStatUncheckedCreateWithoutPerksInput>
  }

  export type PlayerEndOfGameStatUpdateWithoutPerksInput = {
    id?: StringFieldUpdateOperationsInput | string
    player?: PlayerUpdateOneWithoutEndOfGameStatsInput
    game?: GameUpdateOneWithoutFrom_PlayerEndOfGameStat_gameInput
    items?: PlayerItemUpdateOneWithoutPlayerEndOfGameStatInput
    assists?: NullableIntFieldUpdateOperationsInput | number | null
    baronKills?: NullableIntFieldUpdateOperationsInput | number | null
    bountyLevel?: NullableIntFieldUpdateOperationsInput | number | null
    championExperience?: NullableIntFieldUpdateOperationsInput | number | null
    championLevel?: NullableIntFieldUpdateOperationsInput | number | null
    championId?: NullableIntFieldUpdateOperationsInput | number | null
    championName?: StringFieldUpdateOperationsInput | string
    championTransform?: NullableIntFieldUpdateOperationsInput | number | null
    consumablesPurchased?: NullableIntFieldUpdateOperationsInput | number | null
    damageDealtToBuildings?: NullableIntFieldUpdateOperationsInput | number | null
    damageDealtToObjectives?: NullableIntFieldUpdateOperationsInput | number | null
    damageDealtToTurrets?: NullableIntFieldUpdateOperationsInput | number | null
    damageSelfMitigated?: NullableIntFieldUpdateOperationsInput | number | null
    deaths?: NullableIntFieldUpdateOperationsInput | number | null
    detectorWardsPlaced?: NullableIntFieldUpdateOperationsInput | number | null
    doubleKills?: NullableIntFieldUpdateOperationsInput | number | null
    dragonKills?: NullableIntFieldUpdateOperationsInput | number | null
    firstBlood?: BoolFieldUpdateOperationsInput | boolean
    firstBloodAssist?: BoolFieldUpdateOperationsInput | boolean
    firstTowerKill?: BoolFieldUpdateOperationsInput | boolean
    firstTowerAssist?: BoolFieldUpdateOperationsInput | boolean
    gameEndedInEarlySurrender?: BoolFieldUpdateOperationsInput | boolean
    gameEndedInSurrender?: BoolFieldUpdateOperationsInput | boolean
    goldEarned?: NullableIntFieldUpdateOperationsInput | number | null
    goldSpent?: NullableIntFieldUpdateOperationsInput | number | null
    individualPosition?: StringFieldUpdateOperationsInput | string
    inhibitorKills?: NullableIntFieldUpdateOperationsInput | number | null
    inhibitorTakedowns?: NullableIntFieldUpdateOperationsInput | number | null
    inhibitorsLost?: NullableIntFieldUpdateOperationsInput | number | null
    item0?: NullableIntFieldUpdateOperationsInput | number | null
    item1?: NullableIntFieldUpdateOperationsInput | number | null
    item2?: NullableIntFieldUpdateOperationsInput | number | null
    item3?: NullableIntFieldUpdateOperationsInput | number | null
    item4?: NullableIntFieldUpdateOperationsInput | number | null
    item5?: NullableIntFieldUpdateOperationsInput | number | null
    item6?: NullableIntFieldUpdateOperationsInput | number | null
    itemsPurchased?: NullableIntFieldUpdateOperationsInput | number | null
    killingSprees?: NullableIntFieldUpdateOperationsInput | number | null
    kills?: NullableIntFieldUpdateOperationsInput | number | null
    lane?: StringFieldUpdateOperationsInput | string
    largestCriticalStrike?: NullableIntFieldUpdateOperationsInput | number | null
    largestKillingSpree?: NullableIntFieldUpdateOperationsInput | number | null
    largestMultiKill?: NullableIntFieldUpdateOperationsInput | number | null
    longestTimeSpentLiving?: NullableIntFieldUpdateOperationsInput | number | null
    magicDamageDealt?: NullableIntFieldUpdateOperationsInput | number | null
    magicDamageDealtToChampions?: NullableIntFieldUpdateOperationsInput | number | null
    magicDamageTaken?: NullableIntFieldUpdateOperationsInput | number | null
    neutralMinionsKilled?: NullableIntFieldUpdateOperationsInput | number | null
    nexusKills?: NullableIntFieldUpdateOperationsInput | number | null
    nexusLost?: NullableIntFieldUpdateOperationsInput | number | null
    nexusTakedowns?: NullableIntFieldUpdateOperationsInput | number | null
    objectivesStolen?: NullableIntFieldUpdateOperationsInput | number | null
    objectivesStolenAssists?: NullableIntFieldUpdateOperationsInput | number | null
    participantId?: NullableIntFieldUpdateOperationsInput | number | null
    pentaKills?: NullableIntFieldUpdateOperationsInput | number | null
    physicalDamageDealt?: NullableIntFieldUpdateOperationsInput | number | null
    physicalDamageDealtToChampions?: NullableIntFieldUpdateOperationsInput | number | null
    physicalDamageTaken?: NullableIntFieldUpdateOperationsInput | number | null
    quadraKills?: NullableIntFieldUpdateOperationsInput | number | null
    riotIdName?: StringFieldUpdateOperationsInput | string
    riotIdTagline?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    sightWardsBoughtInGame?: NullableIntFieldUpdateOperationsInput | number | null
    spell1Casts?: NullableIntFieldUpdateOperationsInput | number | null
    spell2Casts?: NullableIntFieldUpdateOperationsInput | number | null
    spell3Casts?: NullableIntFieldUpdateOperationsInput | number | null
    spell4Casts?: NullableIntFieldUpdateOperationsInput | number | null
    summoner1Casts?: NullableIntFieldUpdateOperationsInput | number | null
    summoner1Id?: NullableIntFieldUpdateOperationsInput | number | null
    summoner2Casts?: NullableIntFieldUpdateOperationsInput | number | null
    summoner2Id?: NullableIntFieldUpdateOperationsInput | number | null
    summonerLevel?: NullableIntFieldUpdateOperationsInput | number | null
    summonerName?: StringFieldUpdateOperationsInput | string
    teamEarlySurrendered?: BoolFieldUpdateOperationsInput | boolean
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    teamPosition?: StringFieldUpdateOperationsInput | string
    timeCCingOthers?: NullableIntFieldUpdateOperationsInput | number | null
    timePlayed?: NullableIntFieldUpdateOperationsInput | number | null
    totalDamageDealt?: NullableIntFieldUpdateOperationsInput | number | null
    totalDamageDealtToChampions?: NullableIntFieldUpdateOperationsInput | number | null
    totalDamageShieldedOnTeammates?: NullableIntFieldUpdateOperationsInput | number | null
    totalDamageTaken?: NullableIntFieldUpdateOperationsInput | number | null
    totalHeal?: NullableIntFieldUpdateOperationsInput | number | null
    totalHealsOnTeammates?: NullableIntFieldUpdateOperationsInput | number | null
    totalMinionsKilled?: NullableIntFieldUpdateOperationsInput | number | null
    totalTimeCCDealt?: NullableIntFieldUpdateOperationsInput | number | null
    totalTimeSpentDead?: NullableIntFieldUpdateOperationsInput | number | null
    totalUnitsHealed?: NullableIntFieldUpdateOperationsInput | number | null
    tripleKills?: NullableIntFieldUpdateOperationsInput | number | null
    trueDamageDealt?: NullableIntFieldUpdateOperationsInput | number | null
    trueDamageDealtToChampions?: NullableIntFieldUpdateOperationsInput | number | null
    trueDamageTaken?: NullableIntFieldUpdateOperationsInput | number | null
    turretsKilled?: NullableIntFieldUpdateOperationsInput | number | null
    turretTakedowns?: NullableIntFieldUpdateOperationsInput | number | null
    turretsLost?: NullableIntFieldUpdateOperationsInput | number | null
    unrealKills?: NullableIntFieldUpdateOperationsInput | number | null
    visionScore?: NullableIntFieldUpdateOperationsInput | number | null
    visionWardsBoughtInGame?: NullableIntFieldUpdateOperationsInput | number | null
    wardsKilled?: NullableIntFieldUpdateOperationsInput | number | null
    wardsPlaced?: NullableIntFieldUpdateOperationsInput | number | null
    win?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PlayerEndOfGameStatUncheckedUpdateWithoutPerksInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: NullableStringFieldUpdateOperationsInput | string | null
    gameId?: NullableStringFieldUpdateOperationsInput | string | null
    itemsId?: NullableStringFieldUpdateOperationsInput | string | null
    assists?: NullableIntFieldUpdateOperationsInput | number | null
    baronKills?: NullableIntFieldUpdateOperationsInput | number | null
    bountyLevel?: NullableIntFieldUpdateOperationsInput | number | null
    championExperience?: NullableIntFieldUpdateOperationsInput | number | null
    championLevel?: NullableIntFieldUpdateOperationsInput | number | null
    championId?: NullableIntFieldUpdateOperationsInput | number | null
    championName?: StringFieldUpdateOperationsInput | string
    championTransform?: NullableIntFieldUpdateOperationsInput | number | null
    consumablesPurchased?: NullableIntFieldUpdateOperationsInput | number | null
    damageDealtToBuildings?: NullableIntFieldUpdateOperationsInput | number | null
    damageDealtToObjectives?: NullableIntFieldUpdateOperationsInput | number | null
    damageDealtToTurrets?: NullableIntFieldUpdateOperationsInput | number | null
    damageSelfMitigated?: NullableIntFieldUpdateOperationsInput | number | null
    deaths?: NullableIntFieldUpdateOperationsInput | number | null
    detectorWardsPlaced?: NullableIntFieldUpdateOperationsInput | number | null
    doubleKills?: NullableIntFieldUpdateOperationsInput | number | null
    dragonKills?: NullableIntFieldUpdateOperationsInput | number | null
    firstBlood?: BoolFieldUpdateOperationsInput | boolean
    firstBloodAssist?: BoolFieldUpdateOperationsInput | boolean
    firstTowerKill?: BoolFieldUpdateOperationsInput | boolean
    firstTowerAssist?: BoolFieldUpdateOperationsInput | boolean
    gameEndedInEarlySurrender?: BoolFieldUpdateOperationsInput | boolean
    gameEndedInSurrender?: BoolFieldUpdateOperationsInput | boolean
    goldEarned?: NullableIntFieldUpdateOperationsInput | number | null
    goldSpent?: NullableIntFieldUpdateOperationsInput | number | null
    individualPosition?: StringFieldUpdateOperationsInput | string
    inhibitorKills?: NullableIntFieldUpdateOperationsInput | number | null
    inhibitorTakedowns?: NullableIntFieldUpdateOperationsInput | number | null
    inhibitorsLost?: NullableIntFieldUpdateOperationsInput | number | null
    item0?: NullableIntFieldUpdateOperationsInput | number | null
    item1?: NullableIntFieldUpdateOperationsInput | number | null
    item2?: NullableIntFieldUpdateOperationsInput | number | null
    item3?: NullableIntFieldUpdateOperationsInput | number | null
    item4?: NullableIntFieldUpdateOperationsInput | number | null
    item5?: NullableIntFieldUpdateOperationsInput | number | null
    item6?: NullableIntFieldUpdateOperationsInput | number | null
    itemsPurchased?: NullableIntFieldUpdateOperationsInput | number | null
    killingSprees?: NullableIntFieldUpdateOperationsInput | number | null
    kills?: NullableIntFieldUpdateOperationsInput | number | null
    lane?: StringFieldUpdateOperationsInput | string
    largestCriticalStrike?: NullableIntFieldUpdateOperationsInput | number | null
    largestKillingSpree?: NullableIntFieldUpdateOperationsInput | number | null
    largestMultiKill?: NullableIntFieldUpdateOperationsInput | number | null
    longestTimeSpentLiving?: NullableIntFieldUpdateOperationsInput | number | null
    magicDamageDealt?: NullableIntFieldUpdateOperationsInput | number | null
    magicDamageDealtToChampions?: NullableIntFieldUpdateOperationsInput | number | null
    magicDamageTaken?: NullableIntFieldUpdateOperationsInput | number | null
    neutralMinionsKilled?: NullableIntFieldUpdateOperationsInput | number | null
    nexusKills?: NullableIntFieldUpdateOperationsInput | number | null
    nexusLost?: NullableIntFieldUpdateOperationsInput | number | null
    nexusTakedowns?: NullableIntFieldUpdateOperationsInput | number | null
    objectivesStolen?: NullableIntFieldUpdateOperationsInput | number | null
    objectivesStolenAssists?: NullableIntFieldUpdateOperationsInput | number | null
    participantId?: NullableIntFieldUpdateOperationsInput | number | null
    pentaKills?: NullableIntFieldUpdateOperationsInput | number | null
    physicalDamageDealt?: NullableIntFieldUpdateOperationsInput | number | null
    physicalDamageDealtToChampions?: NullableIntFieldUpdateOperationsInput | number | null
    physicalDamageTaken?: NullableIntFieldUpdateOperationsInput | number | null
    quadraKills?: NullableIntFieldUpdateOperationsInput | number | null
    riotIdName?: StringFieldUpdateOperationsInput | string
    riotIdTagline?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    sightWardsBoughtInGame?: NullableIntFieldUpdateOperationsInput | number | null
    spell1Casts?: NullableIntFieldUpdateOperationsInput | number | null
    spell2Casts?: NullableIntFieldUpdateOperationsInput | number | null
    spell3Casts?: NullableIntFieldUpdateOperationsInput | number | null
    spell4Casts?: NullableIntFieldUpdateOperationsInput | number | null
    summoner1Casts?: NullableIntFieldUpdateOperationsInput | number | null
    summoner1Id?: NullableIntFieldUpdateOperationsInput | number | null
    summoner2Casts?: NullableIntFieldUpdateOperationsInput | number | null
    summoner2Id?: NullableIntFieldUpdateOperationsInput | number | null
    summonerLevel?: NullableIntFieldUpdateOperationsInput | number | null
    summonerName?: StringFieldUpdateOperationsInput | string
    teamEarlySurrendered?: BoolFieldUpdateOperationsInput | boolean
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    teamPosition?: StringFieldUpdateOperationsInput | string
    timeCCingOthers?: NullableIntFieldUpdateOperationsInput | number | null
    timePlayed?: NullableIntFieldUpdateOperationsInput | number | null
    totalDamageDealt?: NullableIntFieldUpdateOperationsInput | number | null
    totalDamageDealtToChampions?: NullableIntFieldUpdateOperationsInput | number | null
    totalDamageShieldedOnTeammates?: NullableIntFieldUpdateOperationsInput | number | null
    totalDamageTaken?: NullableIntFieldUpdateOperationsInput | number | null
    totalHeal?: NullableIntFieldUpdateOperationsInput | number | null
    totalHealsOnTeammates?: NullableIntFieldUpdateOperationsInput | number | null
    totalMinionsKilled?: NullableIntFieldUpdateOperationsInput | number | null
    totalTimeCCDealt?: NullableIntFieldUpdateOperationsInput | number | null
    totalTimeSpentDead?: NullableIntFieldUpdateOperationsInput | number | null
    totalUnitsHealed?: NullableIntFieldUpdateOperationsInput | number | null
    tripleKills?: NullableIntFieldUpdateOperationsInput | number | null
    trueDamageDealt?: NullableIntFieldUpdateOperationsInput | number | null
    trueDamageDealtToChampions?: NullableIntFieldUpdateOperationsInput | number | null
    trueDamageTaken?: NullableIntFieldUpdateOperationsInput | number | null
    turretsKilled?: NullableIntFieldUpdateOperationsInput | number | null
    turretTakedowns?: NullableIntFieldUpdateOperationsInput | number | null
    turretsLost?: NullableIntFieldUpdateOperationsInput | number | null
    unrealKills?: NullableIntFieldUpdateOperationsInput | number | null
    visionScore?: NullableIntFieldUpdateOperationsInput | number | null
    visionWardsBoughtInGame?: NullableIntFieldUpdateOperationsInput | number | null
    wardsKilled?: NullableIntFieldUpdateOperationsInput | number | null
    wardsPlaced?: NullableIntFieldUpdateOperationsInput | number | null
    win?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RuneStyleUpsertWithWhereUniqueWithoutPlayerRunesInput = {
    where: RuneStyleWhereUniqueInput
    update: XOR<RuneStyleUpdateWithoutPlayerRunesInput, RuneStyleUncheckedUpdateWithoutPlayerRunesInput>
    create: XOR<RuneStyleCreateWithoutPlayerRunesInput, RuneStyleUncheckedCreateWithoutPlayerRunesInput>
  }

  export type RuneStyleUpdateWithWhereUniqueWithoutPlayerRunesInput = {
    where: RuneStyleWhereUniqueInput
    data: XOR<RuneStyleUpdateWithoutPlayerRunesInput, RuneStyleUncheckedUpdateWithoutPlayerRunesInput>
  }

  export type RuneStyleUpdateManyWithWhereWithoutPlayerRunesInput = {
    where: RuneStyleScalarWhereInput
    data: XOR<RuneStyleUpdateManyMutationInput, RuneStyleUncheckedUpdateManyWithoutRuneStyleInput>
  }

  export type RuneStyleScalarWhereInput = {
    AND?: Enumerable<RuneStyleScalarWhereInput>
    OR?: Enumerable<RuneStyleScalarWhereInput>
    NOT?: Enumerable<RuneStyleScalarWhereInput>
    id?: StringFilter | string
    playerRunesId?: StringNullableFilter | string | null
    description?: StringFilter | string
    style?: IntNullableFilter | number | null
  }

  export type PlayerCreateWithoutSkillLevelUpEventsInput = {
    id?: string
    puuid?: string
    accountId?: string
    platformId?: string
    summonerId?: string
    summonerName?: string
    summonerLevel?: number | null
    profileIconId?: number | null
    revisionDate?: string
    kills?: PlayerKillCreateNestedManyWithoutKillerInput
    deaths?: PlayerKillCreateNestedManyWithoutVictimInput
    teams?: TeamCreateNestedManyWithoutPlayersInput
    profile?: ProfileCreateNestedOneWithoutPlayerInput
    monsterKills?: TeamMonsterKillCreateNestedManyWithoutKillerInput
    buildingKills?: TeamBuildingKillCreateNestedManyWithoutKillerInput
    itemEvent?: PlayerItemEventCreateNestedManyWithoutPlayerInput
    endOfGameStats?: PlayerEndOfGameStatCreateNestedManyWithoutPlayerInput
    snapshots?: PlayerSnapshotCreateNestedManyWithoutPlayerInput
    wardEvents?: PlayerWardEventCreateNestedManyWithoutPlayerInput
  }

  export type PlayerUncheckedCreateWithoutSkillLevelUpEventsInput = {
    id?: string
    puuid?: string
    accountId?: string
    platformId?: string
    summonerId?: string
    summonerName?: string
    summonerLevel?: number | null
    profileIconId?: number | null
    revisionDate?: string
    kills?: PlayerKillUncheckedCreateNestedManyWithoutKillerInput
    deaths?: PlayerKillUncheckedCreateNestedManyWithoutVictimInput
    teams?: TeamUncheckedCreateNestedManyWithoutPlayersInput
    profileId?: string | null
    monsterKills?: TeamMonsterKillUncheckedCreateNestedManyWithoutKillerInput
    buildingKills?: TeamBuildingKillUncheckedCreateNestedManyWithoutKillerInput
    itemEvent?: PlayerItemEventUncheckedCreateNestedManyWithoutPlayerInput
    endOfGameStats?: PlayerEndOfGameStatUncheckedCreateNestedManyWithoutPlayerInput
    snapshots?: PlayerSnapshotUncheckedCreateNestedManyWithoutPlayerInput
    wardEvents?: PlayerWardEventUncheckedCreateNestedManyWithoutPlayerInput
  }

  export type PlayerCreateOrConnectWithoutSkillLevelUpEventsInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutSkillLevelUpEventsInput, PlayerUncheckedCreateWithoutSkillLevelUpEventsInput>
  }

  export type PlayerUpsertWithWhereUniqueWithoutSkillLevelUpEventsInput = {
    where: PlayerWhereUniqueInput
    update: XOR<PlayerUpdateWithoutSkillLevelUpEventsInput, PlayerUncheckedUpdateWithoutSkillLevelUpEventsInput>
    create: XOR<PlayerCreateWithoutSkillLevelUpEventsInput, PlayerUncheckedCreateWithoutSkillLevelUpEventsInput>
  }

  export type PlayerUpdateWithWhereUniqueWithoutSkillLevelUpEventsInput = {
    where: PlayerWhereUniqueInput
    data: XOR<PlayerUpdateWithoutSkillLevelUpEventsInput, PlayerUncheckedUpdateWithoutSkillLevelUpEventsInput>
  }

  export type PlayerUpdateManyWithWhereWithoutSkillLevelUpEventsInput = {
    where: PlayerScalarWhereInput
    data: XOR<PlayerUpdateManyMutationInput, PlayerUncheckedUpdateManyWithoutPlayerInput>
  }

  export type PositionCreateWithoutPlayerSnapshotInput = {
    id?: string
    event?: EventCreateNestedManyWithoutPositionInput
    x?: number | null
    y?: number | null
  }

  export type PositionUncheckedCreateWithoutPlayerSnapshotInput = {
    id?: string
    event?: EventUncheckedCreateNestedManyWithoutPositionInput
    x?: number | null
    y?: number | null
  }

  export type PositionCreateOrConnectWithoutPlayerSnapshotInput = {
    where: PositionWhereUniqueInput
    create: XOR<PositionCreateWithoutPlayerSnapshotInput, PositionUncheckedCreateWithoutPlayerSnapshotInput>
  }

  export type PlayerCreateWithoutSnapshotsInput = {
    id?: string
    puuid?: string
    accountId?: string
    platformId?: string
    summonerId?: string
    summonerName?: string
    summonerLevel?: number | null
    profileIconId?: number | null
    revisionDate?: string
    kills?: PlayerKillCreateNestedManyWithoutKillerInput
    deaths?: PlayerKillCreateNestedManyWithoutVictimInput
    teams?: TeamCreateNestedManyWithoutPlayersInput
    profile?: ProfileCreateNestedOneWithoutPlayerInput
    monsterKills?: TeamMonsterKillCreateNestedManyWithoutKillerInput
    buildingKills?: TeamBuildingKillCreateNestedManyWithoutKillerInput
    itemEvent?: PlayerItemEventCreateNestedManyWithoutPlayerInput
    endOfGameStats?: PlayerEndOfGameStatCreateNestedManyWithoutPlayerInput
    wardEvents?: PlayerWardEventCreateNestedManyWithoutPlayerInput
    skillLevelUpEvents?: PlayerSkillLevelUpEventCreateNestedManyWithoutPlayerInput
  }

  export type PlayerUncheckedCreateWithoutSnapshotsInput = {
    id?: string
    puuid?: string
    accountId?: string
    platformId?: string
    summonerId?: string
    summonerName?: string
    summonerLevel?: number | null
    profileIconId?: number | null
    revisionDate?: string
    kills?: PlayerKillUncheckedCreateNestedManyWithoutKillerInput
    deaths?: PlayerKillUncheckedCreateNestedManyWithoutVictimInput
    teams?: TeamUncheckedCreateNestedManyWithoutPlayersInput
    profileId?: string | null
    monsterKills?: TeamMonsterKillUncheckedCreateNestedManyWithoutKillerInput
    buildingKills?: TeamBuildingKillUncheckedCreateNestedManyWithoutKillerInput
    itemEvent?: PlayerItemEventUncheckedCreateNestedManyWithoutPlayerInput
    endOfGameStats?: PlayerEndOfGameStatUncheckedCreateNestedManyWithoutPlayerInput
    wardEvents?: PlayerWardEventUncheckedCreateNestedManyWithoutPlayerInput
    skillLevelUpEvents?: PlayerSkillLevelUpEventUncheckedCreateNestedManyWithoutPlayerInput
  }

  export type PlayerCreateOrConnectWithoutSnapshotsInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutSnapshotsInput, PlayerUncheckedCreateWithoutSnapshotsInput>
  }

  export type PositionUpsertWithWhereUniqueWithoutPlayerSnapshotInput = {
    where: PositionWhereUniqueInput
    update: XOR<PositionUpdateWithoutPlayerSnapshotInput, PositionUncheckedUpdateWithoutPlayerSnapshotInput>
    create: XOR<PositionCreateWithoutPlayerSnapshotInput, PositionUncheckedCreateWithoutPlayerSnapshotInput>
  }

  export type PositionUpdateWithWhereUniqueWithoutPlayerSnapshotInput = {
    where: PositionWhereUniqueInput
    data: XOR<PositionUpdateWithoutPlayerSnapshotInput, PositionUncheckedUpdateWithoutPlayerSnapshotInput>
  }

  export type PositionUpdateManyWithWhereWithoutPlayerSnapshotInput = {
    where: PositionScalarWhereInput
    data: XOR<PositionUpdateManyMutationInput, PositionUncheckedUpdateManyWithoutPositionInput>
  }

  export type PlayerUpsertWithWhereUniqueWithoutSnapshotsInput = {
    where: PlayerWhereUniqueInput
    update: XOR<PlayerUpdateWithoutSnapshotsInput, PlayerUncheckedUpdateWithoutSnapshotsInput>
    create: XOR<PlayerCreateWithoutSnapshotsInput, PlayerUncheckedCreateWithoutSnapshotsInput>
  }

  export type PlayerUpdateWithWhereUniqueWithoutSnapshotsInput = {
    where: PlayerWhereUniqueInput
    data: XOR<PlayerUpdateWithoutSnapshotsInput, PlayerUncheckedUpdateWithoutSnapshotsInput>
  }

  export type PlayerUpdateManyWithWhereWithoutSnapshotsInput = {
    where: PlayerScalarWhereInput
    data: XOR<PlayerUpdateManyMutationInput, PlayerUncheckedUpdateManyWithoutPlayerInput>
  }

  export type PlayerCreateWithoutWardEventsInput = {
    id?: string
    puuid?: string
    accountId?: string
    platformId?: string
    summonerId?: string
    summonerName?: string
    summonerLevel?: number | null
    profileIconId?: number | null
    revisionDate?: string
    kills?: PlayerKillCreateNestedManyWithoutKillerInput
    deaths?: PlayerKillCreateNestedManyWithoutVictimInput
    teams?: TeamCreateNestedManyWithoutPlayersInput
    profile?: ProfileCreateNestedOneWithoutPlayerInput
    monsterKills?: TeamMonsterKillCreateNestedManyWithoutKillerInput
    buildingKills?: TeamBuildingKillCreateNestedManyWithoutKillerInput
    itemEvent?: PlayerItemEventCreateNestedManyWithoutPlayerInput
    endOfGameStats?: PlayerEndOfGameStatCreateNestedManyWithoutPlayerInput
    snapshots?: PlayerSnapshotCreateNestedManyWithoutPlayerInput
    skillLevelUpEvents?: PlayerSkillLevelUpEventCreateNestedManyWithoutPlayerInput
  }

  export type PlayerUncheckedCreateWithoutWardEventsInput = {
    id?: string
    puuid?: string
    accountId?: string
    platformId?: string
    summonerId?: string
    summonerName?: string
    summonerLevel?: number | null
    profileIconId?: number | null
    revisionDate?: string
    kills?: PlayerKillUncheckedCreateNestedManyWithoutKillerInput
    deaths?: PlayerKillUncheckedCreateNestedManyWithoutVictimInput
    teams?: TeamUncheckedCreateNestedManyWithoutPlayersInput
    profileId?: string | null
    monsterKills?: TeamMonsterKillUncheckedCreateNestedManyWithoutKillerInput
    buildingKills?: TeamBuildingKillUncheckedCreateNestedManyWithoutKillerInput
    itemEvent?: PlayerItemEventUncheckedCreateNestedManyWithoutPlayerInput
    endOfGameStats?: PlayerEndOfGameStatUncheckedCreateNestedManyWithoutPlayerInput
    snapshots?: PlayerSnapshotUncheckedCreateNestedManyWithoutPlayerInput
    skillLevelUpEvents?: PlayerSkillLevelUpEventUncheckedCreateNestedManyWithoutPlayerInput
  }

  export type PlayerCreateOrConnectWithoutWardEventsInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutWardEventsInput, PlayerUncheckedCreateWithoutWardEventsInput>
  }

  export type PlayerUpsertWithWhereUniqueWithoutWardEventsInput = {
    where: PlayerWhereUniqueInput
    update: XOR<PlayerUpdateWithoutWardEventsInput, PlayerUncheckedUpdateWithoutWardEventsInput>
    create: XOR<PlayerCreateWithoutWardEventsInput, PlayerUncheckedCreateWithoutWardEventsInput>
  }

  export type PlayerUpdateWithWhereUniqueWithoutWardEventsInput = {
    where: PlayerWhereUniqueInput
    data: XOR<PlayerUpdateWithoutWardEventsInput, PlayerUncheckedUpdateWithoutWardEventsInput>
  }

  export type PlayerUpdateManyWithWhereWithoutWardEventsInput = {
    where: PlayerScalarWhereInput
    data: XOR<PlayerUpdateManyMutationInput, PlayerUncheckedUpdateManyWithoutPlayerInput>
  }

  export type EventCreateWithoutPositionInput = {
    id?: string
    timestamp?: number | null
  }

  export type EventUncheckedCreateWithoutPositionInput = {
    id?: string
    timestamp?: number | null
  }

  export type EventCreateOrConnectWithoutPositionInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutPositionInput, EventUncheckedCreateWithoutPositionInput>
  }

  export type PlayerSnapshotCreateWithoutPositionInput = {
    id?: string
    timestamp?: number | null
    currentGold?: number | null
    totalGold?: number | null
    totalGoldDiff?: number | null
    xp?: number | null
    xpDiff?: number | null
    level?: number | null
    cs?: number | null
    csDiff?: number | null
    monstersKilled?: number | null
    monstersKilledDiff?: number | null
    player?: PlayerCreateNestedManyWithoutSnapshotsInput
  }

  export type PlayerSnapshotUncheckedCreateWithoutPositionInput = {
    id?: string
    timestamp?: number | null
    currentGold?: number | null
    totalGold?: number | null
    totalGoldDiff?: number | null
    xp?: number | null
    xpDiff?: number | null
    level?: number | null
    cs?: number | null
    csDiff?: number | null
    monstersKilled?: number | null
    monstersKilledDiff?: number | null
    player?: PlayerUncheckedCreateNestedManyWithoutSnapshotsInput
  }

  export type PlayerSnapshotCreateOrConnectWithoutPositionInput = {
    where: PlayerSnapshotWhereUniqueInput
    create: XOR<PlayerSnapshotCreateWithoutPositionInput, PlayerSnapshotUncheckedCreateWithoutPositionInput>
  }

  export type EventUpsertWithWhereUniqueWithoutPositionInput = {
    where: EventWhereUniqueInput
    update: XOR<EventUpdateWithoutPositionInput, EventUncheckedUpdateWithoutPositionInput>
    create: XOR<EventCreateWithoutPositionInput, EventUncheckedCreateWithoutPositionInput>
  }

  export type EventUpdateWithWhereUniqueWithoutPositionInput = {
    where: EventWhereUniqueInput
    data: XOR<EventUpdateWithoutPositionInput, EventUncheckedUpdateWithoutPositionInput>
  }

  export type EventUpdateManyWithWhereWithoutPositionInput = {
    where: EventScalarWhereInput
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyWithoutEventInput>
  }

  export type EventScalarWhereInput = {
    AND?: Enumerable<EventScalarWhereInput>
    OR?: Enumerable<EventScalarWhereInput>
    NOT?: Enumerable<EventScalarWhereInput>
    id?: StringFilter | string
    timestamp?: IntNullableFilter | number | null
  }

  export type PlayerSnapshotUpsertWithWhereUniqueWithoutPositionInput = {
    where: PlayerSnapshotWhereUniqueInput
    update: XOR<PlayerSnapshotUpdateWithoutPositionInput, PlayerSnapshotUncheckedUpdateWithoutPositionInput>
    create: XOR<PlayerSnapshotCreateWithoutPositionInput, PlayerSnapshotUncheckedCreateWithoutPositionInput>
  }

  export type PlayerSnapshotUpdateWithWhereUniqueWithoutPositionInput = {
    where: PlayerSnapshotWhereUniqueInput
    data: XOR<PlayerSnapshotUpdateWithoutPositionInput, PlayerSnapshotUncheckedUpdateWithoutPositionInput>
  }

  export type PlayerSnapshotUpdateManyWithWhereWithoutPositionInput = {
    where: PlayerSnapshotScalarWhereInput
    data: XOR<PlayerSnapshotUpdateManyMutationInput, PlayerSnapshotUncheckedUpdateManyWithoutPlayerSnapshotInput>
  }

  export type PlayerCreateWithoutProfileInput = {
    id?: string
    puuid?: string
    accountId?: string
    platformId?: string
    summonerId?: string
    summonerName?: string
    summonerLevel?: number | null
    profileIconId?: number | null
    revisionDate?: string
    kills?: PlayerKillCreateNestedManyWithoutKillerInput
    deaths?: PlayerKillCreateNestedManyWithoutVictimInput
    teams?: TeamCreateNestedManyWithoutPlayersInput
    monsterKills?: TeamMonsterKillCreateNestedManyWithoutKillerInput
    buildingKills?: TeamBuildingKillCreateNestedManyWithoutKillerInput
    itemEvent?: PlayerItemEventCreateNestedManyWithoutPlayerInput
    endOfGameStats?: PlayerEndOfGameStatCreateNestedManyWithoutPlayerInput
    snapshots?: PlayerSnapshotCreateNestedManyWithoutPlayerInput
    wardEvents?: PlayerWardEventCreateNestedManyWithoutPlayerInput
    skillLevelUpEvents?: PlayerSkillLevelUpEventCreateNestedManyWithoutPlayerInput
  }

  export type PlayerUncheckedCreateWithoutProfileInput = {
    id?: string
    puuid?: string
    accountId?: string
    platformId?: string
    summonerId?: string
    summonerName?: string
    summonerLevel?: number | null
    profileIconId?: number | null
    revisionDate?: string
    kills?: PlayerKillUncheckedCreateNestedManyWithoutKillerInput
    deaths?: PlayerKillUncheckedCreateNestedManyWithoutVictimInput
    teams?: TeamUncheckedCreateNestedManyWithoutPlayersInput
    monsterKills?: TeamMonsterKillUncheckedCreateNestedManyWithoutKillerInput
    buildingKills?: TeamBuildingKillUncheckedCreateNestedManyWithoutKillerInput
    itemEvent?: PlayerItemEventUncheckedCreateNestedManyWithoutPlayerInput
    endOfGameStats?: PlayerEndOfGameStatUncheckedCreateNestedManyWithoutPlayerInput
    snapshots?: PlayerSnapshotUncheckedCreateNestedManyWithoutPlayerInput
    wardEvents?: PlayerWardEventUncheckedCreateNestedManyWithoutPlayerInput
    skillLevelUpEvents?: PlayerSkillLevelUpEventUncheckedCreateNestedManyWithoutPlayerInput
  }

  export type PlayerCreateOrConnectWithoutProfileInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutProfileInput, PlayerUncheckedCreateWithoutProfileInput>
  }

  export type ActivityCreateWithoutProfileInput = {
    id?: string
    month?: number | null
    year?: number | null
    day?: number | null
    gamesPlayed?: number | null
  }

  export type ActivityUncheckedCreateWithoutProfileInput = {
    id?: string
    month?: number | null
    year?: number | null
    day?: number | null
    gamesPlayed?: number | null
  }

  export type ActivityCreateOrConnectWithoutProfileInput = {
    where: ActivityWhereUniqueInput
    create: XOR<ActivityCreateWithoutProfileInput, ActivityUncheckedCreateWithoutProfileInput>
  }

  export type ActivityCreateManyProfileInputEnvelope = {
    data: Enumerable<ActivityCreateManyProfileInput>
    skipDuplicates?: boolean
  }

  export type ChampionWinrateCreateWithoutProfileInput = {
    id?: string
    champion?: string
    wins?: number | null
    games?: number | null
    spell1Casts?: number | null
    spell2Casts?: number | null
    spell3Casts?: number | null
    spell4Casts?: number | null
  }

  export type ChampionWinrateUncheckedCreateWithoutProfileInput = {
    id?: string
    champion?: string
    wins?: number | null
    games?: number | null
    spell1Casts?: number | null
    spell2Casts?: number | null
    spell3Casts?: number | null
    spell4Casts?: number | null
  }

  export type ChampionWinrateCreateOrConnectWithoutProfileInput = {
    where: ChampionWinrateWhereUniqueInput
    create: XOR<ChampionWinrateCreateWithoutProfileInput, ChampionWinrateUncheckedCreateWithoutProfileInput>
  }

  export type ChampionWinrateCreateManyProfileInputEnvelope = {
    data: Enumerable<ChampionWinrateCreateManyProfileInput>
    skipDuplicates?: boolean
  }

  export type DuoCreateWithoutProfileInput = {
    id?: string
    name?: string
    wins?: number | null
    losses?: number | null
    winrate?: string
  }

  export type DuoUncheckedCreateWithoutProfileInput = {
    id?: string
    name?: string
    wins?: number | null
    losses?: number | null
    winrate?: string
  }

  export type DuoCreateOrConnectWithoutProfileInput = {
    where: DuoWhereUniqueInput
    create: XOR<DuoCreateWithoutProfileInput, DuoUncheckedCreateWithoutProfileInput>
  }

  export type DuoCreateManyProfileInputEnvelope = {
    data: Enumerable<DuoCreateManyProfileInput>
    skipDuplicates?: boolean
  }

  export type PlayerUpsertWithoutProfileInput = {
    update: XOR<PlayerUpdateWithoutProfileInput, PlayerUncheckedUpdateWithoutProfileInput>
    create: XOR<PlayerCreateWithoutProfileInput, PlayerUncheckedCreateWithoutProfileInput>
  }

  export type PlayerUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    puuid?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    platformId?: StringFieldUpdateOperationsInput | string
    summonerId?: StringFieldUpdateOperationsInput | string
    summonerName?: StringFieldUpdateOperationsInput | string
    summonerLevel?: NullableIntFieldUpdateOperationsInput | number | null
    profileIconId?: NullableIntFieldUpdateOperationsInput | number | null
    revisionDate?: StringFieldUpdateOperationsInput | string
    kills?: PlayerKillUpdateManyWithoutKillerInput
    deaths?: PlayerKillUpdateManyWithoutVictimInput
    teams?: TeamUpdateManyWithoutPlayersInput
    monsterKills?: TeamMonsterKillUpdateManyWithoutKillerInput
    buildingKills?: TeamBuildingKillUpdateManyWithoutKillerInput
    itemEvent?: PlayerItemEventUpdateManyWithoutPlayerInput
    endOfGameStats?: PlayerEndOfGameStatUpdateManyWithoutPlayerInput
    snapshots?: PlayerSnapshotUpdateManyWithoutPlayerInput
    wardEvents?: PlayerWardEventUpdateManyWithoutPlayerInput
    skillLevelUpEvents?: PlayerSkillLevelUpEventUpdateManyWithoutPlayerInput
  }

  export type PlayerUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    puuid?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    platformId?: StringFieldUpdateOperationsInput | string
    summonerId?: StringFieldUpdateOperationsInput | string
    summonerName?: StringFieldUpdateOperationsInput | string
    summonerLevel?: NullableIntFieldUpdateOperationsInput | number | null
    profileIconId?: NullableIntFieldUpdateOperationsInput | number | null
    revisionDate?: StringFieldUpdateOperationsInput | string
    kills?: PlayerKillUncheckedUpdateManyWithoutKillerInput
    deaths?: PlayerKillUncheckedUpdateManyWithoutVictimInput
    teams?: TeamUncheckedUpdateManyWithoutPlayersInput
    monsterKills?: TeamMonsterKillUncheckedUpdateManyWithoutKillerInput
    buildingKills?: TeamBuildingKillUncheckedUpdateManyWithoutKillerInput
    itemEvent?: PlayerItemEventUncheckedUpdateManyWithoutPlayerInput
    endOfGameStats?: PlayerEndOfGameStatUncheckedUpdateManyWithoutPlayerInput
    snapshots?: PlayerSnapshotUncheckedUpdateManyWithoutPlayerInput
    wardEvents?: PlayerWardEventUncheckedUpdateManyWithoutPlayerInput
    skillLevelUpEvents?: PlayerSkillLevelUpEventUncheckedUpdateManyWithoutPlayerInput
  }

  export type ActivityUpsertWithWhereUniqueWithoutProfileInput = {
    where: ActivityWhereUniqueInput
    update: XOR<ActivityUpdateWithoutProfileInput, ActivityUncheckedUpdateWithoutProfileInput>
    create: XOR<ActivityCreateWithoutProfileInput, ActivityUncheckedCreateWithoutProfileInput>
  }

  export type ActivityUpdateWithWhereUniqueWithoutProfileInput = {
    where: ActivityWhereUniqueInput
    data: XOR<ActivityUpdateWithoutProfileInput, ActivityUncheckedUpdateWithoutProfileInput>
  }

  export type ActivityUpdateManyWithWhereWithoutProfileInput = {
    where: ActivityScalarWhereInput
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyWithoutActivityInput>
  }

  export type ActivityScalarWhereInput = {
    AND?: Enumerable<ActivityScalarWhereInput>
    OR?: Enumerable<ActivityScalarWhereInput>
    NOT?: Enumerable<ActivityScalarWhereInput>
    id?: StringFilter | string
    profileId?: StringNullableFilter | string | null
    month?: IntNullableFilter | number | null
    year?: IntNullableFilter | number | null
    day?: IntNullableFilter | number | null
    gamesPlayed?: IntNullableFilter | number | null
  }

  export type ChampionWinrateUpsertWithWhereUniqueWithoutProfileInput = {
    where: ChampionWinrateWhereUniqueInput
    update: XOR<ChampionWinrateUpdateWithoutProfileInput, ChampionWinrateUncheckedUpdateWithoutProfileInput>
    create: XOR<ChampionWinrateCreateWithoutProfileInput, ChampionWinrateUncheckedCreateWithoutProfileInput>
  }

  export type ChampionWinrateUpdateWithWhereUniqueWithoutProfileInput = {
    where: ChampionWinrateWhereUniqueInput
    data: XOR<ChampionWinrateUpdateWithoutProfileInput, ChampionWinrateUncheckedUpdateWithoutProfileInput>
  }

  export type ChampionWinrateUpdateManyWithWhereWithoutProfileInput = {
    where: ChampionWinrateScalarWhereInput
    data: XOR<ChampionWinrateUpdateManyMutationInput, ChampionWinrateUncheckedUpdateManyWithoutChampionWinrateInput>
  }

  export type ChampionWinrateScalarWhereInput = {
    AND?: Enumerable<ChampionWinrateScalarWhereInput>
    OR?: Enumerable<ChampionWinrateScalarWhereInput>
    NOT?: Enumerable<ChampionWinrateScalarWhereInput>
    id?: StringFilter | string
    profileId?: StringNullableFilter | string | null
    champion?: StringFilter | string
    wins?: IntNullableFilter | number | null
    games?: IntNullableFilter | number | null
    spell1Casts?: IntNullableFilter | number | null
    spell2Casts?: IntNullableFilter | number | null
    spell3Casts?: IntNullableFilter | number | null
    spell4Casts?: IntNullableFilter | number | null
  }

  export type DuoUpsertWithWhereUniqueWithoutProfileInput = {
    where: DuoWhereUniqueInput
    update: XOR<DuoUpdateWithoutProfileInput, DuoUncheckedUpdateWithoutProfileInput>
    create: XOR<DuoCreateWithoutProfileInput, DuoUncheckedCreateWithoutProfileInput>
  }

  export type DuoUpdateWithWhereUniqueWithoutProfileInput = {
    where: DuoWhereUniqueInput
    data: XOR<DuoUpdateWithoutProfileInput, DuoUncheckedUpdateWithoutProfileInput>
  }

  export type DuoUpdateManyWithWhereWithoutProfileInput = {
    where: DuoScalarWhereInput
    data: XOR<DuoUpdateManyMutationInput, DuoUncheckedUpdateManyWithoutDuosInput>
  }

  export type DuoScalarWhereInput = {
    AND?: Enumerable<DuoScalarWhereInput>
    OR?: Enumerable<DuoScalarWhereInput>
    NOT?: Enumerable<DuoScalarWhereInput>
    id?: StringFilter | string
    profileId?: StringNullableFilter | string | null
    name?: StringFilter | string
    wins?: IntNullableFilter | number | null
    losses?: IntNullableFilter | number | null
    winrate?: StringFilter | string
  }

  export type GameCreateWithoutSourceInput = {
    id?: string
    matchId?: string
    gameId?: string
    gameCreation?: string
    gameStartTimestamp?: string
    gameEndTimestamp?: string
    duration?: number | null
    start?: string
    gameVersion?: string
    blueTeam?: TeamCreateNestedOneWithoutFrom_Game_blueTeamInput
    redTeam?: TeamCreateNestedOneWithoutFrom_Game_redTeamInput
    tournament?: string
    gameInSeries?: number | null
    vod?: string
    platformId?: string
    from_PlayerEndOfGameStat_game?: PlayerEndOfGameStatCreateNestedManyWithoutGameInput
    from_Team_game?: TeamCreateNestedManyWithoutGameInput
  }

  export type GameUncheckedCreateWithoutSourceInput = {
    id?: string
    matchId?: string
    gameId?: string
    gameCreation?: string
    gameStartTimestamp?: string
    gameEndTimestamp?: string
    duration?: number | null
    start?: string
    gameVersion?: string
    blueTeamId?: string | null
    redTeamId?: string | null
    tournament?: string
    gameInSeries?: number | null
    vod?: string
    platformId?: string
    from_PlayerEndOfGameStat_game?: PlayerEndOfGameStatUncheckedCreateNestedManyWithoutGameInput
    from_Team_game?: TeamUncheckedCreateNestedManyWithoutGameInput
  }

  export type GameCreateOrConnectWithoutSourceInput = {
    where: GameWhereUniqueInput
    create: XOR<GameCreateWithoutSourceInput, GameUncheckedCreateWithoutSourceInput>
  }

  export type GameUpsertWithWhereUniqueWithoutSourceInput = {
    where: GameWhereUniqueInput
    update: XOR<GameUpdateWithoutSourceInput, GameUncheckedUpdateWithoutSourceInput>
    create: XOR<GameCreateWithoutSourceInput, GameUncheckedCreateWithoutSourceInput>
  }

  export type GameUpdateWithWhereUniqueWithoutSourceInput = {
    where: GameWhereUniqueInput
    data: XOR<GameUpdateWithoutSourceInput, GameUncheckedUpdateWithoutSourceInput>
  }

  export type GameUpdateManyWithWhereWithoutSourceInput = {
    where: GameScalarWhereInput
    data: XOR<GameUpdateManyMutationInput, GameUncheckedUpdateManyWithoutGameInput>
  }

  export type GameScalarWhereInput = {
    AND?: Enumerable<GameScalarWhereInput>
    OR?: Enumerable<GameScalarWhereInput>
    NOT?: Enumerable<GameScalarWhereInput>
    id?: StringFilter | string
    matchId?: StringFilter | string
    gameId?: StringFilter | string
    gameCreation?: StringFilter | string
    gameStartTimestamp?: StringFilter | string
    gameEndTimestamp?: StringFilter | string
    duration?: IntNullableFilter | number | null
    start?: StringFilter | string
    gameVersion?: StringFilter | string
    blueTeamId?: StringNullableFilter | string | null
    redTeamId?: StringNullableFilter | string | null
    tournament?: StringFilter | string
    gameInSeries?: IntNullableFilter | number | null
    vod?: StringFilter | string
    platformId?: StringFilter | string
  }

  export type PickBanCreateWithoutTeamInput = {
    id?: string
    championId?: number | null
    pickTurn?: number | null
  }

  export type PickBanUncheckedCreateWithoutTeamInput = {
    id?: string
    championId?: number | null
    pickTurn?: number | null
  }

  export type PickBanCreateOrConnectWithoutTeamInput = {
    where: PickBanWhereUniqueInput
    create: XOR<PickBanCreateWithoutTeamInput, PickBanUncheckedCreateWithoutTeamInput>
  }

  export type PickBanCreateManyTeamInputEnvelope = {
    data: Enumerable<PickBanCreateManyTeamInput>
    skipDuplicates?: boolean
  }

  export type GameCreateWithoutFrom_Team_gameInput = {
    id?: string
    matchId?: string
    gameId?: string
    gameCreation?: string
    gameStartTimestamp?: string
    gameEndTimestamp?: string
    duration?: number | null
    start?: string
    gameVersion?: string
    blueTeam?: TeamCreateNestedOneWithoutFrom_Game_blueTeamInput
    redTeam?: TeamCreateNestedOneWithoutFrom_Game_redTeamInput
    source?: SourceCreateNestedManyWithoutGameInput
    tournament?: string
    gameInSeries?: number | null
    vod?: string
    platformId?: string
    from_PlayerEndOfGameStat_game?: PlayerEndOfGameStatCreateNestedManyWithoutGameInput
  }

  export type GameUncheckedCreateWithoutFrom_Team_gameInput = {
    id?: string
    matchId?: string
    gameId?: string
    gameCreation?: string
    gameStartTimestamp?: string
    gameEndTimestamp?: string
    duration?: number | null
    start?: string
    gameVersion?: string
    blueTeamId?: string | null
    redTeamId?: string | null
    source?: SourceUncheckedCreateNestedManyWithoutGameInput
    tournament?: string
    gameInSeries?: number | null
    vod?: string
    platformId?: string
    from_PlayerEndOfGameStat_game?: PlayerEndOfGameStatUncheckedCreateNestedManyWithoutGameInput
  }

  export type GameCreateOrConnectWithoutFrom_Team_gameInput = {
    where: GameWhereUniqueInput
    create: XOR<GameCreateWithoutFrom_Team_gameInput, GameUncheckedCreateWithoutFrom_Team_gameInput>
  }

  export type PlayerCreateWithoutTeamsInput = {
    id?: string
    puuid?: string
    accountId?: string
    platformId?: string
    summonerId?: string
    summonerName?: string
    summonerLevel?: number | null
    profileIconId?: number | null
    revisionDate?: string
    kills?: PlayerKillCreateNestedManyWithoutKillerInput
    deaths?: PlayerKillCreateNestedManyWithoutVictimInput
    profile?: ProfileCreateNestedOneWithoutPlayerInput
    monsterKills?: TeamMonsterKillCreateNestedManyWithoutKillerInput
    buildingKills?: TeamBuildingKillCreateNestedManyWithoutKillerInput
    itemEvent?: PlayerItemEventCreateNestedManyWithoutPlayerInput
    endOfGameStats?: PlayerEndOfGameStatCreateNestedManyWithoutPlayerInput
    snapshots?: PlayerSnapshotCreateNestedManyWithoutPlayerInput
    wardEvents?: PlayerWardEventCreateNestedManyWithoutPlayerInput
    skillLevelUpEvents?: PlayerSkillLevelUpEventCreateNestedManyWithoutPlayerInput
  }

  export type PlayerUncheckedCreateWithoutTeamsInput = {
    id?: string
    puuid?: string
    accountId?: string
    platformId?: string
    summonerId?: string
    summonerName?: string
    summonerLevel?: number | null
    profileIconId?: number | null
    revisionDate?: string
    kills?: PlayerKillUncheckedCreateNestedManyWithoutKillerInput
    deaths?: PlayerKillUncheckedCreateNestedManyWithoutVictimInput
    profileId?: string | null
    monsterKills?: TeamMonsterKillUncheckedCreateNestedManyWithoutKillerInput
    buildingKills?: TeamBuildingKillUncheckedCreateNestedManyWithoutKillerInput
    itemEvent?: PlayerItemEventUncheckedCreateNestedManyWithoutPlayerInput
    endOfGameStats?: PlayerEndOfGameStatUncheckedCreateNestedManyWithoutPlayerInput
    snapshots?: PlayerSnapshotUncheckedCreateNestedManyWithoutPlayerInput
    wardEvents?: PlayerWardEventUncheckedCreateNestedManyWithoutPlayerInput
    skillLevelUpEvents?: PlayerSkillLevelUpEventUncheckedCreateNestedManyWithoutPlayerInput
  }

  export type PlayerCreateOrConnectWithoutTeamsInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutTeamsInput, PlayerUncheckedCreateWithoutTeamsInput>
  }

  export type ObjectiveCreateWithoutTeamInput = {
    id?: string
    first?: boolean
    kills?: number | null
    type?: string
  }

  export type ObjectiveUncheckedCreateWithoutTeamInput = {
    id?: string
    first?: boolean
    kills?: number | null
    type?: string
  }

  export type ObjectiveCreateOrConnectWithoutTeamInput = {
    where: ObjectiveWhereUniqueInput
    create: XOR<ObjectiveCreateWithoutTeamInput, ObjectiveUncheckedCreateWithoutTeamInput>
  }

  export type ObjectiveCreateManyTeamInputEnvelope = {
    data: Enumerable<ObjectiveCreateManyTeamInput>
    skipDuplicates?: boolean
  }

  export type GameCreateWithoutBlueTeamInput = {
    id?: string
    matchId?: string
    gameId?: string
    gameCreation?: string
    gameStartTimestamp?: string
    gameEndTimestamp?: string
    duration?: number | null
    start?: string
    gameVersion?: string
    redTeam?: TeamCreateNestedOneWithoutFrom_Game_redTeamInput
    source?: SourceCreateNestedManyWithoutGameInput
    tournament?: string
    gameInSeries?: number | null
    vod?: string
    platformId?: string
    from_PlayerEndOfGameStat_game?: PlayerEndOfGameStatCreateNestedManyWithoutGameInput
    from_Team_game?: TeamCreateNestedManyWithoutGameInput
  }

  export type GameUncheckedCreateWithoutBlueTeamInput = {
    id?: string
    matchId?: string
    gameId?: string
    gameCreation?: string
    gameStartTimestamp?: string
    gameEndTimestamp?: string
    duration?: number | null
    start?: string
    gameVersion?: string
    redTeamId?: string | null
    source?: SourceUncheckedCreateNestedManyWithoutGameInput
    tournament?: string
    gameInSeries?: number | null
    vod?: string
    platformId?: string
    from_PlayerEndOfGameStat_game?: PlayerEndOfGameStatUncheckedCreateNestedManyWithoutGameInput
    from_Team_game?: TeamUncheckedCreateNestedManyWithoutGameInput
  }

  export type GameCreateOrConnectWithoutBlueTeamInput = {
    where: GameWhereUniqueInput
    create: XOR<GameCreateWithoutBlueTeamInput, GameUncheckedCreateWithoutBlueTeamInput>
  }

  export type GameCreateManyBlueTeamInputEnvelope = {
    data: Enumerable<GameCreateManyBlueTeamInput>
    skipDuplicates?: boolean
  }

  export type GameCreateWithoutRedTeamInput = {
    id?: string
    matchId?: string
    gameId?: string
    gameCreation?: string
    gameStartTimestamp?: string
    gameEndTimestamp?: string
    duration?: number | null
    start?: string
    gameVersion?: string
    blueTeam?: TeamCreateNestedOneWithoutFrom_Game_blueTeamInput
    source?: SourceCreateNestedManyWithoutGameInput
    tournament?: string
    gameInSeries?: number | null
    vod?: string
    platformId?: string
    from_PlayerEndOfGameStat_game?: PlayerEndOfGameStatCreateNestedManyWithoutGameInput
    from_Team_game?: TeamCreateNestedManyWithoutGameInput
  }

  export type GameUncheckedCreateWithoutRedTeamInput = {
    id?: string
    matchId?: string
    gameId?: string
    gameCreation?: string
    gameStartTimestamp?: string
    gameEndTimestamp?: string
    duration?: number | null
    start?: string
    gameVersion?: string
    blueTeamId?: string | null
    source?: SourceUncheckedCreateNestedManyWithoutGameInput
    tournament?: string
    gameInSeries?: number | null
    vod?: string
    platformId?: string
    from_PlayerEndOfGameStat_game?: PlayerEndOfGameStatUncheckedCreateNestedManyWithoutGameInput
    from_Team_game?: TeamUncheckedCreateNestedManyWithoutGameInput
  }

  export type GameCreateOrConnectWithoutRedTeamInput = {
    where: GameWhereUniqueInput
    create: XOR<GameCreateWithoutRedTeamInput, GameUncheckedCreateWithoutRedTeamInput>
  }

  export type GameCreateManyRedTeamInputEnvelope = {
    data: Enumerable<GameCreateManyRedTeamInput>
    skipDuplicates?: boolean
  }

  export type PickBanUpsertWithWhereUniqueWithoutTeamInput = {
    where: PickBanWhereUniqueInput
    update: XOR<PickBanUpdateWithoutTeamInput, PickBanUncheckedUpdateWithoutTeamInput>
    create: XOR<PickBanCreateWithoutTeamInput, PickBanUncheckedCreateWithoutTeamInput>
  }

  export type PickBanUpdateWithWhereUniqueWithoutTeamInput = {
    where: PickBanWhereUniqueInput
    data: XOR<PickBanUpdateWithoutTeamInput, PickBanUncheckedUpdateWithoutTeamInput>
  }

  export type PickBanUpdateManyWithWhereWithoutTeamInput = {
    where: PickBanScalarWhereInput
    data: XOR<PickBanUpdateManyMutationInput, PickBanUncheckedUpdateManyWithoutPickBanInput>
  }

  export type PickBanScalarWhereInput = {
    AND?: Enumerable<PickBanScalarWhereInput>
    OR?: Enumerable<PickBanScalarWhereInput>
    NOT?: Enumerable<PickBanScalarWhereInput>
    id?: StringFilter | string
    teamId?: StringNullableFilter | string | null
    championId?: IntNullableFilter | number | null
    pickTurn?: IntNullableFilter | number | null
  }

  export type GameUpsertWithoutFrom_Team_gameInput = {
    update: XOR<GameUpdateWithoutFrom_Team_gameInput, GameUncheckedUpdateWithoutFrom_Team_gameInput>
    create: XOR<GameCreateWithoutFrom_Team_gameInput, GameUncheckedCreateWithoutFrom_Team_gameInput>
  }

  export type GameUpdateWithoutFrom_Team_gameInput = {
    id?: StringFieldUpdateOperationsInput | string
    matchId?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    gameCreation?: StringFieldUpdateOperationsInput | string
    gameStartTimestamp?: StringFieldUpdateOperationsInput | string
    gameEndTimestamp?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    start?: StringFieldUpdateOperationsInput | string
    gameVersion?: StringFieldUpdateOperationsInput | string
    blueTeam?: TeamUpdateOneWithoutFrom_Game_blueTeamInput
    redTeam?: TeamUpdateOneWithoutFrom_Game_redTeamInput
    source?: SourceUpdateManyWithoutGameInput
    tournament?: StringFieldUpdateOperationsInput | string
    gameInSeries?: NullableIntFieldUpdateOperationsInput | number | null
    vod?: StringFieldUpdateOperationsInput | string
    platformId?: StringFieldUpdateOperationsInput | string
    from_PlayerEndOfGameStat_game?: PlayerEndOfGameStatUpdateManyWithoutGameInput
  }

  export type GameUncheckedUpdateWithoutFrom_Team_gameInput = {
    id?: StringFieldUpdateOperationsInput | string
    matchId?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    gameCreation?: StringFieldUpdateOperationsInput | string
    gameStartTimestamp?: StringFieldUpdateOperationsInput | string
    gameEndTimestamp?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    start?: StringFieldUpdateOperationsInput | string
    gameVersion?: StringFieldUpdateOperationsInput | string
    blueTeamId?: NullableStringFieldUpdateOperationsInput | string | null
    redTeamId?: NullableStringFieldUpdateOperationsInput | string | null
    source?: SourceUncheckedUpdateManyWithoutGameInput
    tournament?: StringFieldUpdateOperationsInput | string
    gameInSeries?: NullableIntFieldUpdateOperationsInput | number | null
    vod?: StringFieldUpdateOperationsInput | string
    platformId?: StringFieldUpdateOperationsInput | string
    from_PlayerEndOfGameStat_game?: PlayerEndOfGameStatUncheckedUpdateManyWithoutGameInput
  }

  export type PlayerUpsertWithWhereUniqueWithoutTeamsInput = {
    where: PlayerWhereUniqueInput
    update: XOR<PlayerUpdateWithoutTeamsInput, PlayerUncheckedUpdateWithoutTeamsInput>
    create: XOR<PlayerCreateWithoutTeamsInput, PlayerUncheckedCreateWithoutTeamsInput>
  }

  export type PlayerUpdateWithWhereUniqueWithoutTeamsInput = {
    where: PlayerWhereUniqueInput
    data: XOR<PlayerUpdateWithoutTeamsInput, PlayerUncheckedUpdateWithoutTeamsInput>
  }

  export type PlayerUpdateManyWithWhereWithoutTeamsInput = {
    where: PlayerScalarWhereInput
    data: XOR<PlayerUpdateManyMutationInput, PlayerUncheckedUpdateManyWithoutPlayersInput>
  }

  export type ObjectiveUpsertWithWhereUniqueWithoutTeamInput = {
    where: ObjectiveWhereUniqueInput
    update: XOR<ObjectiveUpdateWithoutTeamInput, ObjectiveUncheckedUpdateWithoutTeamInput>
    create: XOR<ObjectiveCreateWithoutTeamInput, ObjectiveUncheckedCreateWithoutTeamInput>
  }

  export type ObjectiveUpdateWithWhereUniqueWithoutTeamInput = {
    where: ObjectiveWhereUniqueInput
    data: XOR<ObjectiveUpdateWithoutTeamInput, ObjectiveUncheckedUpdateWithoutTeamInput>
  }

  export type ObjectiveUpdateManyWithWhereWithoutTeamInput = {
    where: ObjectiveScalarWhereInput
    data: XOR<ObjectiveUpdateManyMutationInput, ObjectiveUncheckedUpdateManyWithoutObjectivesInput>
  }

  export type ObjectiveScalarWhereInput = {
    AND?: Enumerable<ObjectiveScalarWhereInput>
    OR?: Enumerable<ObjectiveScalarWhereInput>
    NOT?: Enumerable<ObjectiveScalarWhereInput>
    id?: StringFilter | string
    teamId?: StringNullableFilter | string | null
    first?: BoolFilter | boolean
    kills?: IntNullableFilter | number | null
    type?: StringFilter | string
  }

  export type GameUpsertWithWhereUniqueWithoutBlueTeamInput = {
    where: GameWhereUniqueInput
    update: XOR<GameUpdateWithoutBlueTeamInput, GameUncheckedUpdateWithoutBlueTeamInput>
    create: XOR<GameCreateWithoutBlueTeamInput, GameUncheckedCreateWithoutBlueTeamInput>
  }

  export type GameUpdateWithWhereUniqueWithoutBlueTeamInput = {
    where: GameWhereUniqueInput
    data: XOR<GameUpdateWithoutBlueTeamInput, GameUncheckedUpdateWithoutBlueTeamInput>
  }

  export type GameUpdateManyWithWhereWithoutBlueTeamInput = {
    where: GameScalarWhereInput
    data: XOR<GameUpdateManyMutationInput, GameUncheckedUpdateManyWithoutFrom_Game_blueTeamInput>
  }

  export type GameUpsertWithWhereUniqueWithoutRedTeamInput = {
    where: GameWhereUniqueInput
    update: XOR<GameUpdateWithoutRedTeamInput, GameUncheckedUpdateWithoutRedTeamInput>
    create: XOR<GameCreateWithoutRedTeamInput, GameUncheckedCreateWithoutRedTeamInput>
  }

  export type GameUpdateWithWhereUniqueWithoutRedTeamInput = {
    where: GameWhereUniqueInput
    data: XOR<GameUpdateWithoutRedTeamInput, GameUncheckedUpdateWithoutRedTeamInput>
  }

  export type GameUpdateManyWithWhereWithoutRedTeamInput = {
    where: GameScalarWhereInput
    data: XOR<GameUpdateManyMutationInput, GameUncheckedUpdateManyWithoutFrom_Game_redTeamInput>
  }

  export type PlayerCreateWithoutBuildingKillsInput = {
    id?: string
    puuid?: string
    accountId?: string
    platformId?: string
    summonerId?: string
    summonerName?: string
    summonerLevel?: number | null
    profileIconId?: number | null
    revisionDate?: string
    kills?: PlayerKillCreateNestedManyWithoutKillerInput
    deaths?: PlayerKillCreateNestedManyWithoutVictimInput
    teams?: TeamCreateNestedManyWithoutPlayersInput
    profile?: ProfileCreateNestedOneWithoutPlayerInput
    monsterKills?: TeamMonsterKillCreateNestedManyWithoutKillerInput
    itemEvent?: PlayerItemEventCreateNestedManyWithoutPlayerInput
    endOfGameStats?: PlayerEndOfGameStatCreateNestedManyWithoutPlayerInput
    snapshots?: PlayerSnapshotCreateNestedManyWithoutPlayerInput
    wardEvents?: PlayerWardEventCreateNestedManyWithoutPlayerInput
    skillLevelUpEvents?: PlayerSkillLevelUpEventCreateNestedManyWithoutPlayerInput
  }

  export type PlayerUncheckedCreateWithoutBuildingKillsInput = {
    id?: string
    puuid?: string
    accountId?: string
    platformId?: string
    summonerId?: string
    summonerName?: string
    summonerLevel?: number | null
    profileIconId?: number | null
    revisionDate?: string
    kills?: PlayerKillUncheckedCreateNestedManyWithoutKillerInput
    deaths?: PlayerKillUncheckedCreateNestedManyWithoutVictimInput
    teams?: TeamUncheckedCreateNestedManyWithoutPlayersInput
    profileId?: string | null
    monsterKills?: TeamMonsterKillUncheckedCreateNestedManyWithoutKillerInput
    itemEvent?: PlayerItemEventUncheckedCreateNestedManyWithoutPlayerInput
    endOfGameStats?: PlayerEndOfGameStatUncheckedCreateNestedManyWithoutPlayerInput
    snapshots?: PlayerSnapshotUncheckedCreateNestedManyWithoutPlayerInput
    wardEvents?: PlayerWardEventUncheckedCreateNestedManyWithoutPlayerInput
    skillLevelUpEvents?: PlayerSkillLevelUpEventUncheckedCreateNestedManyWithoutPlayerInput
  }

  export type PlayerCreateOrConnectWithoutBuildingKillsInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutBuildingKillsInput, PlayerUncheckedCreateWithoutBuildingKillsInput>
  }

  export type PlayerUpsertWithWhereUniqueWithoutBuildingKillsInput = {
    where: PlayerWhereUniqueInput
    update: XOR<PlayerUpdateWithoutBuildingKillsInput, PlayerUncheckedUpdateWithoutBuildingKillsInput>
    create: XOR<PlayerCreateWithoutBuildingKillsInput, PlayerUncheckedCreateWithoutBuildingKillsInput>
  }

  export type PlayerUpdateWithWhereUniqueWithoutBuildingKillsInput = {
    where: PlayerWhereUniqueInput
    data: XOR<PlayerUpdateWithoutBuildingKillsInput, PlayerUncheckedUpdateWithoutBuildingKillsInput>
  }

  export type PlayerUpdateManyWithWhereWithoutBuildingKillsInput = {
    where: PlayerScalarWhereInput
    data: XOR<PlayerUpdateManyMutationInput, PlayerUncheckedUpdateManyWithoutKillerInput>
  }

  export type PlayerCreateWithoutMonsterKillsInput = {
    id?: string
    puuid?: string
    accountId?: string
    platformId?: string
    summonerId?: string
    summonerName?: string
    summonerLevel?: number | null
    profileIconId?: number | null
    revisionDate?: string
    kills?: PlayerKillCreateNestedManyWithoutKillerInput
    deaths?: PlayerKillCreateNestedManyWithoutVictimInput
    teams?: TeamCreateNestedManyWithoutPlayersInput
    profile?: ProfileCreateNestedOneWithoutPlayerInput
    buildingKills?: TeamBuildingKillCreateNestedManyWithoutKillerInput
    itemEvent?: PlayerItemEventCreateNestedManyWithoutPlayerInput
    endOfGameStats?: PlayerEndOfGameStatCreateNestedManyWithoutPlayerInput
    snapshots?: PlayerSnapshotCreateNestedManyWithoutPlayerInput
    wardEvents?: PlayerWardEventCreateNestedManyWithoutPlayerInput
    skillLevelUpEvents?: PlayerSkillLevelUpEventCreateNestedManyWithoutPlayerInput
  }

  export type PlayerUncheckedCreateWithoutMonsterKillsInput = {
    id?: string
    puuid?: string
    accountId?: string
    platformId?: string
    summonerId?: string
    summonerName?: string
    summonerLevel?: number | null
    profileIconId?: number | null
    revisionDate?: string
    kills?: PlayerKillUncheckedCreateNestedManyWithoutKillerInput
    deaths?: PlayerKillUncheckedCreateNestedManyWithoutVictimInput
    teams?: TeamUncheckedCreateNestedManyWithoutPlayersInput
    profileId?: string | null
    buildingKills?: TeamBuildingKillUncheckedCreateNestedManyWithoutKillerInput
    itemEvent?: PlayerItemEventUncheckedCreateNestedManyWithoutPlayerInput
    endOfGameStats?: PlayerEndOfGameStatUncheckedCreateNestedManyWithoutPlayerInput
    snapshots?: PlayerSnapshotUncheckedCreateNestedManyWithoutPlayerInput
    wardEvents?: PlayerWardEventUncheckedCreateNestedManyWithoutPlayerInput
    skillLevelUpEvents?: PlayerSkillLevelUpEventUncheckedCreateNestedManyWithoutPlayerInput
  }

  export type PlayerCreateOrConnectWithoutMonsterKillsInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutMonsterKillsInput, PlayerUncheckedCreateWithoutMonsterKillsInput>
  }

  export type PlayerUpsertWithWhereUniqueWithoutMonsterKillsInput = {
    where: PlayerWhereUniqueInput
    update: XOR<PlayerUpdateWithoutMonsterKillsInput, PlayerUncheckedUpdateWithoutMonsterKillsInput>
    create: XOR<PlayerCreateWithoutMonsterKillsInput, PlayerUncheckedCreateWithoutMonsterKillsInput>
  }

  export type PlayerUpdateWithWhereUniqueWithoutMonsterKillsInput = {
    where: PlayerWhereUniqueInput
    data: XOR<PlayerUpdateWithoutMonsterKillsInput, PlayerUncheckedUpdateWithoutMonsterKillsInput>
  }

  export type PlayerUpdateManyWithWhereWithoutMonsterKillsInput = {
    where: PlayerScalarWhereInput
    data: XOR<PlayerUpdateManyMutationInput, PlayerUncheckedUpdateManyWithoutKillerInput>
  }

  export type RuneStyleCreateWithoutSelectionInput = {
    id?: string
    playerRunes?: PlayerRuneCreateNestedOneWithoutRuneStyleInput
    description?: string
    style?: number | null
  }

  export type RuneStyleUncheckedCreateWithoutSelectionInput = {
    id?: string
    playerRunesId?: string | null
    description?: string
    style?: number | null
  }

  export type RuneStyleCreateOrConnectWithoutSelectionInput = {
    where: RuneStyleWhereUniqueInput
    create: XOR<RuneStyleCreateWithoutSelectionInput, RuneStyleUncheckedCreateWithoutSelectionInput>
  }

  export type RuneStyleUpsertWithoutSelectionInput = {
    update: XOR<RuneStyleUpdateWithoutSelectionInput, RuneStyleUncheckedUpdateWithoutSelectionInput>
    create: XOR<RuneStyleCreateWithoutSelectionInput, RuneStyleUncheckedCreateWithoutSelectionInput>
  }

  export type RuneStyleUpdateWithoutSelectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerRunes?: PlayerRuneUpdateOneWithoutRuneStyleInput
    description?: StringFieldUpdateOperationsInput | string
    style?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RuneStyleUncheckedUpdateWithoutSelectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerRunesId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    style?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PlayerRuneCreateWithoutRuneStyleInput = {
    id?: string
    playerEndOfGameStat?: PlayerEndOfGameStatCreateNestedOneWithoutPerksInput
    defense?: number | null
    flex?: number | null
    offense?: number | null
  }

  export type PlayerRuneUncheckedCreateWithoutRuneStyleInput = {
    id?: string
    playerEndOfGameStat?: PlayerEndOfGameStatUncheckedCreateNestedOneWithoutPerksInput
    defense?: number | null
    flex?: number | null
    offense?: number | null
  }

  export type PlayerRuneCreateOrConnectWithoutRuneStyleInput = {
    where: PlayerRuneWhereUniqueInput
    create: XOR<PlayerRuneCreateWithoutRuneStyleInput, PlayerRuneUncheckedCreateWithoutRuneStyleInput>
  }

  export type RuneSelectionCreateWithoutRuneStyleInput = {
    id?: string
    perk?: number | null
    var1?: number | null
    var2?: number | null
    var3?: number | null
  }

  export type RuneSelectionUncheckedCreateWithoutRuneStyleInput = {
    id?: string
    perk?: number | null
    var1?: number | null
    var2?: number | null
    var3?: number | null
  }

  export type RuneSelectionCreateOrConnectWithoutRuneStyleInput = {
    where: RuneSelectionWhereUniqueInput
    create: XOR<RuneSelectionCreateWithoutRuneStyleInput, RuneSelectionUncheckedCreateWithoutRuneStyleInput>
  }

  export type RuneSelectionCreateManyRuneStyleInputEnvelope = {
    data: Enumerable<RuneSelectionCreateManyRuneStyleInput>
    skipDuplicates?: boolean
  }

  export type PlayerRuneUpsertWithoutRuneStyleInput = {
    update: XOR<PlayerRuneUpdateWithoutRuneStyleInput, PlayerRuneUncheckedUpdateWithoutRuneStyleInput>
    create: XOR<PlayerRuneCreateWithoutRuneStyleInput, PlayerRuneUncheckedCreateWithoutRuneStyleInput>
  }

  export type PlayerRuneUpdateWithoutRuneStyleInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerEndOfGameStat?: PlayerEndOfGameStatUpdateOneWithoutPerksInput
    defense?: NullableIntFieldUpdateOperationsInput | number | null
    flex?: NullableIntFieldUpdateOperationsInput | number | null
    offense?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PlayerRuneUncheckedUpdateWithoutRuneStyleInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerEndOfGameStat?: PlayerEndOfGameStatUncheckedUpdateOneWithoutPerksInput
    defense?: NullableIntFieldUpdateOperationsInput | number | null
    flex?: NullableIntFieldUpdateOperationsInput | number | null
    offense?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RuneSelectionUpsertWithWhereUniqueWithoutRuneStyleInput = {
    where: RuneSelectionWhereUniqueInput
    update: XOR<RuneSelectionUpdateWithoutRuneStyleInput, RuneSelectionUncheckedUpdateWithoutRuneStyleInput>
    create: XOR<RuneSelectionCreateWithoutRuneStyleInput, RuneSelectionUncheckedCreateWithoutRuneStyleInput>
  }

  export type RuneSelectionUpdateWithWhereUniqueWithoutRuneStyleInput = {
    where: RuneSelectionWhereUniqueInput
    data: XOR<RuneSelectionUpdateWithoutRuneStyleInput, RuneSelectionUncheckedUpdateWithoutRuneStyleInput>
  }

  export type RuneSelectionUpdateManyWithWhereWithoutRuneStyleInput = {
    where: RuneSelectionScalarWhereInput
    data: XOR<RuneSelectionUpdateManyMutationInput, RuneSelectionUncheckedUpdateManyWithoutSelectionInput>
  }

  export type RuneSelectionScalarWhereInput = {
    AND?: Enumerable<RuneSelectionScalarWhereInput>
    OR?: Enumerable<RuneSelectionScalarWhereInput>
    NOT?: Enumerable<RuneSelectionScalarWhereInput>
    id?: StringFilter | string
    runeStyleId?: StringNullableFilter | string | null
    perk?: IntNullableFilter | number | null
    var1?: IntNullableFilter | number | null
    var2?: IntNullableFilter | number | null
    var3?: IntNullableFilter | number | null
  }

  export type PositionUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    x?: NullableIntFieldUpdateOperationsInput | number | null
    y?: NullableIntFieldUpdateOperationsInput | number | null
    playerSnapshot?: PlayerSnapshotUpdateManyWithoutPositionInput
  }

  export type PositionUncheckedUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    x?: NullableIntFieldUpdateOperationsInput | number | null
    y?: NullableIntFieldUpdateOperationsInput | number | null
    playerSnapshot?: PlayerSnapshotUncheckedUpdateManyWithoutPositionInput
  }

  export type PositionUncheckedUpdateManyWithoutPositionInput = {
    id?: StringFieldUpdateOperationsInput | string
    x?: NullableIntFieldUpdateOperationsInput | number | null
    y?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PlayerEndOfGameStatCreateManyGameInput = {
    id?: string
    playerId?: string | null
    perksId?: string | null
    itemsId?: string | null
    assists?: number | null
    baronKills?: number | null
    bountyLevel?: number | null
    championExperience?: number | null
    championLevel?: number | null
    championId?: number | null
    championName?: string
    championTransform?: number | null
    consumablesPurchased?: number | null
    damageDealtToBuildings?: number | null
    damageDealtToObjectives?: number | null
    damageDealtToTurrets?: number | null
    damageSelfMitigated?: number | null
    deaths?: number | null
    detectorWardsPlaced?: number | null
    doubleKills?: number | null
    dragonKills?: number | null
    firstBlood?: boolean
    firstBloodAssist?: boolean
    firstTowerKill?: boolean
    firstTowerAssist?: boolean
    gameEndedInEarlySurrender?: boolean
    gameEndedInSurrender?: boolean
    goldEarned?: number | null
    goldSpent?: number | null
    individualPosition?: string
    inhibitorKills?: number | null
    inhibitorTakedowns?: number | null
    inhibitorsLost?: number | null
    item0?: number | null
    item1?: number | null
    item2?: number | null
    item3?: number | null
    item4?: number | null
    item5?: number | null
    item6?: number | null
    itemsPurchased?: number | null
    killingSprees?: number | null
    kills?: number | null
    lane?: string
    largestCriticalStrike?: number | null
    largestKillingSpree?: number | null
    largestMultiKill?: number | null
    longestTimeSpentLiving?: number | null
    magicDamageDealt?: number | null
    magicDamageDealtToChampions?: number | null
    magicDamageTaken?: number | null
    neutralMinionsKilled?: number | null
    nexusKills?: number | null
    nexusLost?: number | null
    nexusTakedowns?: number | null
    objectivesStolen?: number | null
    objectivesStolenAssists?: number | null
    participantId?: number | null
    pentaKills?: number | null
    physicalDamageDealt?: number | null
    physicalDamageDealtToChampions?: number | null
    physicalDamageTaken?: number | null
    quadraKills?: number | null
    riotIdName?: string
    riotIdTagline?: string
    role?: string
    sightWardsBoughtInGame?: number | null
    spell1Casts?: number | null
    spell2Casts?: number | null
    spell3Casts?: number | null
    spell4Casts?: number | null
    summoner1Casts?: number | null
    summoner1Id?: number | null
    summoner2Casts?: number | null
    summoner2Id?: number | null
    summonerLevel?: number | null
    summonerName?: string
    teamEarlySurrendered?: boolean
    teamId?: number | null
    teamPosition?: string
    timeCCingOthers?: number | null
    timePlayed?: number | null
    totalDamageDealt?: number | null
    totalDamageDealtToChampions?: number | null
    totalDamageShieldedOnTeammates?: number | null
    totalDamageTaken?: number | null
    totalHeal?: number | null
    totalHealsOnTeammates?: number | null
    totalMinionsKilled?: number | null
    totalTimeCCDealt?: number | null
    totalTimeSpentDead?: number | null
    totalUnitsHealed?: number | null
    tripleKills?: number | null
    trueDamageDealt?: number | null
    trueDamageDealtToChampions?: number | null
    trueDamageTaken?: number | null
    turretsKilled?: number | null
    turretTakedowns?: number | null
    turretsLost?: number | null
    unrealKills?: number | null
    visionScore?: number | null
    visionWardsBoughtInGame?: number | null
    wardsKilled?: number | null
    wardsPlaced?: number | null
    win?: boolean
  }

  export type TeamCreateManyGameInput = {
    id?: string
    teamId?: number | null
    teamMatchId?: string
    win?: boolean
  }

  export type SourceUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    api?: StringFieldUpdateOperationsInput | string
  }

  export type SourceUncheckedUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    api?: StringFieldUpdateOperationsInput | string
  }

  export type SourceUncheckedUpdateManyWithoutSourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    api?: StringFieldUpdateOperationsInput | string
  }

  export type PlayerEndOfGameStatUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    player?: PlayerUpdateOneWithoutEndOfGameStatsInput
    perks?: PlayerRuneUpdateOneWithoutPlayerEndOfGameStatInput
    items?: PlayerItemUpdateOneWithoutPlayerEndOfGameStatInput
    assists?: NullableIntFieldUpdateOperationsInput | number | null
    baronKills?: NullableIntFieldUpdateOperationsInput | number | null
    bountyLevel?: NullableIntFieldUpdateOperationsInput | number | null
    championExperience?: NullableIntFieldUpdateOperationsInput | number | null
    championLevel?: NullableIntFieldUpdateOperationsInput | number | null
    championId?: NullableIntFieldUpdateOperationsInput | number | null
    championName?: StringFieldUpdateOperationsInput | string
    championTransform?: NullableIntFieldUpdateOperationsInput | number | null
    consumablesPurchased?: NullableIntFieldUpdateOperationsInput | number | null
    damageDealtToBuildings?: NullableIntFieldUpdateOperationsInput | number | null
    damageDealtToObjectives?: NullableIntFieldUpdateOperationsInput | number | null
    damageDealtToTurrets?: NullableIntFieldUpdateOperationsInput | number | null
    damageSelfMitigated?: NullableIntFieldUpdateOperationsInput | number | null
    deaths?: NullableIntFieldUpdateOperationsInput | number | null
    detectorWardsPlaced?: NullableIntFieldUpdateOperationsInput | number | null
    doubleKills?: NullableIntFieldUpdateOperationsInput | number | null
    dragonKills?: NullableIntFieldUpdateOperationsInput | number | null
    firstBlood?: BoolFieldUpdateOperationsInput | boolean
    firstBloodAssist?: BoolFieldUpdateOperationsInput | boolean
    firstTowerKill?: BoolFieldUpdateOperationsInput | boolean
    firstTowerAssist?: BoolFieldUpdateOperationsInput | boolean
    gameEndedInEarlySurrender?: BoolFieldUpdateOperationsInput | boolean
    gameEndedInSurrender?: BoolFieldUpdateOperationsInput | boolean
    goldEarned?: NullableIntFieldUpdateOperationsInput | number | null
    goldSpent?: NullableIntFieldUpdateOperationsInput | number | null
    individualPosition?: StringFieldUpdateOperationsInput | string
    inhibitorKills?: NullableIntFieldUpdateOperationsInput | number | null
    inhibitorTakedowns?: NullableIntFieldUpdateOperationsInput | number | null
    inhibitorsLost?: NullableIntFieldUpdateOperationsInput | number | null
    item0?: NullableIntFieldUpdateOperationsInput | number | null
    item1?: NullableIntFieldUpdateOperationsInput | number | null
    item2?: NullableIntFieldUpdateOperationsInput | number | null
    item3?: NullableIntFieldUpdateOperationsInput | number | null
    item4?: NullableIntFieldUpdateOperationsInput | number | null
    item5?: NullableIntFieldUpdateOperationsInput | number | null
    item6?: NullableIntFieldUpdateOperationsInput | number | null
    itemsPurchased?: NullableIntFieldUpdateOperationsInput | number | null
    killingSprees?: NullableIntFieldUpdateOperationsInput | number | null
    kills?: NullableIntFieldUpdateOperationsInput | number | null
    lane?: StringFieldUpdateOperationsInput | string
    largestCriticalStrike?: NullableIntFieldUpdateOperationsInput | number | null
    largestKillingSpree?: NullableIntFieldUpdateOperationsInput | number | null
    largestMultiKill?: NullableIntFieldUpdateOperationsInput | number | null
    longestTimeSpentLiving?: NullableIntFieldUpdateOperationsInput | number | null
    magicDamageDealt?: NullableIntFieldUpdateOperationsInput | number | null
    magicDamageDealtToChampions?: NullableIntFieldUpdateOperationsInput | number | null
    magicDamageTaken?: NullableIntFieldUpdateOperationsInput | number | null
    neutralMinionsKilled?: NullableIntFieldUpdateOperationsInput | number | null
    nexusKills?: NullableIntFieldUpdateOperationsInput | number | null
    nexusLost?: NullableIntFieldUpdateOperationsInput | number | null
    nexusTakedowns?: NullableIntFieldUpdateOperationsInput | number | null
    objectivesStolen?: NullableIntFieldUpdateOperationsInput | number | null
    objectivesStolenAssists?: NullableIntFieldUpdateOperationsInput | number | null
    participantId?: NullableIntFieldUpdateOperationsInput | number | null
    pentaKills?: NullableIntFieldUpdateOperationsInput | number | null
    physicalDamageDealt?: NullableIntFieldUpdateOperationsInput | number | null
    physicalDamageDealtToChampions?: NullableIntFieldUpdateOperationsInput | number | null
    physicalDamageTaken?: NullableIntFieldUpdateOperationsInput | number | null
    quadraKills?: NullableIntFieldUpdateOperationsInput | number | null
    riotIdName?: StringFieldUpdateOperationsInput | string
    riotIdTagline?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    sightWardsBoughtInGame?: NullableIntFieldUpdateOperationsInput | number | null
    spell1Casts?: NullableIntFieldUpdateOperationsInput | number | null
    spell2Casts?: NullableIntFieldUpdateOperationsInput | number | null
    spell3Casts?: NullableIntFieldUpdateOperationsInput | number | null
    spell4Casts?: NullableIntFieldUpdateOperationsInput | number | null
    summoner1Casts?: NullableIntFieldUpdateOperationsInput | number | null
    summoner1Id?: NullableIntFieldUpdateOperationsInput | number | null
    summoner2Casts?: NullableIntFieldUpdateOperationsInput | number | null
    summoner2Id?: NullableIntFieldUpdateOperationsInput | number | null
    summonerLevel?: NullableIntFieldUpdateOperationsInput | number | null
    summonerName?: StringFieldUpdateOperationsInput | string
    teamEarlySurrendered?: BoolFieldUpdateOperationsInput | boolean
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    teamPosition?: StringFieldUpdateOperationsInput | string
    timeCCingOthers?: NullableIntFieldUpdateOperationsInput | number | null
    timePlayed?: NullableIntFieldUpdateOperationsInput | number | null
    totalDamageDealt?: NullableIntFieldUpdateOperationsInput | number | null
    totalDamageDealtToChampions?: NullableIntFieldUpdateOperationsInput | number | null
    totalDamageShieldedOnTeammates?: NullableIntFieldUpdateOperationsInput | number | null
    totalDamageTaken?: NullableIntFieldUpdateOperationsInput | number | null
    totalHeal?: NullableIntFieldUpdateOperationsInput | number | null
    totalHealsOnTeammates?: NullableIntFieldUpdateOperationsInput | number | null
    totalMinionsKilled?: NullableIntFieldUpdateOperationsInput | number | null
    totalTimeCCDealt?: NullableIntFieldUpdateOperationsInput | number | null
    totalTimeSpentDead?: NullableIntFieldUpdateOperationsInput | number | null
    totalUnitsHealed?: NullableIntFieldUpdateOperationsInput | number | null
    tripleKills?: NullableIntFieldUpdateOperationsInput | number | null
    trueDamageDealt?: NullableIntFieldUpdateOperationsInput | number | null
    trueDamageDealtToChampions?: NullableIntFieldUpdateOperationsInput | number | null
    trueDamageTaken?: NullableIntFieldUpdateOperationsInput | number | null
    turretsKilled?: NullableIntFieldUpdateOperationsInput | number | null
    turretTakedowns?: NullableIntFieldUpdateOperationsInput | number | null
    turretsLost?: NullableIntFieldUpdateOperationsInput | number | null
    unrealKills?: NullableIntFieldUpdateOperationsInput | number | null
    visionScore?: NullableIntFieldUpdateOperationsInput | number | null
    visionWardsBoughtInGame?: NullableIntFieldUpdateOperationsInput | number | null
    wardsKilled?: NullableIntFieldUpdateOperationsInput | number | null
    wardsPlaced?: NullableIntFieldUpdateOperationsInput | number | null
    win?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PlayerEndOfGameStatUncheckedUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: NullableStringFieldUpdateOperationsInput | string | null
    perksId?: NullableStringFieldUpdateOperationsInput | string | null
    itemsId?: NullableStringFieldUpdateOperationsInput | string | null
    assists?: NullableIntFieldUpdateOperationsInput | number | null
    baronKills?: NullableIntFieldUpdateOperationsInput | number | null
    bountyLevel?: NullableIntFieldUpdateOperationsInput | number | null
    championExperience?: NullableIntFieldUpdateOperationsInput | number | null
    championLevel?: NullableIntFieldUpdateOperationsInput | number | null
    championId?: NullableIntFieldUpdateOperationsInput | number | null
    championName?: StringFieldUpdateOperationsInput | string
    championTransform?: NullableIntFieldUpdateOperationsInput | number | null
    consumablesPurchased?: NullableIntFieldUpdateOperationsInput | number | null
    damageDealtToBuildings?: NullableIntFieldUpdateOperationsInput | number | null
    damageDealtToObjectives?: NullableIntFieldUpdateOperationsInput | number | null
    damageDealtToTurrets?: NullableIntFieldUpdateOperationsInput | number | null
    damageSelfMitigated?: NullableIntFieldUpdateOperationsInput | number | null
    deaths?: NullableIntFieldUpdateOperationsInput | number | null
    detectorWardsPlaced?: NullableIntFieldUpdateOperationsInput | number | null
    doubleKills?: NullableIntFieldUpdateOperationsInput | number | null
    dragonKills?: NullableIntFieldUpdateOperationsInput | number | null
    firstBlood?: BoolFieldUpdateOperationsInput | boolean
    firstBloodAssist?: BoolFieldUpdateOperationsInput | boolean
    firstTowerKill?: BoolFieldUpdateOperationsInput | boolean
    firstTowerAssist?: BoolFieldUpdateOperationsInput | boolean
    gameEndedInEarlySurrender?: BoolFieldUpdateOperationsInput | boolean
    gameEndedInSurrender?: BoolFieldUpdateOperationsInput | boolean
    goldEarned?: NullableIntFieldUpdateOperationsInput | number | null
    goldSpent?: NullableIntFieldUpdateOperationsInput | number | null
    individualPosition?: StringFieldUpdateOperationsInput | string
    inhibitorKills?: NullableIntFieldUpdateOperationsInput | number | null
    inhibitorTakedowns?: NullableIntFieldUpdateOperationsInput | number | null
    inhibitorsLost?: NullableIntFieldUpdateOperationsInput | number | null
    item0?: NullableIntFieldUpdateOperationsInput | number | null
    item1?: NullableIntFieldUpdateOperationsInput | number | null
    item2?: NullableIntFieldUpdateOperationsInput | number | null
    item3?: NullableIntFieldUpdateOperationsInput | number | null
    item4?: NullableIntFieldUpdateOperationsInput | number | null
    item5?: NullableIntFieldUpdateOperationsInput | number | null
    item6?: NullableIntFieldUpdateOperationsInput | number | null
    itemsPurchased?: NullableIntFieldUpdateOperationsInput | number | null
    killingSprees?: NullableIntFieldUpdateOperationsInput | number | null
    kills?: NullableIntFieldUpdateOperationsInput | number | null
    lane?: StringFieldUpdateOperationsInput | string
    largestCriticalStrike?: NullableIntFieldUpdateOperationsInput | number | null
    largestKillingSpree?: NullableIntFieldUpdateOperationsInput | number | null
    largestMultiKill?: NullableIntFieldUpdateOperationsInput | number | null
    longestTimeSpentLiving?: NullableIntFieldUpdateOperationsInput | number | null
    magicDamageDealt?: NullableIntFieldUpdateOperationsInput | number | null
    magicDamageDealtToChampions?: NullableIntFieldUpdateOperationsInput | number | null
    magicDamageTaken?: NullableIntFieldUpdateOperationsInput | number | null
    neutralMinionsKilled?: NullableIntFieldUpdateOperationsInput | number | null
    nexusKills?: NullableIntFieldUpdateOperationsInput | number | null
    nexusLost?: NullableIntFieldUpdateOperationsInput | number | null
    nexusTakedowns?: NullableIntFieldUpdateOperationsInput | number | null
    objectivesStolen?: NullableIntFieldUpdateOperationsInput | number | null
    objectivesStolenAssists?: NullableIntFieldUpdateOperationsInput | number | null
    participantId?: NullableIntFieldUpdateOperationsInput | number | null
    pentaKills?: NullableIntFieldUpdateOperationsInput | number | null
    physicalDamageDealt?: NullableIntFieldUpdateOperationsInput | number | null
    physicalDamageDealtToChampions?: NullableIntFieldUpdateOperationsInput | number | null
    physicalDamageTaken?: NullableIntFieldUpdateOperationsInput | number | null
    quadraKills?: NullableIntFieldUpdateOperationsInput | number | null
    riotIdName?: StringFieldUpdateOperationsInput | string
    riotIdTagline?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    sightWardsBoughtInGame?: NullableIntFieldUpdateOperationsInput | number | null
    spell1Casts?: NullableIntFieldUpdateOperationsInput | number | null
    spell2Casts?: NullableIntFieldUpdateOperationsInput | number | null
    spell3Casts?: NullableIntFieldUpdateOperationsInput | number | null
    spell4Casts?: NullableIntFieldUpdateOperationsInput | number | null
    summoner1Casts?: NullableIntFieldUpdateOperationsInput | number | null
    summoner1Id?: NullableIntFieldUpdateOperationsInput | number | null
    summoner2Casts?: NullableIntFieldUpdateOperationsInput | number | null
    summoner2Id?: NullableIntFieldUpdateOperationsInput | number | null
    summonerLevel?: NullableIntFieldUpdateOperationsInput | number | null
    summonerName?: StringFieldUpdateOperationsInput | string
    teamEarlySurrendered?: BoolFieldUpdateOperationsInput | boolean
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    teamPosition?: StringFieldUpdateOperationsInput | string
    timeCCingOthers?: NullableIntFieldUpdateOperationsInput | number | null
    timePlayed?: NullableIntFieldUpdateOperationsInput | number | null
    totalDamageDealt?: NullableIntFieldUpdateOperationsInput | number | null
    totalDamageDealtToChampions?: NullableIntFieldUpdateOperationsInput | number | null
    totalDamageShieldedOnTeammates?: NullableIntFieldUpdateOperationsInput | number | null
    totalDamageTaken?: NullableIntFieldUpdateOperationsInput | number | null
    totalHeal?: NullableIntFieldUpdateOperationsInput | number | null
    totalHealsOnTeammates?: NullableIntFieldUpdateOperationsInput | number | null
    totalMinionsKilled?: NullableIntFieldUpdateOperationsInput | number | null
    totalTimeCCDealt?: NullableIntFieldUpdateOperationsInput | number | null
    totalTimeSpentDead?: NullableIntFieldUpdateOperationsInput | number | null
    totalUnitsHealed?: NullableIntFieldUpdateOperationsInput | number | null
    tripleKills?: NullableIntFieldUpdateOperationsInput | number | null
    trueDamageDealt?: NullableIntFieldUpdateOperationsInput | number | null
    trueDamageDealtToChampions?: NullableIntFieldUpdateOperationsInput | number | null
    trueDamageTaken?: NullableIntFieldUpdateOperationsInput | number | null
    turretsKilled?: NullableIntFieldUpdateOperationsInput | number | null
    turretTakedowns?: NullableIntFieldUpdateOperationsInput | number | null
    turretsLost?: NullableIntFieldUpdateOperationsInput | number | null
    unrealKills?: NullableIntFieldUpdateOperationsInput | number | null
    visionScore?: NullableIntFieldUpdateOperationsInput | number | null
    visionWardsBoughtInGame?: NullableIntFieldUpdateOperationsInput | number | null
    wardsKilled?: NullableIntFieldUpdateOperationsInput | number | null
    wardsPlaced?: NullableIntFieldUpdateOperationsInput | number | null
    win?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PlayerEndOfGameStatUncheckedUpdateManyWithoutFrom_PlayerEndOfGameStat_gameInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: NullableStringFieldUpdateOperationsInput | string | null
    perksId?: NullableStringFieldUpdateOperationsInput | string | null
    itemsId?: NullableStringFieldUpdateOperationsInput | string | null
    assists?: NullableIntFieldUpdateOperationsInput | number | null
    baronKills?: NullableIntFieldUpdateOperationsInput | number | null
    bountyLevel?: NullableIntFieldUpdateOperationsInput | number | null
    championExperience?: NullableIntFieldUpdateOperationsInput | number | null
    championLevel?: NullableIntFieldUpdateOperationsInput | number | null
    championId?: NullableIntFieldUpdateOperationsInput | number | null
    championName?: StringFieldUpdateOperationsInput | string
    championTransform?: NullableIntFieldUpdateOperationsInput | number | null
    consumablesPurchased?: NullableIntFieldUpdateOperationsInput | number | null
    damageDealtToBuildings?: NullableIntFieldUpdateOperationsInput | number | null
    damageDealtToObjectives?: NullableIntFieldUpdateOperationsInput | number | null
    damageDealtToTurrets?: NullableIntFieldUpdateOperationsInput | number | null
    damageSelfMitigated?: NullableIntFieldUpdateOperationsInput | number | null
    deaths?: NullableIntFieldUpdateOperationsInput | number | null
    detectorWardsPlaced?: NullableIntFieldUpdateOperationsInput | number | null
    doubleKills?: NullableIntFieldUpdateOperationsInput | number | null
    dragonKills?: NullableIntFieldUpdateOperationsInput | number | null
    firstBlood?: BoolFieldUpdateOperationsInput | boolean
    firstBloodAssist?: BoolFieldUpdateOperationsInput | boolean
    firstTowerKill?: BoolFieldUpdateOperationsInput | boolean
    firstTowerAssist?: BoolFieldUpdateOperationsInput | boolean
    gameEndedInEarlySurrender?: BoolFieldUpdateOperationsInput | boolean
    gameEndedInSurrender?: BoolFieldUpdateOperationsInput | boolean
    goldEarned?: NullableIntFieldUpdateOperationsInput | number | null
    goldSpent?: NullableIntFieldUpdateOperationsInput | number | null
    individualPosition?: StringFieldUpdateOperationsInput | string
    inhibitorKills?: NullableIntFieldUpdateOperationsInput | number | null
    inhibitorTakedowns?: NullableIntFieldUpdateOperationsInput | number | null
    inhibitorsLost?: NullableIntFieldUpdateOperationsInput | number | null
    item0?: NullableIntFieldUpdateOperationsInput | number | null
    item1?: NullableIntFieldUpdateOperationsInput | number | null
    item2?: NullableIntFieldUpdateOperationsInput | number | null
    item3?: NullableIntFieldUpdateOperationsInput | number | null
    item4?: NullableIntFieldUpdateOperationsInput | number | null
    item5?: NullableIntFieldUpdateOperationsInput | number | null
    item6?: NullableIntFieldUpdateOperationsInput | number | null
    itemsPurchased?: NullableIntFieldUpdateOperationsInput | number | null
    killingSprees?: NullableIntFieldUpdateOperationsInput | number | null
    kills?: NullableIntFieldUpdateOperationsInput | number | null
    lane?: StringFieldUpdateOperationsInput | string
    largestCriticalStrike?: NullableIntFieldUpdateOperationsInput | number | null
    largestKillingSpree?: NullableIntFieldUpdateOperationsInput | number | null
    largestMultiKill?: NullableIntFieldUpdateOperationsInput | number | null
    longestTimeSpentLiving?: NullableIntFieldUpdateOperationsInput | number | null
    magicDamageDealt?: NullableIntFieldUpdateOperationsInput | number | null
    magicDamageDealtToChampions?: NullableIntFieldUpdateOperationsInput | number | null
    magicDamageTaken?: NullableIntFieldUpdateOperationsInput | number | null
    neutralMinionsKilled?: NullableIntFieldUpdateOperationsInput | number | null
    nexusKills?: NullableIntFieldUpdateOperationsInput | number | null
    nexusLost?: NullableIntFieldUpdateOperationsInput | number | null
    nexusTakedowns?: NullableIntFieldUpdateOperationsInput | number | null
    objectivesStolen?: NullableIntFieldUpdateOperationsInput | number | null
    objectivesStolenAssists?: NullableIntFieldUpdateOperationsInput | number | null
    participantId?: NullableIntFieldUpdateOperationsInput | number | null
    pentaKills?: NullableIntFieldUpdateOperationsInput | number | null
    physicalDamageDealt?: NullableIntFieldUpdateOperationsInput | number | null
    physicalDamageDealtToChampions?: NullableIntFieldUpdateOperationsInput | number | null
    physicalDamageTaken?: NullableIntFieldUpdateOperationsInput | number | null
    quadraKills?: NullableIntFieldUpdateOperationsInput | number | null
    riotIdName?: StringFieldUpdateOperationsInput | string
    riotIdTagline?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    sightWardsBoughtInGame?: NullableIntFieldUpdateOperationsInput | number | null
    spell1Casts?: NullableIntFieldUpdateOperationsInput | number | null
    spell2Casts?: NullableIntFieldUpdateOperationsInput | number | null
    spell3Casts?: NullableIntFieldUpdateOperationsInput | number | null
    spell4Casts?: NullableIntFieldUpdateOperationsInput | number | null
    summoner1Casts?: NullableIntFieldUpdateOperationsInput | number | null
    summoner1Id?: NullableIntFieldUpdateOperationsInput | number | null
    summoner2Casts?: NullableIntFieldUpdateOperationsInput | number | null
    summoner2Id?: NullableIntFieldUpdateOperationsInput | number | null
    summonerLevel?: NullableIntFieldUpdateOperationsInput | number | null
    summonerName?: StringFieldUpdateOperationsInput | string
    teamEarlySurrendered?: BoolFieldUpdateOperationsInput | boolean
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    teamPosition?: StringFieldUpdateOperationsInput | string
    timeCCingOthers?: NullableIntFieldUpdateOperationsInput | number | null
    timePlayed?: NullableIntFieldUpdateOperationsInput | number | null
    totalDamageDealt?: NullableIntFieldUpdateOperationsInput | number | null
    totalDamageDealtToChampions?: NullableIntFieldUpdateOperationsInput | number | null
    totalDamageShieldedOnTeammates?: NullableIntFieldUpdateOperationsInput | number | null
    totalDamageTaken?: NullableIntFieldUpdateOperationsInput | number | null
    totalHeal?: NullableIntFieldUpdateOperationsInput | number | null
    totalHealsOnTeammates?: NullableIntFieldUpdateOperationsInput | number | null
    totalMinionsKilled?: NullableIntFieldUpdateOperationsInput | number | null
    totalTimeCCDealt?: NullableIntFieldUpdateOperationsInput | number | null
    totalTimeSpentDead?: NullableIntFieldUpdateOperationsInput | number | null
    totalUnitsHealed?: NullableIntFieldUpdateOperationsInput | number | null
    tripleKills?: NullableIntFieldUpdateOperationsInput | number | null
    trueDamageDealt?: NullableIntFieldUpdateOperationsInput | number | null
    trueDamageDealtToChampions?: NullableIntFieldUpdateOperationsInput | number | null
    trueDamageTaken?: NullableIntFieldUpdateOperationsInput | number | null
    turretsKilled?: NullableIntFieldUpdateOperationsInput | number | null
    turretTakedowns?: NullableIntFieldUpdateOperationsInput | number | null
    turretsLost?: NullableIntFieldUpdateOperationsInput | number | null
    unrealKills?: NullableIntFieldUpdateOperationsInput | number | null
    visionScore?: NullableIntFieldUpdateOperationsInput | number | null
    visionWardsBoughtInGame?: NullableIntFieldUpdateOperationsInput | number | null
    wardsKilled?: NullableIntFieldUpdateOperationsInput | number | null
    wardsPlaced?: NullableIntFieldUpdateOperationsInput | number | null
    win?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TeamUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    pickBan?: PickBanUpdateManyWithoutTeamInput
    players?: PlayerUpdateManyWithoutTeamsInput
    objectives?: ObjectiveUpdateManyWithoutTeamInput
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    teamMatchId?: StringFieldUpdateOperationsInput | string
    win?: BoolFieldUpdateOperationsInput | boolean
    from_Game_blueTeam?: GameUpdateManyWithoutBlueTeamInput
    from_Game_redTeam?: GameUpdateManyWithoutRedTeamInput
  }

  export type TeamUncheckedUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    pickBan?: PickBanUncheckedUpdateManyWithoutTeamInput
    players?: PlayerUncheckedUpdateManyWithoutTeamsInput
    objectives?: ObjectiveUncheckedUpdateManyWithoutTeamInput
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    teamMatchId?: StringFieldUpdateOperationsInput | string
    win?: BoolFieldUpdateOperationsInput | boolean
    from_Game_blueTeam?: GameUncheckedUpdateManyWithoutBlueTeamInput
    from_Game_redTeam?: GameUncheckedUpdateManyWithoutRedTeamInput
  }

  export type TeamUncheckedUpdateManyWithoutFrom_Team_gameInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    teamMatchId?: StringFieldUpdateOperationsInput | string
    win?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PlayerEndOfGameStatCreateManyPlayerInput = {
    id?: string
    gameId?: string | null
    perksId?: string | null
    itemsId?: string | null
    assists?: number | null
    baronKills?: number | null
    bountyLevel?: number | null
    championExperience?: number | null
    championLevel?: number | null
    championId?: number | null
    championName?: string
    championTransform?: number | null
    consumablesPurchased?: number | null
    damageDealtToBuildings?: number | null
    damageDealtToObjectives?: number | null
    damageDealtToTurrets?: number | null
    damageSelfMitigated?: number | null
    deaths?: number | null
    detectorWardsPlaced?: number | null
    doubleKills?: number | null
    dragonKills?: number | null
    firstBlood?: boolean
    firstBloodAssist?: boolean
    firstTowerKill?: boolean
    firstTowerAssist?: boolean
    gameEndedInEarlySurrender?: boolean
    gameEndedInSurrender?: boolean
    goldEarned?: number | null
    goldSpent?: number | null
    individualPosition?: string
    inhibitorKills?: number | null
    inhibitorTakedowns?: number | null
    inhibitorsLost?: number | null
    item0?: number | null
    item1?: number | null
    item2?: number | null
    item3?: number | null
    item4?: number | null
    item5?: number | null
    item6?: number | null
    itemsPurchased?: number | null
    killingSprees?: number | null
    kills?: number | null
    lane?: string
    largestCriticalStrike?: number | null
    largestKillingSpree?: number | null
    largestMultiKill?: number | null
    longestTimeSpentLiving?: number | null
    magicDamageDealt?: number | null
    magicDamageDealtToChampions?: number | null
    magicDamageTaken?: number | null
    neutralMinionsKilled?: number | null
    nexusKills?: number | null
    nexusLost?: number | null
    nexusTakedowns?: number | null
    objectivesStolen?: number | null
    objectivesStolenAssists?: number | null
    participantId?: number | null
    pentaKills?: number | null
    physicalDamageDealt?: number | null
    physicalDamageDealtToChampions?: number | null
    physicalDamageTaken?: number | null
    quadraKills?: number | null
    riotIdName?: string
    riotIdTagline?: string
    role?: string
    sightWardsBoughtInGame?: number | null
    spell1Casts?: number | null
    spell2Casts?: number | null
    spell3Casts?: number | null
    spell4Casts?: number | null
    summoner1Casts?: number | null
    summoner1Id?: number | null
    summoner2Casts?: number | null
    summoner2Id?: number | null
    summonerLevel?: number | null
    summonerName?: string
    teamEarlySurrendered?: boolean
    teamId?: number | null
    teamPosition?: string
    timeCCingOthers?: number | null
    timePlayed?: number | null
    totalDamageDealt?: number | null
    totalDamageDealtToChampions?: number | null
    totalDamageShieldedOnTeammates?: number | null
    totalDamageTaken?: number | null
    totalHeal?: number | null
    totalHealsOnTeammates?: number | null
    totalMinionsKilled?: number | null
    totalTimeCCDealt?: number | null
    totalTimeSpentDead?: number | null
    totalUnitsHealed?: number | null
    tripleKills?: number | null
    trueDamageDealt?: number | null
    trueDamageDealtToChampions?: number | null
    trueDamageTaken?: number | null
    turretsKilled?: number | null
    turretTakedowns?: number | null
    turretsLost?: number | null
    unrealKills?: number | null
    visionScore?: number | null
    visionWardsBoughtInGame?: number | null
    wardsKilled?: number | null
    wardsPlaced?: number | null
    win?: boolean
  }

  export type PlayerKillUpdateWithoutKillerInput = {
    id?: StringFieldUpdateOperationsInput | string
    victim?: PlayerUpdateManyWithoutDeathsInput
  }

  export type PlayerKillUncheckedUpdateWithoutKillerInput = {
    id?: StringFieldUpdateOperationsInput | string
    victim?: PlayerUncheckedUpdateManyWithoutDeathsInput
  }

  export type PlayerKillUncheckedUpdateManyWithoutKillsInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type PlayerKillUpdateWithoutVictimInput = {
    id?: StringFieldUpdateOperationsInput | string
    killer?: PlayerUpdateManyWithoutKillsInput
  }

  export type PlayerKillUncheckedUpdateWithoutVictimInput = {
    id?: StringFieldUpdateOperationsInput | string
    killer?: PlayerUncheckedUpdateManyWithoutKillsInput
  }

  export type PlayerKillUncheckedUpdateManyWithoutDeathsInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type TeamUpdateWithoutPlayersInput = {
    id?: StringFieldUpdateOperationsInput | string
    pickBan?: PickBanUpdateManyWithoutTeamInput
    game?: GameUpdateOneWithoutFrom_Team_gameInput
    objectives?: ObjectiveUpdateManyWithoutTeamInput
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    teamMatchId?: StringFieldUpdateOperationsInput | string
    win?: BoolFieldUpdateOperationsInput | boolean
    from_Game_blueTeam?: GameUpdateManyWithoutBlueTeamInput
    from_Game_redTeam?: GameUpdateManyWithoutRedTeamInput
  }

  export type TeamUncheckedUpdateWithoutPlayersInput = {
    id?: StringFieldUpdateOperationsInput | string
    pickBan?: PickBanUncheckedUpdateManyWithoutTeamInput
    gameId?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: ObjectiveUncheckedUpdateManyWithoutTeamInput
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    teamMatchId?: StringFieldUpdateOperationsInput | string
    win?: BoolFieldUpdateOperationsInput | boolean
    from_Game_blueTeam?: GameUncheckedUpdateManyWithoutBlueTeamInput
    from_Game_redTeam?: GameUncheckedUpdateManyWithoutRedTeamInput
  }

  export type TeamUncheckedUpdateManyWithoutTeamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    teamMatchId?: StringFieldUpdateOperationsInput | string
    win?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TeamMonsterKillUpdateWithoutKillerInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    subType?: StringFieldUpdateOperationsInput | string
  }

  export type TeamMonsterKillUncheckedUpdateWithoutKillerInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    subType?: StringFieldUpdateOperationsInput | string
  }

  export type TeamMonsterKillUncheckedUpdateManyWithoutMonsterKillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    subType?: StringFieldUpdateOperationsInput | string
  }

  export type TeamBuildingKillUpdateWithoutKillerInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    lane?: StringFieldUpdateOperationsInput | string
    side?: StringFieldUpdateOperationsInput | string
    towerLocation?: StringFieldUpdateOperationsInput | string
  }

  export type TeamBuildingKillUncheckedUpdateWithoutKillerInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    lane?: StringFieldUpdateOperationsInput | string
    side?: StringFieldUpdateOperationsInput | string
    towerLocation?: StringFieldUpdateOperationsInput | string
  }

  export type TeamBuildingKillUncheckedUpdateManyWithoutBuildingKillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    lane?: StringFieldUpdateOperationsInput | string
    side?: StringFieldUpdateOperationsInput | string
    towerLocation?: StringFieldUpdateOperationsInput | string
  }

  export type PlayerItemEventUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    itemId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    undoId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PlayerItemEventUncheckedUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    itemId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    undoId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PlayerItemEventUncheckedUpdateManyWithoutItemEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    itemId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    undoId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PlayerEndOfGameStatUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    game?: GameUpdateOneWithoutFrom_PlayerEndOfGameStat_gameInput
    perks?: PlayerRuneUpdateOneWithoutPlayerEndOfGameStatInput
    items?: PlayerItemUpdateOneWithoutPlayerEndOfGameStatInput
    assists?: NullableIntFieldUpdateOperationsInput | number | null
    baronKills?: NullableIntFieldUpdateOperationsInput | number | null
    bountyLevel?: NullableIntFieldUpdateOperationsInput | number | null
    championExperience?: NullableIntFieldUpdateOperationsInput | number | null
    championLevel?: NullableIntFieldUpdateOperationsInput | number | null
    championId?: NullableIntFieldUpdateOperationsInput | number | null
    championName?: StringFieldUpdateOperationsInput | string
    championTransform?: NullableIntFieldUpdateOperationsInput | number | null
    consumablesPurchased?: NullableIntFieldUpdateOperationsInput | number | null
    damageDealtToBuildings?: NullableIntFieldUpdateOperationsInput | number | null
    damageDealtToObjectives?: NullableIntFieldUpdateOperationsInput | number | null
    damageDealtToTurrets?: NullableIntFieldUpdateOperationsInput | number | null
    damageSelfMitigated?: NullableIntFieldUpdateOperationsInput | number | null
    deaths?: NullableIntFieldUpdateOperationsInput | number | null
    detectorWardsPlaced?: NullableIntFieldUpdateOperationsInput | number | null
    doubleKills?: NullableIntFieldUpdateOperationsInput | number | null
    dragonKills?: NullableIntFieldUpdateOperationsInput | number | null
    firstBlood?: BoolFieldUpdateOperationsInput | boolean
    firstBloodAssist?: BoolFieldUpdateOperationsInput | boolean
    firstTowerKill?: BoolFieldUpdateOperationsInput | boolean
    firstTowerAssist?: BoolFieldUpdateOperationsInput | boolean
    gameEndedInEarlySurrender?: BoolFieldUpdateOperationsInput | boolean
    gameEndedInSurrender?: BoolFieldUpdateOperationsInput | boolean
    goldEarned?: NullableIntFieldUpdateOperationsInput | number | null
    goldSpent?: NullableIntFieldUpdateOperationsInput | number | null
    individualPosition?: StringFieldUpdateOperationsInput | string
    inhibitorKills?: NullableIntFieldUpdateOperationsInput | number | null
    inhibitorTakedowns?: NullableIntFieldUpdateOperationsInput | number | null
    inhibitorsLost?: NullableIntFieldUpdateOperationsInput | number | null
    item0?: NullableIntFieldUpdateOperationsInput | number | null
    item1?: NullableIntFieldUpdateOperationsInput | number | null
    item2?: NullableIntFieldUpdateOperationsInput | number | null
    item3?: NullableIntFieldUpdateOperationsInput | number | null
    item4?: NullableIntFieldUpdateOperationsInput | number | null
    item5?: NullableIntFieldUpdateOperationsInput | number | null
    item6?: NullableIntFieldUpdateOperationsInput | number | null
    itemsPurchased?: NullableIntFieldUpdateOperationsInput | number | null
    killingSprees?: NullableIntFieldUpdateOperationsInput | number | null
    kills?: NullableIntFieldUpdateOperationsInput | number | null
    lane?: StringFieldUpdateOperationsInput | string
    largestCriticalStrike?: NullableIntFieldUpdateOperationsInput | number | null
    largestKillingSpree?: NullableIntFieldUpdateOperationsInput | number | null
    largestMultiKill?: NullableIntFieldUpdateOperationsInput | number | null
    longestTimeSpentLiving?: NullableIntFieldUpdateOperationsInput | number | null
    magicDamageDealt?: NullableIntFieldUpdateOperationsInput | number | null
    magicDamageDealtToChampions?: NullableIntFieldUpdateOperationsInput | number | null
    magicDamageTaken?: NullableIntFieldUpdateOperationsInput | number | null
    neutralMinionsKilled?: NullableIntFieldUpdateOperationsInput | number | null
    nexusKills?: NullableIntFieldUpdateOperationsInput | number | null
    nexusLost?: NullableIntFieldUpdateOperationsInput | number | null
    nexusTakedowns?: NullableIntFieldUpdateOperationsInput | number | null
    objectivesStolen?: NullableIntFieldUpdateOperationsInput | number | null
    objectivesStolenAssists?: NullableIntFieldUpdateOperationsInput | number | null
    participantId?: NullableIntFieldUpdateOperationsInput | number | null
    pentaKills?: NullableIntFieldUpdateOperationsInput | number | null
    physicalDamageDealt?: NullableIntFieldUpdateOperationsInput | number | null
    physicalDamageDealtToChampions?: NullableIntFieldUpdateOperationsInput | number | null
    physicalDamageTaken?: NullableIntFieldUpdateOperationsInput | number | null
    quadraKills?: NullableIntFieldUpdateOperationsInput | number | null
    riotIdName?: StringFieldUpdateOperationsInput | string
    riotIdTagline?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    sightWardsBoughtInGame?: NullableIntFieldUpdateOperationsInput | number | null
    spell1Casts?: NullableIntFieldUpdateOperationsInput | number | null
    spell2Casts?: NullableIntFieldUpdateOperationsInput | number | null
    spell3Casts?: NullableIntFieldUpdateOperationsInput | number | null
    spell4Casts?: NullableIntFieldUpdateOperationsInput | number | null
    summoner1Casts?: NullableIntFieldUpdateOperationsInput | number | null
    summoner1Id?: NullableIntFieldUpdateOperationsInput | number | null
    summoner2Casts?: NullableIntFieldUpdateOperationsInput | number | null
    summoner2Id?: NullableIntFieldUpdateOperationsInput | number | null
    summonerLevel?: NullableIntFieldUpdateOperationsInput | number | null
    summonerName?: StringFieldUpdateOperationsInput | string
    teamEarlySurrendered?: BoolFieldUpdateOperationsInput | boolean
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    teamPosition?: StringFieldUpdateOperationsInput | string
    timeCCingOthers?: NullableIntFieldUpdateOperationsInput | number | null
    timePlayed?: NullableIntFieldUpdateOperationsInput | number | null
    totalDamageDealt?: NullableIntFieldUpdateOperationsInput | number | null
    totalDamageDealtToChampions?: NullableIntFieldUpdateOperationsInput | number | null
    totalDamageShieldedOnTeammates?: NullableIntFieldUpdateOperationsInput | number | null
    totalDamageTaken?: NullableIntFieldUpdateOperationsInput | number | null
    totalHeal?: NullableIntFieldUpdateOperationsInput | number | null
    totalHealsOnTeammates?: NullableIntFieldUpdateOperationsInput | number | null
    totalMinionsKilled?: NullableIntFieldUpdateOperationsInput | number | null
    totalTimeCCDealt?: NullableIntFieldUpdateOperationsInput | number | null
    totalTimeSpentDead?: NullableIntFieldUpdateOperationsInput | number | null
    totalUnitsHealed?: NullableIntFieldUpdateOperationsInput | number | null
    tripleKills?: NullableIntFieldUpdateOperationsInput | number | null
    trueDamageDealt?: NullableIntFieldUpdateOperationsInput | number | null
    trueDamageDealtToChampions?: NullableIntFieldUpdateOperationsInput | number | null
    trueDamageTaken?: NullableIntFieldUpdateOperationsInput | number | null
    turretsKilled?: NullableIntFieldUpdateOperationsInput | number | null
    turretTakedowns?: NullableIntFieldUpdateOperationsInput | number | null
    turretsLost?: NullableIntFieldUpdateOperationsInput | number | null
    unrealKills?: NullableIntFieldUpdateOperationsInput | number | null
    visionScore?: NullableIntFieldUpdateOperationsInput | number | null
    visionWardsBoughtInGame?: NullableIntFieldUpdateOperationsInput | number | null
    wardsKilled?: NullableIntFieldUpdateOperationsInput | number | null
    wardsPlaced?: NullableIntFieldUpdateOperationsInput | number | null
    win?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PlayerEndOfGameStatUncheckedUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: NullableStringFieldUpdateOperationsInput | string | null
    perksId?: NullableStringFieldUpdateOperationsInput | string | null
    itemsId?: NullableStringFieldUpdateOperationsInput | string | null
    assists?: NullableIntFieldUpdateOperationsInput | number | null
    baronKills?: NullableIntFieldUpdateOperationsInput | number | null
    bountyLevel?: NullableIntFieldUpdateOperationsInput | number | null
    championExperience?: NullableIntFieldUpdateOperationsInput | number | null
    championLevel?: NullableIntFieldUpdateOperationsInput | number | null
    championId?: NullableIntFieldUpdateOperationsInput | number | null
    championName?: StringFieldUpdateOperationsInput | string
    championTransform?: NullableIntFieldUpdateOperationsInput | number | null
    consumablesPurchased?: NullableIntFieldUpdateOperationsInput | number | null
    damageDealtToBuildings?: NullableIntFieldUpdateOperationsInput | number | null
    damageDealtToObjectives?: NullableIntFieldUpdateOperationsInput | number | null
    damageDealtToTurrets?: NullableIntFieldUpdateOperationsInput | number | null
    damageSelfMitigated?: NullableIntFieldUpdateOperationsInput | number | null
    deaths?: NullableIntFieldUpdateOperationsInput | number | null
    detectorWardsPlaced?: NullableIntFieldUpdateOperationsInput | number | null
    doubleKills?: NullableIntFieldUpdateOperationsInput | number | null
    dragonKills?: NullableIntFieldUpdateOperationsInput | number | null
    firstBlood?: BoolFieldUpdateOperationsInput | boolean
    firstBloodAssist?: BoolFieldUpdateOperationsInput | boolean
    firstTowerKill?: BoolFieldUpdateOperationsInput | boolean
    firstTowerAssist?: BoolFieldUpdateOperationsInput | boolean
    gameEndedInEarlySurrender?: BoolFieldUpdateOperationsInput | boolean
    gameEndedInSurrender?: BoolFieldUpdateOperationsInput | boolean
    goldEarned?: NullableIntFieldUpdateOperationsInput | number | null
    goldSpent?: NullableIntFieldUpdateOperationsInput | number | null
    individualPosition?: StringFieldUpdateOperationsInput | string
    inhibitorKills?: NullableIntFieldUpdateOperationsInput | number | null
    inhibitorTakedowns?: NullableIntFieldUpdateOperationsInput | number | null
    inhibitorsLost?: NullableIntFieldUpdateOperationsInput | number | null
    item0?: NullableIntFieldUpdateOperationsInput | number | null
    item1?: NullableIntFieldUpdateOperationsInput | number | null
    item2?: NullableIntFieldUpdateOperationsInput | number | null
    item3?: NullableIntFieldUpdateOperationsInput | number | null
    item4?: NullableIntFieldUpdateOperationsInput | number | null
    item5?: NullableIntFieldUpdateOperationsInput | number | null
    item6?: NullableIntFieldUpdateOperationsInput | number | null
    itemsPurchased?: NullableIntFieldUpdateOperationsInput | number | null
    killingSprees?: NullableIntFieldUpdateOperationsInput | number | null
    kills?: NullableIntFieldUpdateOperationsInput | number | null
    lane?: StringFieldUpdateOperationsInput | string
    largestCriticalStrike?: NullableIntFieldUpdateOperationsInput | number | null
    largestKillingSpree?: NullableIntFieldUpdateOperationsInput | number | null
    largestMultiKill?: NullableIntFieldUpdateOperationsInput | number | null
    longestTimeSpentLiving?: NullableIntFieldUpdateOperationsInput | number | null
    magicDamageDealt?: NullableIntFieldUpdateOperationsInput | number | null
    magicDamageDealtToChampions?: NullableIntFieldUpdateOperationsInput | number | null
    magicDamageTaken?: NullableIntFieldUpdateOperationsInput | number | null
    neutralMinionsKilled?: NullableIntFieldUpdateOperationsInput | number | null
    nexusKills?: NullableIntFieldUpdateOperationsInput | number | null
    nexusLost?: NullableIntFieldUpdateOperationsInput | number | null
    nexusTakedowns?: NullableIntFieldUpdateOperationsInput | number | null
    objectivesStolen?: NullableIntFieldUpdateOperationsInput | number | null
    objectivesStolenAssists?: NullableIntFieldUpdateOperationsInput | number | null
    participantId?: NullableIntFieldUpdateOperationsInput | number | null
    pentaKills?: NullableIntFieldUpdateOperationsInput | number | null
    physicalDamageDealt?: NullableIntFieldUpdateOperationsInput | number | null
    physicalDamageDealtToChampions?: NullableIntFieldUpdateOperationsInput | number | null
    physicalDamageTaken?: NullableIntFieldUpdateOperationsInput | number | null
    quadraKills?: NullableIntFieldUpdateOperationsInput | number | null
    riotIdName?: StringFieldUpdateOperationsInput | string
    riotIdTagline?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    sightWardsBoughtInGame?: NullableIntFieldUpdateOperationsInput | number | null
    spell1Casts?: NullableIntFieldUpdateOperationsInput | number | null
    spell2Casts?: NullableIntFieldUpdateOperationsInput | number | null
    spell3Casts?: NullableIntFieldUpdateOperationsInput | number | null
    spell4Casts?: NullableIntFieldUpdateOperationsInput | number | null
    summoner1Casts?: NullableIntFieldUpdateOperationsInput | number | null
    summoner1Id?: NullableIntFieldUpdateOperationsInput | number | null
    summoner2Casts?: NullableIntFieldUpdateOperationsInput | number | null
    summoner2Id?: NullableIntFieldUpdateOperationsInput | number | null
    summonerLevel?: NullableIntFieldUpdateOperationsInput | number | null
    summonerName?: StringFieldUpdateOperationsInput | string
    teamEarlySurrendered?: BoolFieldUpdateOperationsInput | boolean
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    teamPosition?: StringFieldUpdateOperationsInput | string
    timeCCingOthers?: NullableIntFieldUpdateOperationsInput | number | null
    timePlayed?: NullableIntFieldUpdateOperationsInput | number | null
    totalDamageDealt?: NullableIntFieldUpdateOperationsInput | number | null
    totalDamageDealtToChampions?: NullableIntFieldUpdateOperationsInput | number | null
    totalDamageShieldedOnTeammates?: NullableIntFieldUpdateOperationsInput | number | null
    totalDamageTaken?: NullableIntFieldUpdateOperationsInput | number | null
    totalHeal?: NullableIntFieldUpdateOperationsInput | number | null
    totalHealsOnTeammates?: NullableIntFieldUpdateOperationsInput | number | null
    totalMinionsKilled?: NullableIntFieldUpdateOperationsInput | number | null
    totalTimeCCDealt?: NullableIntFieldUpdateOperationsInput | number | null
    totalTimeSpentDead?: NullableIntFieldUpdateOperationsInput | number | null
    totalUnitsHealed?: NullableIntFieldUpdateOperationsInput | number | null
    tripleKills?: NullableIntFieldUpdateOperationsInput | number | null
    trueDamageDealt?: NullableIntFieldUpdateOperationsInput | number | null
    trueDamageDealtToChampions?: NullableIntFieldUpdateOperationsInput | number | null
    trueDamageTaken?: NullableIntFieldUpdateOperationsInput | number | null
    turretsKilled?: NullableIntFieldUpdateOperationsInput | number | null
    turretTakedowns?: NullableIntFieldUpdateOperationsInput | number | null
    turretsLost?: NullableIntFieldUpdateOperationsInput | number | null
    unrealKills?: NullableIntFieldUpdateOperationsInput | number | null
    visionScore?: NullableIntFieldUpdateOperationsInput | number | null
    visionWardsBoughtInGame?: NullableIntFieldUpdateOperationsInput | number | null
    wardsKilled?: NullableIntFieldUpdateOperationsInput | number | null
    wardsPlaced?: NullableIntFieldUpdateOperationsInput | number | null
    win?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PlayerEndOfGameStatUncheckedUpdateManyWithoutEndOfGameStatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: NullableStringFieldUpdateOperationsInput | string | null
    perksId?: NullableStringFieldUpdateOperationsInput | string | null
    itemsId?: NullableStringFieldUpdateOperationsInput | string | null
    assists?: NullableIntFieldUpdateOperationsInput | number | null
    baronKills?: NullableIntFieldUpdateOperationsInput | number | null
    bountyLevel?: NullableIntFieldUpdateOperationsInput | number | null
    championExperience?: NullableIntFieldUpdateOperationsInput | number | null
    championLevel?: NullableIntFieldUpdateOperationsInput | number | null
    championId?: NullableIntFieldUpdateOperationsInput | number | null
    championName?: StringFieldUpdateOperationsInput | string
    championTransform?: NullableIntFieldUpdateOperationsInput | number | null
    consumablesPurchased?: NullableIntFieldUpdateOperationsInput | number | null
    damageDealtToBuildings?: NullableIntFieldUpdateOperationsInput | number | null
    damageDealtToObjectives?: NullableIntFieldUpdateOperationsInput | number | null
    damageDealtToTurrets?: NullableIntFieldUpdateOperationsInput | number | null
    damageSelfMitigated?: NullableIntFieldUpdateOperationsInput | number | null
    deaths?: NullableIntFieldUpdateOperationsInput | number | null
    detectorWardsPlaced?: NullableIntFieldUpdateOperationsInput | number | null
    doubleKills?: NullableIntFieldUpdateOperationsInput | number | null
    dragonKills?: NullableIntFieldUpdateOperationsInput | number | null
    firstBlood?: BoolFieldUpdateOperationsInput | boolean
    firstBloodAssist?: BoolFieldUpdateOperationsInput | boolean
    firstTowerKill?: BoolFieldUpdateOperationsInput | boolean
    firstTowerAssist?: BoolFieldUpdateOperationsInput | boolean
    gameEndedInEarlySurrender?: BoolFieldUpdateOperationsInput | boolean
    gameEndedInSurrender?: BoolFieldUpdateOperationsInput | boolean
    goldEarned?: NullableIntFieldUpdateOperationsInput | number | null
    goldSpent?: NullableIntFieldUpdateOperationsInput | number | null
    individualPosition?: StringFieldUpdateOperationsInput | string
    inhibitorKills?: NullableIntFieldUpdateOperationsInput | number | null
    inhibitorTakedowns?: NullableIntFieldUpdateOperationsInput | number | null
    inhibitorsLost?: NullableIntFieldUpdateOperationsInput | number | null
    item0?: NullableIntFieldUpdateOperationsInput | number | null
    item1?: NullableIntFieldUpdateOperationsInput | number | null
    item2?: NullableIntFieldUpdateOperationsInput | number | null
    item3?: NullableIntFieldUpdateOperationsInput | number | null
    item4?: NullableIntFieldUpdateOperationsInput | number | null
    item5?: NullableIntFieldUpdateOperationsInput | number | null
    item6?: NullableIntFieldUpdateOperationsInput | number | null
    itemsPurchased?: NullableIntFieldUpdateOperationsInput | number | null
    killingSprees?: NullableIntFieldUpdateOperationsInput | number | null
    kills?: NullableIntFieldUpdateOperationsInput | number | null
    lane?: StringFieldUpdateOperationsInput | string
    largestCriticalStrike?: NullableIntFieldUpdateOperationsInput | number | null
    largestKillingSpree?: NullableIntFieldUpdateOperationsInput | number | null
    largestMultiKill?: NullableIntFieldUpdateOperationsInput | number | null
    longestTimeSpentLiving?: NullableIntFieldUpdateOperationsInput | number | null
    magicDamageDealt?: NullableIntFieldUpdateOperationsInput | number | null
    magicDamageDealtToChampions?: NullableIntFieldUpdateOperationsInput | number | null
    magicDamageTaken?: NullableIntFieldUpdateOperationsInput | number | null
    neutralMinionsKilled?: NullableIntFieldUpdateOperationsInput | number | null
    nexusKills?: NullableIntFieldUpdateOperationsInput | number | null
    nexusLost?: NullableIntFieldUpdateOperationsInput | number | null
    nexusTakedowns?: NullableIntFieldUpdateOperationsInput | number | null
    objectivesStolen?: NullableIntFieldUpdateOperationsInput | number | null
    objectivesStolenAssists?: NullableIntFieldUpdateOperationsInput | number | null
    participantId?: NullableIntFieldUpdateOperationsInput | number | null
    pentaKills?: NullableIntFieldUpdateOperationsInput | number | null
    physicalDamageDealt?: NullableIntFieldUpdateOperationsInput | number | null
    physicalDamageDealtToChampions?: NullableIntFieldUpdateOperationsInput | number | null
    physicalDamageTaken?: NullableIntFieldUpdateOperationsInput | number | null
    quadraKills?: NullableIntFieldUpdateOperationsInput | number | null
    riotIdName?: StringFieldUpdateOperationsInput | string
    riotIdTagline?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    sightWardsBoughtInGame?: NullableIntFieldUpdateOperationsInput | number | null
    spell1Casts?: NullableIntFieldUpdateOperationsInput | number | null
    spell2Casts?: NullableIntFieldUpdateOperationsInput | number | null
    spell3Casts?: NullableIntFieldUpdateOperationsInput | number | null
    spell4Casts?: NullableIntFieldUpdateOperationsInput | number | null
    summoner1Casts?: NullableIntFieldUpdateOperationsInput | number | null
    summoner1Id?: NullableIntFieldUpdateOperationsInput | number | null
    summoner2Casts?: NullableIntFieldUpdateOperationsInput | number | null
    summoner2Id?: NullableIntFieldUpdateOperationsInput | number | null
    summonerLevel?: NullableIntFieldUpdateOperationsInput | number | null
    summonerName?: StringFieldUpdateOperationsInput | string
    teamEarlySurrendered?: BoolFieldUpdateOperationsInput | boolean
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    teamPosition?: StringFieldUpdateOperationsInput | string
    timeCCingOthers?: NullableIntFieldUpdateOperationsInput | number | null
    timePlayed?: NullableIntFieldUpdateOperationsInput | number | null
    totalDamageDealt?: NullableIntFieldUpdateOperationsInput | number | null
    totalDamageDealtToChampions?: NullableIntFieldUpdateOperationsInput | number | null
    totalDamageShieldedOnTeammates?: NullableIntFieldUpdateOperationsInput | number | null
    totalDamageTaken?: NullableIntFieldUpdateOperationsInput | number | null
    totalHeal?: NullableIntFieldUpdateOperationsInput | number | null
    totalHealsOnTeammates?: NullableIntFieldUpdateOperationsInput | number | null
    totalMinionsKilled?: NullableIntFieldUpdateOperationsInput | number | null
    totalTimeCCDealt?: NullableIntFieldUpdateOperationsInput | number | null
    totalTimeSpentDead?: NullableIntFieldUpdateOperationsInput | number | null
    totalUnitsHealed?: NullableIntFieldUpdateOperationsInput | number | null
    tripleKills?: NullableIntFieldUpdateOperationsInput | number | null
    trueDamageDealt?: NullableIntFieldUpdateOperationsInput | number | null
    trueDamageDealtToChampions?: NullableIntFieldUpdateOperationsInput | number | null
    trueDamageTaken?: NullableIntFieldUpdateOperationsInput | number | null
    turretsKilled?: NullableIntFieldUpdateOperationsInput | number | null
    turretTakedowns?: NullableIntFieldUpdateOperationsInput | number | null
    turretsLost?: NullableIntFieldUpdateOperationsInput | number | null
    unrealKills?: NullableIntFieldUpdateOperationsInput | number | null
    visionScore?: NullableIntFieldUpdateOperationsInput | number | null
    visionWardsBoughtInGame?: NullableIntFieldUpdateOperationsInput | number | null
    wardsKilled?: NullableIntFieldUpdateOperationsInput | number | null
    wardsPlaced?: NullableIntFieldUpdateOperationsInput | number | null
    win?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PlayerSnapshotUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: NullableFloatFieldUpdateOperationsInput | number | null
    currentGold?: NullableIntFieldUpdateOperationsInput | number | null
    totalGold?: NullableIntFieldUpdateOperationsInput | number | null
    totalGoldDiff?: NullableIntFieldUpdateOperationsInput | number | null
    xp?: NullableIntFieldUpdateOperationsInput | number | null
    xpDiff?: NullableIntFieldUpdateOperationsInput | number | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    cs?: NullableIntFieldUpdateOperationsInput | number | null
    csDiff?: NullableIntFieldUpdateOperationsInput | number | null
    monstersKilled?: NullableIntFieldUpdateOperationsInput | number | null
    monstersKilledDiff?: NullableIntFieldUpdateOperationsInput | number | null
    position?: PositionUpdateManyWithoutPlayerSnapshotInput
  }

  export type PlayerSnapshotUncheckedUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: NullableFloatFieldUpdateOperationsInput | number | null
    currentGold?: NullableIntFieldUpdateOperationsInput | number | null
    totalGold?: NullableIntFieldUpdateOperationsInput | number | null
    totalGoldDiff?: NullableIntFieldUpdateOperationsInput | number | null
    xp?: NullableIntFieldUpdateOperationsInput | number | null
    xpDiff?: NullableIntFieldUpdateOperationsInput | number | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    cs?: NullableIntFieldUpdateOperationsInput | number | null
    csDiff?: NullableIntFieldUpdateOperationsInput | number | null
    monstersKilled?: NullableIntFieldUpdateOperationsInput | number | null
    monstersKilledDiff?: NullableIntFieldUpdateOperationsInput | number | null
    position?: PositionUncheckedUpdateManyWithoutPlayerSnapshotInput
  }

  export type PlayerSnapshotUncheckedUpdateManyWithoutSnapshotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: NullableFloatFieldUpdateOperationsInput | number | null
    currentGold?: NullableIntFieldUpdateOperationsInput | number | null
    totalGold?: NullableIntFieldUpdateOperationsInput | number | null
    totalGoldDiff?: NullableIntFieldUpdateOperationsInput | number | null
    xp?: NullableIntFieldUpdateOperationsInput | number | null
    xpDiff?: NullableIntFieldUpdateOperationsInput | number | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    cs?: NullableIntFieldUpdateOperationsInput | number | null
    csDiff?: NullableIntFieldUpdateOperationsInput | number | null
    monstersKilled?: NullableIntFieldUpdateOperationsInput | number | null
    monstersKilledDiff?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PlayerWardEventUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    wardType?: NullableEnumPlayerWardEventWardTypeTypeFieldUpdateOperationsInput | PlayerWardEventWardTypeType | null
  }

  export type PlayerWardEventUncheckedUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    wardType?: NullableEnumPlayerWardEventWardTypeTypeFieldUpdateOperationsInput | PlayerWardEventWardTypeType | null
  }

  export type PlayerWardEventUncheckedUpdateManyWithoutWardEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    wardType?: NullableEnumPlayerWardEventWardTypeTypeFieldUpdateOperationsInput | PlayerWardEventWardTypeType | null
  }

  export type PlayerSkillLevelUpEventUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    slot?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PlayerSkillLevelUpEventUncheckedUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    slot?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PlayerSkillLevelUpEventUncheckedUpdateManyWithoutSkillLevelUpEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    slot?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PlayerEndOfGameStatCreateManyItemsInput = {
    id?: string
    playerId?: string | null
    gameId?: string | null
    perksId?: string | null
    assists?: number | null
    baronKills?: number | null
    bountyLevel?: number | null
    championExperience?: number | null
    championLevel?: number | null
    championId?: number | null
    championName?: string
    championTransform?: number | null
    consumablesPurchased?: number | null
    damageDealtToBuildings?: number | null
    damageDealtToObjectives?: number | null
    damageDealtToTurrets?: number | null
    damageSelfMitigated?: number | null
    deaths?: number | null
    detectorWardsPlaced?: number | null
    doubleKills?: number | null
    dragonKills?: number | null
    firstBlood?: boolean
    firstBloodAssist?: boolean
    firstTowerKill?: boolean
    firstTowerAssist?: boolean
    gameEndedInEarlySurrender?: boolean
    gameEndedInSurrender?: boolean
    goldEarned?: number | null
    goldSpent?: number | null
    individualPosition?: string
    inhibitorKills?: number | null
    inhibitorTakedowns?: number | null
    inhibitorsLost?: number | null
    item0?: number | null
    item1?: number | null
    item2?: number | null
    item3?: number | null
    item4?: number | null
    item5?: number | null
    item6?: number | null
    itemsPurchased?: number | null
    killingSprees?: number | null
    kills?: number | null
    lane?: string
    largestCriticalStrike?: number | null
    largestKillingSpree?: number | null
    largestMultiKill?: number | null
    longestTimeSpentLiving?: number | null
    magicDamageDealt?: number | null
    magicDamageDealtToChampions?: number | null
    magicDamageTaken?: number | null
    neutralMinionsKilled?: number | null
    nexusKills?: number | null
    nexusLost?: number | null
    nexusTakedowns?: number | null
    objectivesStolen?: number | null
    objectivesStolenAssists?: number | null
    participantId?: number | null
    pentaKills?: number | null
    physicalDamageDealt?: number | null
    physicalDamageDealtToChampions?: number | null
    physicalDamageTaken?: number | null
    quadraKills?: number | null
    riotIdName?: string
    riotIdTagline?: string
    role?: string
    sightWardsBoughtInGame?: number | null
    spell1Casts?: number | null
    spell2Casts?: number | null
    spell3Casts?: number | null
    spell4Casts?: number | null
    summoner1Casts?: number | null
    summoner1Id?: number | null
    summoner2Casts?: number | null
    summoner2Id?: number | null
    summonerLevel?: number | null
    summonerName?: string
    teamEarlySurrendered?: boolean
    teamId?: number | null
    teamPosition?: string
    timeCCingOthers?: number | null
    timePlayed?: number | null
    totalDamageDealt?: number | null
    totalDamageDealtToChampions?: number | null
    totalDamageShieldedOnTeammates?: number | null
    totalDamageTaken?: number | null
    totalHeal?: number | null
    totalHealsOnTeammates?: number | null
    totalMinionsKilled?: number | null
    totalTimeCCDealt?: number | null
    totalTimeSpentDead?: number | null
    totalUnitsHealed?: number | null
    tripleKills?: number | null
    trueDamageDealt?: number | null
    trueDamageDealtToChampions?: number | null
    trueDamageTaken?: number | null
    turretsKilled?: number | null
    turretTakedowns?: number | null
    turretsLost?: number | null
    unrealKills?: number | null
    visionScore?: number | null
    visionWardsBoughtInGame?: number | null
    wardsKilled?: number | null
    wardsPlaced?: number | null
    win?: boolean
  }

  export type PlayerEndOfGameStatUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    player?: PlayerUpdateOneWithoutEndOfGameStatsInput
    game?: GameUpdateOneWithoutFrom_PlayerEndOfGameStat_gameInput
    perks?: PlayerRuneUpdateOneWithoutPlayerEndOfGameStatInput
    assists?: NullableIntFieldUpdateOperationsInput | number | null
    baronKills?: NullableIntFieldUpdateOperationsInput | number | null
    bountyLevel?: NullableIntFieldUpdateOperationsInput | number | null
    championExperience?: NullableIntFieldUpdateOperationsInput | number | null
    championLevel?: NullableIntFieldUpdateOperationsInput | number | null
    championId?: NullableIntFieldUpdateOperationsInput | number | null
    championName?: StringFieldUpdateOperationsInput | string
    championTransform?: NullableIntFieldUpdateOperationsInput | number | null
    consumablesPurchased?: NullableIntFieldUpdateOperationsInput | number | null
    damageDealtToBuildings?: NullableIntFieldUpdateOperationsInput | number | null
    damageDealtToObjectives?: NullableIntFieldUpdateOperationsInput | number | null
    damageDealtToTurrets?: NullableIntFieldUpdateOperationsInput | number | null
    damageSelfMitigated?: NullableIntFieldUpdateOperationsInput | number | null
    deaths?: NullableIntFieldUpdateOperationsInput | number | null
    detectorWardsPlaced?: NullableIntFieldUpdateOperationsInput | number | null
    doubleKills?: NullableIntFieldUpdateOperationsInput | number | null
    dragonKills?: NullableIntFieldUpdateOperationsInput | number | null
    firstBlood?: BoolFieldUpdateOperationsInput | boolean
    firstBloodAssist?: BoolFieldUpdateOperationsInput | boolean
    firstTowerKill?: BoolFieldUpdateOperationsInput | boolean
    firstTowerAssist?: BoolFieldUpdateOperationsInput | boolean
    gameEndedInEarlySurrender?: BoolFieldUpdateOperationsInput | boolean
    gameEndedInSurrender?: BoolFieldUpdateOperationsInput | boolean
    goldEarned?: NullableIntFieldUpdateOperationsInput | number | null
    goldSpent?: NullableIntFieldUpdateOperationsInput | number | null
    individualPosition?: StringFieldUpdateOperationsInput | string
    inhibitorKills?: NullableIntFieldUpdateOperationsInput | number | null
    inhibitorTakedowns?: NullableIntFieldUpdateOperationsInput | number | null
    inhibitorsLost?: NullableIntFieldUpdateOperationsInput | number | null
    item0?: NullableIntFieldUpdateOperationsInput | number | null
    item1?: NullableIntFieldUpdateOperationsInput | number | null
    item2?: NullableIntFieldUpdateOperationsInput | number | null
    item3?: NullableIntFieldUpdateOperationsInput | number | null
    item4?: NullableIntFieldUpdateOperationsInput | number | null
    item5?: NullableIntFieldUpdateOperationsInput | number | null
    item6?: NullableIntFieldUpdateOperationsInput | number | null
    itemsPurchased?: NullableIntFieldUpdateOperationsInput | number | null
    killingSprees?: NullableIntFieldUpdateOperationsInput | number | null
    kills?: NullableIntFieldUpdateOperationsInput | number | null
    lane?: StringFieldUpdateOperationsInput | string
    largestCriticalStrike?: NullableIntFieldUpdateOperationsInput | number | null
    largestKillingSpree?: NullableIntFieldUpdateOperationsInput | number | null
    largestMultiKill?: NullableIntFieldUpdateOperationsInput | number | null
    longestTimeSpentLiving?: NullableIntFieldUpdateOperationsInput | number | null
    magicDamageDealt?: NullableIntFieldUpdateOperationsInput | number | null
    magicDamageDealtToChampions?: NullableIntFieldUpdateOperationsInput | number | null
    magicDamageTaken?: NullableIntFieldUpdateOperationsInput | number | null
    neutralMinionsKilled?: NullableIntFieldUpdateOperationsInput | number | null
    nexusKills?: NullableIntFieldUpdateOperationsInput | number | null
    nexusLost?: NullableIntFieldUpdateOperationsInput | number | null
    nexusTakedowns?: NullableIntFieldUpdateOperationsInput | number | null
    objectivesStolen?: NullableIntFieldUpdateOperationsInput | number | null
    objectivesStolenAssists?: NullableIntFieldUpdateOperationsInput | number | null
    participantId?: NullableIntFieldUpdateOperationsInput | number | null
    pentaKills?: NullableIntFieldUpdateOperationsInput | number | null
    physicalDamageDealt?: NullableIntFieldUpdateOperationsInput | number | null
    physicalDamageDealtToChampions?: NullableIntFieldUpdateOperationsInput | number | null
    physicalDamageTaken?: NullableIntFieldUpdateOperationsInput | number | null
    quadraKills?: NullableIntFieldUpdateOperationsInput | number | null
    riotIdName?: StringFieldUpdateOperationsInput | string
    riotIdTagline?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    sightWardsBoughtInGame?: NullableIntFieldUpdateOperationsInput | number | null
    spell1Casts?: NullableIntFieldUpdateOperationsInput | number | null
    spell2Casts?: NullableIntFieldUpdateOperationsInput | number | null
    spell3Casts?: NullableIntFieldUpdateOperationsInput | number | null
    spell4Casts?: NullableIntFieldUpdateOperationsInput | number | null
    summoner1Casts?: NullableIntFieldUpdateOperationsInput | number | null
    summoner1Id?: NullableIntFieldUpdateOperationsInput | number | null
    summoner2Casts?: NullableIntFieldUpdateOperationsInput | number | null
    summoner2Id?: NullableIntFieldUpdateOperationsInput | number | null
    summonerLevel?: NullableIntFieldUpdateOperationsInput | number | null
    summonerName?: StringFieldUpdateOperationsInput | string
    teamEarlySurrendered?: BoolFieldUpdateOperationsInput | boolean
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    teamPosition?: StringFieldUpdateOperationsInput | string
    timeCCingOthers?: NullableIntFieldUpdateOperationsInput | number | null
    timePlayed?: NullableIntFieldUpdateOperationsInput | number | null
    totalDamageDealt?: NullableIntFieldUpdateOperationsInput | number | null
    totalDamageDealtToChampions?: NullableIntFieldUpdateOperationsInput | number | null
    totalDamageShieldedOnTeammates?: NullableIntFieldUpdateOperationsInput | number | null
    totalDamageTaken?: NullableIntFieldUpdateOperationsInput | number | null
    totalHeal?: NullableIntFieldUpdateOperationsInput | number | null
    totalHealsOnTeammates?: NullableIntFieldUpdateOperationsInput | number | null
    totalMinionsKilled?: NullableIntFieldUpdateOperationsInput | number | null
    totalTimeCCDealt?: NullableIntFieldUpdateOperationsInput | number | null
    totalTimeSpentDead?: NullableIntFieldUpdateOperationsInput | number | null
    totalUnitsHealed?: NullableIntFieldUpdateOperationsInput | number | null
    tripleKills?: NullableIntFieldUpdateOperationsInput | number | null
    trueDamageDealt?: NullableIntFieldUpdateOperationsInput | number | null
    trueDamageDealtToChampions?: NullableIntFieldUpdateOperationsInput | number | null
    trueDamageTaken?: NullableIntFieldUpdateOperationsInput | number | null
    turretsKilled?: NullableIntFieldUpdateOperationsInput | number | null
    turretTakedowns?: NullableIntFieldUpdateOperationsInput | number | null
    turretsLost?: NullableIntFieldUpdateOperationsInput | number | null
    unrealKills?: NullableIntFieldUpdateOperationsInput | number | null
    visionScore?: NullableIntFieldUpdateOperationsInput | number | null
    visionWardsBoughtInGame?: NullableIntFieldUpdateOperationsInput | number | null
    wardsKilled?: NullableIntFieldUpdateOperationsInput | number | null
    wardsPlaced?: NullableIntFieldUpdateOperationsInput | number | null
    win?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PlayerEndOfGameStatUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: NullableStringFieldUpdateOperationsInput | string | null
    gameId?: NullableStringFieldUpdateOperationsInput | string | null
    perksId?: NullableStringFieldUpdateOperationsInput | string | null
    assists?: NullableIntFieldUpdateOperationsInput | number | null
    baronKills?: NullableIntFieldUpdateOperationsInput | number | null
    bountyLevel?: NullableIntFieldUpdateOperationsInput | number | null
    championExperience?: NullableIntFieldUpdateOperationsInput | number | null
    championLevel?: NullableIntFieldUpdateOperationsInput | number | null
    championId?: NullableIntFieldUpdateOperationsInput | number | null
    championName?: StringFieldUpdateOperationsInput | string
    championTransform?: NullableIntFieldUpdateOperationsInput | number | null
    consumablesPurchased?: NullableIntFieldUpdateOperationsInput | number | null
    damageDealtToBuildings?: NullableIntFieldUpdateOperationsInput | number | null
    damageDealtToObjectives?: NullableIntFieldUpdateOperationsInput | number | null
    damageDealtToTurrets?: NullableIntFieldUpdateOperationsInput | number | null
    damageSelfMitigated?: NullableIntFieldUpdateOperationsInput | number | null
    deaths?: NullableIntFieldUpdateOperationsInput | number | null
    detectorWardsPlaced?: NullableIntFieldUpdateOperationsInput | number | null
    doubleKills?: NullableIntFieldUpdateOperationsInput | number | null
    dragonKills?: NullableIntFieldUpdateOperationsInput | number | null
    firstBlood?: BoolFieldUpdateOperationsInput | boolean
    firstBloodAssist?: BoolFieldUpdateOperationsInput | boolean
    firstTowerKill?: BoolFieldUpdateOperationsInput | boolean
    firstTowerAssist?: BoolFieldUpdateOperationsInput | boolean
    gameEndedInEarlySurrender?: BoolFieldUpdateOperationsInput | boolean
    gameEndedInSurrender?: BoolFieldUpdateOperationsInput | boolean
    goldEarned?: NullableIntFieldUpdateOperationsInput | number | null
    goldSpent?: NullableIntFieldUpdateOperationsInput | number | null
    individualPosition?: StringFieldUpdateOperationsInput | string
    inhibitorKills?: NullableIntFieldUpdateOperationsInput | number | null
    inhibitorTakedowns?: NullableIntFieldUpdateOperationsInput | number | null
    inhibitorsLost?: NullableIntFieldUpdateOperationsInput | number | null
    item0?: NullableIntFieldUpdateOperationsInput | number | null
    item1?: NullableIntFieldUpdateOperationsInput | number | null
    item2?: NullableIntFieldUpdateOperationsInput | number | null
    item3?: NullableIntFieldUpdateOperationsInput | number | null
    item4?: NullableIntFieldUpdateOperationsInput | number | null
    item5?: NullableIntFieldUpdateOperationsInput | number | null
    item6?: NullableIntFieldUpdateOperationsInput | number | null
    itemsPurchased?: NullableIntFieldUpdateOperationsInput | number | null
    killingSprees?: NullableIntFieldUpdateOperationsInput | number | null
    kills?: NullableIntFieldUpdateOperationsInput | number | null
    lane?: StringFieldUpdateOperationsInput | string
    largestCriticalStrike?: NullableIntFieldUpdateOperationsInput | number | null
    largestKillingSpree?: NullableIntFieldUpdateOperationsInput | number | null
    largestMultiKill?: NullableIntFieldUpdateOperationsInput | number | null
    longestTimeSpentLiving?: NullableIntFieldUpdateOperationsInput | number | null
    magicDamageDealt?: NullableIntFieldUpdateOperationsInput | number | null
    magicDamageDealtToChampions?: NullableIntFieldUpdateOperationsInput | number | null
    magicDamageTaken?: NullableIntFieldUpdateOperationsInput | number | null
    neutralMinionsKilled?: NullableIntFieldUpdateOperationsInput | number | null
    nexusKills?: NullableIntFieldUpdateOperationsInput | number | null
    nexusLost?: NullableIntFieldUpdateOperationsInput | number | null
    nexusTakedowns?: NullableIntFieldUpdateOperationsInput | number | null
    objectivesStolen?: NullableIntFieldUpdateOperationsInput | number | null
    objectivesStolenAssists?: NullableIntFieldUpdateOperationsInput | number | null
    participantId?: NullableIntFieldUpdateOperationsInput | number | null
    pentaKills?: NullableIntFieldUpdateOperationsInput | number | null
    physicalDamageDealt?: NullableIntFieldUpdateOperationsInput | number | null
    physicalDamageDealtToChampions?: NullableIntFieldUpdateOperationsInput | number | null
    physicalDamageTaken?: NullableIntFieldUpdateOperationsInput | number | null
    quadraKills?: NullableIntFieldUpdateOperationsInput | number | null
    riotIdName?: StringFieldUpdateOperationsInput | string
    riotIdTagline?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    sightWardsBoughtInGame?: NullableIntFieldUpdateOperationsInput | number | null
    spell1Casts?: NullableIntFieldUpdateOperationsInput | number | null
    spell2Casts?: NullableIntFieldUpdateOperationsInput | number | null
    spell3Casts?: NullableIntFieldUpdateOperationsInput | number | null
    spell4Casts?: NullableIntFieldUpdateOperationsInput | number | null
    summoner1Casts?: NullableIntFieldUpdateOperationsInput | number | null
    summoner1Id?: NullableIntFieldUpdateOperationsInput | number | null
    summoner2Casts?: NullableIntFieldUpdateOperationsInput | number | null
    summoner2Id?: NullableIntFieldUpdateOperationsInput | number | null
    summonerLevel?: NullableIntFieldUpdateOperationsInput | number | null
    summonerName?: StringFieldUpdateOperationsInput | string
    teamEarlySurrendered?: BoolFieldUpdateOperationsInput | boolean
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    teamPosition?: StringFieldUpdateOperationsInput | string
    timeCCingOthers?: NullableIntFieldUpdateOperationsInput | number | null
    timePlayed?: NullableIntFieldUpdateOperationsInput | number | null
    totalDamageDealt?: NullableIntFieldUpdateOperationsInput | number | null
    totalDamageDealtToChampions?: NullableIntFieldUpdateOperationsInput | number | null
    totalDamageShieldedOnTeammates?: NullableIntFieldUpdateOperationsInput | number | null
    totalDamageTaken?: NullableIntFieldUpdateOperationsInput | number | null
    totalHeal?: NullableIntFieldUpdateOperationsInput | number | null
    totalHealsOnTeammates?: NullableIntFieldUpdateOperationsInput | number | null
    totalMinionsKilled?: NullableIntFieldUpdateOperationsInput | number | null
    totalTimeCCDealt?: NullableIntFieldUpdateOperationsInput | number | null
    totalTimeSpentDead?: NullableIntFieldUpdateOperationsInput | number | null
    totalUnitsHealed?: NullableIntFieldUpdateOperationsInput | number | null
    tripleKills?: NullableIntFieldUpdateOperationsInput | number | null
    trueDamageDealt?: NullableIntFieldUpdateOperationsInput | number | null
    trueDamageDealtToChampions?: NullableIntFieldUpdateOperationsInput | number | null
    trueDamageTaken?: NullableIntFieldUpdateOperationsInput | number | null
    turretsKilled?: NullableIntFieldUpdateOperationsInput | number | null
    turretTakedowns?: NullableIntFieldUpdateOperationsInput | number | null
    turretsLost?: NullableIntFieldUpdateOperationsInput | number | null
    unrealKills?: NullableIntFieldUpdateOperationsInput | number | null
    visionScore?: NullableIntFieldUpdateOperationsInput | number | null
    visionWardsBoughtInGame?: NullableIntFieldUpdateOperationsInput | number | null
    wardsKilled?: NullableIntFieldUpdateOperationsInput | number | null
    wardsPlaced?: NullableIntFieldUpdateOperationsInput | number | null
    win?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PlayerEndOfGameStatUncheckedUpdateManyWithoutPlayerEndOfGameStatInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: NullableStringFieldUpdateOperationsInput | string | null
    gameId?: NullableStringFieldUpdateOperationsInput | string | null
    perksId?: NullableStringFieldUpdateOperationsInput | string | null
    assists?: NullableIntFieldUpdateOperationsInput | number | null
    baronKills?: NullableIntFieldUpdateOperationsInput | number | null
    bountyLevel?: NullableIntFieldUpdateOperationsInput | number | null
    championExperience?: NullableIntFieldUpdateOperationsInput | number | null
    championLevel?: NullableIntFieldUpdateOperationsInput | number | null
    championId?: NullableIntFieldUpdateOperationsInput | number | null
    championName?: StringFieldUpdateOperationsInput | string
    championTransform?: NullableIntFieldUpdateOperationsInput | number | null
    consumablesPurchased?: NullableIntFieldUpdateOperationsInput | number | null
    damageDealtToBuildings?: NullableIntFieldUpdateOperationsInput | number | null
    damageDealtToObjectives?: NullableIntFieldUpdateOperationsInput | number | null
    damageDealtToTurrets?: NullableIntFieldUpdateOperationsInput | number | null
    damageSelfMitigated?: NullableIntFieldUpdateOperationsInput | number | null
    deaths?: NullableIntFieldUpdateOperationsInput | number | null
    detectorWardsPlaced?: NullableIntFieldUpdateOperationsInput | number | null
    doubleKills?: NullableIntFieldUpdateOperationsInput | number | null
    dragonKills?: NullableIntFieldUpdateOperationsInput | number | null
    firstBlood?: BoolFieldUpdateOperationsInput | boolean
    firstBloodAssist?: BoolFieldUpdateOperationsInput | boolean
    firstTowerKill?: BoolFieldUpdateOperationsInput | boolean
    firstTowerAssist?: BoolFieldUpdateOperationsInput | boolean
    gameEndedInEarlySurrender?: BoolFieldUpdateOperationsInput | boolean
    gameEndedInSurrender?: BoolFieldUpdateOperationsInput | boolean
    goldEarned?: NullableIntFieldUpdateOperationsInput | number | null
    goldSpent?: NullableIntFieldUpdateOperationsInput | number | null
    individualPosition?: StringFieldUpdateOperationsInput | string
    inhibitorKills?: NullableIntFieldUpdateOperationsInput | number | null
    inhibitorTakedowns?: NullableIntFieldUpdateOperationsInput | number | null
    inhibitorsLost?: NullableIntFieldUpdateOperationsInput | number | null
    item0?: NullableIntFieldUpdateOperationsInput | number | null
    item1?: NullableIntFieldUpdateOperationsInput | number | null
    item2?: NullableIntFieldUpdateOperationsInput | number | null
    item3?: NullableIntFieldUpdateOperationsInput | number | null
    item4?: NullableIntFieldUpdateOperationsInput | number | null
    item5?: NullableIntFieldUpdateOperationsInput | number | null
    item6?: NullableIntFieldUpdateOperationsInput | number | null
    itemsPurchased?: NullableIntFieldUpdateOperationsInput | number | null
    killingSprees?: NullableIntFieldUpdateOperationsInput | number | null
    kills?: NullableIntFieldUpdateOperationsInput | number | null
    lane?: StringFieldUpdateOperationsInput | string
    largestCriticalStrike?: NullableIntFieldUpdateOperationsInput | number | null
    largestKillingSpree?: NullableIntFieldUpdateOperationsInput | number | null
    largestMultiKill?: NullableIntFieldUpdateOperationsInput | number | null
    longestTimeSpentLiving?: NullableIntFieldUpdateOperationsInput | number | null
    magicDamageDealt?: NullableIntFieldUpdateOperationsInput | number | null
    magicDamageDealtToChampions?: NullableIntFieldUpdateOperationsInput | number | null
    magicDamageTaken?: NullableIntFieldUpdateOperationsInput | number | null
    neutralMinionsKilled?: NullableIntFieldUpdateOperationsInput | number | null
    nexusKills?: NullableIntFieldUpdateOperationsInput | number | null
    nexusLost?: NullableIntFieldUpdateOperationsInput | number | null
    nexusTakedowns?: NullableIntFieldUpdateOperationsInput | number | null
    objectivesStolen?: NullableIntFieldUpdateOperationsInput | number | null
    objectivesStolenAssists?: NullableIntFieldUpdateOperationsInput | number | null
    participantId?: NullableIntFieldUpdateOperationsInput | number | null
    pentaKills?: NullableIntFieldUpdateOperationsInput | number | null
    physicalDamageDealt?: NullableIntFieldUpdateOperationsInput | number | null
    physicalDamageDealtToChampions?: NullableIntFieldUpdateOperationsInput | number | null
    physicalDamageTaken?: NullableIntFieldUpdateOperationsInput | number | null
    quadraKills?: NullableIntFieldUpdateOperationsInput | number | null
    riotIdName?: StringFieldUpdateOperationsInput | string
    riotIdTagline?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    sightWardsBoughtInGame?: NullableIntFieldUpdateOperationsInput | number | null
    spell1Casts?: NullableIntFieldUpdateOperationsInput | number | null
    spell2Casts?: NullableIntFieldUpdateOperationsInput | number | null
    spell3Casts?: NullableIntFieldUpdateOperationsInput | number | null
    spell4Casts?: NullableIntFieldUpdateOperationsInput | number | null
    summoner1Casts?: NullableIntFieldUpdateOperationsInput | number | null
    summoner1Id?: NullableIntFieldUpdateOperationsInput | number | null
    summoner2Casts?: NullableIntFieldUpdateOperationsInput | number | null
    summoner2Id?: NullableIntFieldUpdateOperationsInput | number | null
    summonerLevel?: NullableIntFieldUpdateOperationsInput | number | null
    summonerName?: StringFieldUpdateOperationsInput | string
    teamEarlySurrendered?: BoolFieldUpdateOperationsInput | boolean
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    teamPosition?: StringFieldUpdateOperationsInput | string
    timeCCingOthers?: NullableIntFieldUpdateOperationsInput | number | null
    timePlayed?: NullableIntFieldUpdateOperationsInput | number | null
    totalDamageDealt?: NullableIntFieldUpdateOperationsInput | number | null
    totalDamageDealtToChampions?: NullableIntFieldUpdateOperationsInput | number | null
    totalDamageShieldedOnTeammates?: NullableIntFieldUpdateOperationsInput | number | null
    totalDamageTaken?: NullableIntFieldUpdateOperationsInput | number | null
    totalHeal?: NullableIntFieldUpdateOperationsInput | number | null
    totalHealsOnTeammates?: NullableIntFieldUpdateOperationsInput | number | null
    totalMinionsKilled?: NullableIntFieldUpdateOperationsInput | number | null
    totalTimeCCDealt?: NullableIntFieldUpdateOperationsInput | number | null
    totalTimeSpentDead?: NullableIntFieldUpdateOperationsInput | number | null
    totalUnitsHealed?: NullableIntFieldUpdateOperationsInput | number | null
    tripleKills?: NullableIntFieldUpdateOperationsInput | number | null
    trueDamageDealt?: NullableIntFieldUpdateOperationsInput | number | null
    trueDamageDealtToChampions?: NullableIntFieldUpdateOperationsInput | number | null
    trueDamageTaken?: NullableIntFieldUpdateOperationsInput | number | null
    turretsKilled?: NullableIntFieldUpdateOperationsInput | number | null
    turretTakedowns?: NullableIntFieldUpdateOperationsInput | number | null
    turretsLost?: NullableIntFieldUpdateOperationsInput | number | null
    unrealKills?: NullableIntFieldUpdateOperationsInput | number | null
    visionScore?: NullableIntFieldUpdateOperationsInput | number | null
    visionWardsBoughtInGame?: NullableIntFieldUpdateOperationsInput | number | null
    wardsKilled?: NullableIntFieldUpdateOperationsInput | number | null
    wardsPlaced?: NullableIntFieldUpdateOperationsInput | number | null
    win?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PlayerUpdateWithoutItemEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    puuid?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    platformId?: StringFieldUpdateOperationsInput | string
    summonerId?: StringFieldUpdateOperationsInput | string
    summonerName?: StringFieldUpdateOperationsInput | string
    summonerLevel?: NullableIntFieldUpdateOperationsInput | number | null
    profileIconId?: NullableIntFieldUpdateOperationsInput | number | null
    revisionDate?: StringFieldUpdateOperationsInput | string
    kills?: PlayerKillUpdateManyWithoutKillerInput
    deaths?: PlayerKillUpdateManyWithoutVictimInput
    teams?: TeamUpdateManyWithoutPlayersInput
    profile?: ProfileUpdateOneWithoutPlayerInput
    monsterKills?: TeamMonsterKillUpdateManyWithoutKillerInput
    buildingKills?: TeamBuildingKillUpdateManyWithoutKillerInput
    endOfGameStats?: PlayerEndOfGameStatUpdateManyWithoutPlayerInput
    snapshots?: PlayerSnapshotUpdateManyWithoutPlayerInput
    wardEvents?: PlayerWardEventUpdateManyWithoutPlayerInput
    skillLevelUpEvents?: PlayerSkillLevelUpEventUpdateManyWithoutPlayerInput
  }

  export type PlayerUncheckedUpdateWithoutItemEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    puuid?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    platformId?: StringFieldUpdateOperationsInput | string
    summonerId?: StringFieldUpdateOperationsInput | string
    summonerName?: StringFieldUpdateOperationsInput | string
    summonerLevel?: NullableIntFieldUpdateOperationsInput | number | null
    profileIconId?: NullableIntFieldUpdateOperationsInput | number | null
    revisionDate?: StringFieldUpdateOperationsInput | string
    kills?: PlayerKillUncheckedUpdateManyWithoutKillerInput
    deaths?: PlayerKillUncheckedUpdateManyWithoutVictimInput
    teams?: TeamUncheckedUpdateManyWithoutPlayersInput
    profileId?: NullableStringFieldUpdateOperationsInput | string | null
    monsterKills?: TeamMonsterKillUncheckedUpdateManyWithoutKillerInput
    buildingKills?: TeamBuildingKillUncheckedUpdateManyWithoutKillerInput
    endOfGameStats?: PlayerEndOfGameStatUncheckedUpdateManyWithoutPlayerInput
    snapshots?: PlayerSnapshotUncheckedUpdateManyWithoutPlayerInput
    wardEvents?: PlayerWardEventUncheckedUpdateManyWithoutPlayerInput
    skillLevelUpEvents?: PlayerSkillLevelUpEventUncheckedUpdateManyWithoutPlayerInput
  }

  export type PlayerUncheckedUpdateManyWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    puuid?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    platformId?: StringFieldUpdateOperationsInput | string
    summonerId?: StringFieldUpdateOperationsInput | string
    summonerName?: StringFieldUpdateOperationsInput | string
    summonerLevel?: NullableIntFieldUpdateOperationsInput | number | null
    profileIconId?: NullableIntFieldUpdateOperationsInput | number | null
    revisionDate?: StringFieldUpdateOperationsInput | string
    profileId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PlayerUpdateWithoutKillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    puuid?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    platformId?: StringFieldUpdateOperationsInput | string
    summonerId?: StringFieldUpdateOperationsInput | string
    summonerName?: StringFieldUpdateOperationsInput | string
    summonerLevel?: NullableIntFieldUpdateOperationsInput | number | null
    profileIconId?: NullableIntFieldUpdateOperationsInput | number | null
    revisionDate?: StringFieldUpdateOperationsInput | string
    deaths?: PlayerKillUpdateManyWithoutVictimInput
    teams?: TeamUpdateManyWithoutPlayersInput
    profile?: ProfileUpdateOneWithoutPlayerInput
    monsterKills?: TeamMonsterKillUpdateManyWithoutKillerInput
    buildingKills?: TeamBuildingKillUpdateManyWithoutKillerInput
    itemEvent?: PlayerItemEventUpdateManyWithoutPlayerInput
    endOfGameStats?: PlayerEndOfGameStatUpdateManyWithoutPlayerInput
    snapshots?: PlayerSnapshotUpdateManyWithoutPlayerInput
    wardEvents?: PlayerWardEventUpdateManyWithoutPlayerInput
    skillLevelUpEvents?: PlayerSkillLevelUpEventUpdateManyWithoutPlayerInput
  }

  export type PlayerUncheckedUpdateWithoutKillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    puuid?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    platformId?: StringFieldUpdateOperationsInput | string
    summonerId?: StringFieldUpdateOperationsInput | string
    summonerName?: StringFieldUpdateOperationsInput | string
    summonerLevel?: NullableIntFieldUpdateOperationsInput | number | null
    profileIconId?: NullableIntFieldUpdateOperationsInput | number | null
    revisionDate?: StringFieldUpdateOperationsInput | string
    deaths?: PlayerKillUncheckedUpdateManyWithoutVictimInput
    teams?: TeamUncheckedUpdateManyWithoutPlayersInput
    profileId?: NullableStringFieldUpdateOperationsInput | string | null
    monsterKills?: TeamMonsterKillUncheckedUpdateManyWithoutKillerInput
    buildingKills?: TeamBuildingKillUncheckedUpdateManyWithoutKillerInput
    itemEvent?: PlayerItemEventUncheckedUpdateManyWithoutPlayerInput
    endOfGameStats?: PlayerEndOfGameStatUncheckedUpdateManyWithoutPlayerInput
    snapshots?: PlayerSnapshotUncheckedUpdateManyWithoutPlayerInput
    wardEvents?: PlayerWardEventUncheckedUpdateManyWithoutPlayerInput
    skillLevelUpEvents?: PlayerSkillLevelUpEventUncheckedUpdateManyWithoutPlayerInput
  }

  export type PlayerUncheckedUpdateManyWithoutKillerInput = {
    id?: StringFieldUpdateOperationsInput | string
    puuid?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    platformId?: StringFieldUpdateOperationsInput | string
    summonerId?: StringFieldUpdateOperationsInput | string
    summonerName?: StringFieldUpdateOperationsInput | string
    summonerLevel?: NullableIntFieldUpdateOperationsInput | number | null
    profileIconId?: NullableIntFieldUpdateOperationsInput | number | null
    revisionDate?: StringFieldUpdateOperationsInput | string
    profileId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PlayerUpdateWithoutDeathsInput = {
    id?: StringFieldUpdateOperationsInput | string
    puuid?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    platformId?: StringFieldUpdateOperationsInput | string
    summonerId?: StringFieldUpdateOperationsInput | string
    summonerName?: StringFieldUpdateOperationsInput | string
    summonerLevel?: NullableIntFieldUpdateOperationsInput | number | null
    profileIconId?: NullableIntFieldUpdateOperationsInput | number | null
    revisionDate?: StringFieldUpdateOperationsInput | string
    kills?: PlayerKillUpdateManyWithoutKillerInput
    teams?: TeamUpdateManyWithoutPlayersInput
    profile?: ProfileUpdateOneWithoutPlayerInput
    monsterKills?: TeamMonsterKillUpdateManyWithoutKillerInput
    buildingKills?: TeamBuildingKillUpdateManyWithoutKillerInput
    itemEvent?: PlayerItemEventUpdateManyWithoutPlayerInput
    endOfGameStats?: PlayerEndOfGameStatUpdateManyWithoutPlayerInput
    snapshots?: PlayerSnapshotUpdateManyWithoutPlayerInput
    wardEvents?: PlayerWardEventUpdateManyWithoutPlayerInput
    skillLevelUpEvents?: PlayerSkillLevelUpEventUpdateManyWithoutPlayerInput
  }

  export type PlayerUncheckedUpdateWithoutDeathsInput = {
    id?: StringFieldUpdateOperationsInput | string
    puuid?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    platformId?: StringFieldUpdateOperationsInput | string
    summonerId?: StringFieldUpdateOperationsInput | string
    summonerName?: StringFieldUpdateOperationsInput | string
    summonerLevel?: NullableIntFieldUpdateOperationsInput | number | null
    profileIconId?: NullableIntFieldUpdateOperationsInput | number | null
    revisionDate?: StringFieldUpdateOperationsInput | string
    kills?: PlayerKillUncheckedUpdateManyWithoutKillerInput
    teams?: TeamUncheckedUpdateManyWithoutPlayersInput
    profileId?: NullableStringFieldUpdateOperationsInput | string | null
    monsterKills?: TeamMonsterKillUncheckedUpdateManyWithoutKillerInput
    buildingKills?: TeamBuildingKillUncheckedUpdateManyWithoutKillerInput
    itemEvent?: PlayerItemEventUncheckedUpdateManyWithoutPlayerInput
    endOfGameStats?: PlayerEndOfGameStatUncheckedUpdateManyWithoutPlayerInput
    snapshots?: PlayerSnapshotUncheckedUpdateManyWithoutPlayerInput
    wardEvents?: PlayerWardEventUncheckedUpdateManyWithoutPlayerInput
    skillLevelUpEvents?: PlayerSkillLevelUpEventUncheckedUpdateManyWithoutPlayerInput
  }

  export type PlayerUncheckedUpdateManyWithoutVictimInput = {
    id?: StringFieldUpdateOperationsInput | string
    puuid?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    platformId?: StringFieldUpdateOperationsInput | string
    summonerId?: StringFieldUpdateOperationsInput | string
    summonerName?: StringFieldUpdateOperationsInput | string
    summonerLevel?: NullableIntFieldUpdateOperationsInput | number | null
    profileIconId?: NullableIntFieldUpdateOperationsInput | number | null
    revisionDate?: StringFieldUpdateOperationsInput | string
    profileId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RuneStyleCreateManyPlayerRunesInput = {
    id?: string
    description?: string
    style?: number | null
  }

  export type RuneStyleUpdateWithoutPlayerRunesInput = {
    id?: StringFieldUpdateOperationsInput | string
    selection?: RuneSelectionUpdateManyWithoutRuneStyleInput
    description?: StringFieldUpdateOperationsInput | string
    style?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RuneStyleUncheckedUpdateWithoutPlayerRunesInput = {
    id?: StringFieldUpdateOperationsInput | string
    selection?: RuneSelectionUncheckedUpdateManyWithoutRuneStyleInput
    description?: StringFieldUpdateOperationsInput | string
    style?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RuneStyleUncheckedUpdateManyWithoutRuneStyleInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    style?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PlayerUpdateWithoutSkillLevelUpEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    puuid?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    platformId?: StringFieldUpdateOperationsInput | string
    summonerId?: StringFieldUpdateOperationsInput | string
    summonerName?: StringFieldUpdateOperationsInput | string
    summonerLevel?: NullableIntFieldUpdateOperationsInput | number | null
    profileIconId?: NullableIntFieldUpdateOperationsInput | number | null
    revisionDate?: StringFieldUpdateOperationsInput | string
    kills?: PlayerKillUpdateManyWithoutKillerInput
    deaths?: PlayerKillUpdateManyWithoutVictimInput
    teams?: TeamUpdateManyWithoutPlayersInput
    profile?: ProfileUpdateOneWithoutPlayerInput
    monsterKills?: TeamMonsterKillUpdateManyWithoutKillerInput
    buildingKills?: TeamBuildingKillUpdateManyWithoutKillerInput
    itemEvent?: PlayerItemEventUpdateManyWithoutPlayerInput
    endOfGameStats?: PlayerEndOfGameStatUpdateManyWithoutPlayerInput
    snapshots?: PlayerSnapshotUpdateManyWithoutPlayerInput
    wardEvents?: PlayerWardEventUpdateManyWithoutPlayerInput
  }

  export type PlayerUncheckedUpdateWithoutSkillLevelUpEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    puuid?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    platformId?: StringFieldUpdateOperationsInput | string
    summonerId?: StringFieldUpdateOperationsInput | string
    summonerName?: StringFieldUpdateOperationsInput | string
    summonerLevel?: NullableIntFieldUpdateOperationsInput | number | null
    profileIconId?: NullableIntFieldUpdateOperationsInput | number | null
    revisionDate?: StringFieldUpdateOperationsInput | string
    kills?: PlayerKillUncheckedUpdateManyWithoutKillerInput
    deaths?: PlayerKillUncheckedUpdateManyWithoutVictimInput
    teams?: TeamUncheckedUpdateManyWithoutPlayersInput
    profileId?: NullableStringFieldUpdateOperationsInput | string | null
    monsterKills?: TeamMonsterKillUncheckedUpdateManyWithoutKillerInput
    buildingKills?: TeamBuildingKillUncheckedUpdateManyWithoutKillerInput
    itemEvent?: PlayerItemEventUncheckedUpdateManyWithoutPlayerInput
    endOfGameStats?: PlayerEndOfGameStatUncheckedUpdateManyWithoutPlayerInput
    snapshots?: PlayerSnapshotUncheckedUpdateManyWithoutPlayerInput
    wardEvents?: PlayerWardEventUncheckedUpdateManyWithoutPlayerInput
  }

  export type PositionUpdateWithoutPlayerSnapshotInput = {
    id?: StringFieldUpdateOperationsInput | string
    event?: EventUpdateManyWithoutPositionInput
    x?: NullableIntFieldUpdateOperationsInput | number | null
    y?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PositionUncheckedUpdateWithoutPlayerSnapshotInput = {
    id?: StringFieldUpdateOperationsInput | string
    event?: EventUncheckedUpdateManyWithoutPositionInput
    x?: NullableIntFieldUpdateOperationsInput | number | null
    y?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PlayerUpdateWithoutSnapshotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    puuid?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    platformId?: StringFieldUpdateOperationsInput | string
    summonerId?: StringFieldUpdateOperationsInput | string
    summonerName?: StringFieldUpdateOperationsInput | string
    summonerLevel?: NullableIntFieldUpdateOperationsInput | number | null
    profileIconId?: NullableIntFieldUpdateOperationsInput | number | null
    revisionDate?: StringFieldUpdateOperationsInput | string
    kills?: PlayerKillUpdateManyWithoutKillerInput
    deaths?: PlayerKillUpdateManyWithoutVictimInput
    teams?: TeamUpdateManyWithoutPlayersInput
    profile?: ProfileUpdateOneWithoutPlayerInput
    monsterKills?: TeamMonsterKillUpdateManyWithoutKillerInput
    buildingKills?: TeamBuildingKillUpdateManyWithoutKillerInput
    itemEvent?: PlayerItemEventUpdateManyWithoutPlayerInput
    endOfGameStats?: PlayerEndOfGameStatUpdateManyWithoutPlayerInput
    wardEvents?: PlayerWardEventUpdateManyWithoutPlayerInput
    skillLevelUpEvents?: PlayerSkillLevelUpEventUpdateManyWithoutPlayerInput
  }

  export type PlayerUncheckedUpdateWithoutSnapshotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    puuid?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    platformId?: StringFieldUpdateOperationsInput | string
    summonerId?: StringFieldUpdateOperationsInput | string
    summonerName?: StringFieldUpdateOperationsInput | string
    summonerLevel?: NullableIntFieldUpdateOperationsInput | number | null
    profileIconId?: NullableIntFieldUpdateOperationsInput | number | null
    revisionDate?: StringFieldUpdateOperationsInput | string
    kills?: PlayerKillUncheckedUpdateManyWithoutKillerInput
    deaths?: PlayerKillUncheckedUpdateManyWithoutVictimInput
    teams?: TeamUncheckedUpdateManyWithoutPlayersInput
    profileId?: NullableStringFieldUpdateOperationsInput | string | null
    monsterKills?: TeamMonsterKillUncheckedUpdateManyWithoutKillerInput
    buildingKills?: TeamBuildingKillUncheckedUpdateManyWithoutKillerInput
    itemEvent?: PlayerItemEventUncheckedUpdateManyWithoutPlayerInput
    endOfGameStats?: PlayerEndOfGameStatUncheckedUpdateManyWithoutPlayerInput
    wardEvents?: PlayerWardEventUncheckedUpdateManyWithoutPlayerInput
    skillLevelUpEvents?: PlayerSkillLevelUpEventUncheckedUpdateManyWithoutPlayerInput
  }

  export type PlayerUpdateWithoutWardEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    puuid?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    platformId?: StringFieldUpdateOperationsInput | string
    summonerId?: StringFieldUpdateOperationsInput | string
    summonerName?: StringFieldUpdateOperationsInput | string
    summonerLevel?: NullableIntFieldUpdateOperationsInput | number | null
    profileIconId?: NullableIntFieldUpdateOperationsInput | number | null
    revisionDate?: StringFieldUpdateOperationsInput | string
    kills?: PlayerKillUpdateManyWithoutKillerInput
    deaths?: PlayerKillUpdateManyWithoutVictimInput
    teams?: TeamUpdateManyWithoutPlayersInput
    profile?: ProfileUpdateOneWithoutPlayerInput
    monsterKills?: TeamMonsterKillUpdateManyWithoutKillerInput
    buildingKills?: TeamBuildingKillUpdateManyWithoutKillerInput
    itemEvent?: PlayerItemEventUpdateManyWithoutPlayerInput
    endOfGameStats?: PlayerEndOfGameStatUpdateManyWithoutPlayerInput
    snapshots?: PlayerSnapshotUpdateManyWithoutPlayerInput
    skillLevelUpEvents?: PlayerSkillLevelUpEventUpdateManyWithoutPlayerInput
  }

  export type PlayerUncheckedUpdateWithoutWardEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    puuid?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    platformId?: StringFieldUpdateOperationsInput | string
    summonerId?: StringFieldUpdateOperationsInput | string
    summonerName?: StringFieldUpdateOperationsInput | string
    summonerLevel?: NullableIntFieldUpdateOperationsInput | number | null
    profileIconId?: NullableIntFieldUpdateOperationsInput | number | null
    revisionDate?: StringFieldUpdateOperationsInput | string
    kills?: PlayerKillUncheckedUpdateManyWithoutKillerInput
    deaths?: PlayerKillUncheckedUpdateManyWithoutVictimInput
    teams?: TeamUncheckedUpdateManyWithoutPlayersInput
    profileId?: NullableStringFieldUpdateOperationsInput | string | null
    monsterKills?: TeamMonsterKillUncheckedUpdateManyWithoutKillerInput
    buildingKills?: TeamBuildingKillUncheckedUpdateManyWithoutKillerInput
    itemEvent?: PlayerItemEventUncheckedUpdateManyWithoutPlayerInput
    endOfGameStats?: PlayerEndOfGameStatUncheckedUpdateManyWithoutPlayerInput
    snapshots?: PlayerSnapshotUncheckedUpdateManyWithoutPlayerInput
    skillLevelUpEvents?: PlayerSkillLevelUpEventUncheckedUpdateManyWithoutPlayerInput
  }

  export type EventUpdateWithoutPositionInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type EventUncheckedUpdateWithoutPositionInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type EventUncheckedUpdateManyWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PlayerSnapshotUpdateWithoutPositionInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: NullableFloatFieldUpdateOperationsInput | number | null
    currentGold?: NullableIntFieldUpdateOperationsInput | number | null
    totalGold?: NullableIntFieldUpdateOperationsInput | number | null
    totalGoldDiff?: NullableIntFieldUpdateOperationsInput | number | null
    xp?: NullableIntFieldUpdateOperationsInput | number | null
    xpDiff?: NullableIntFieldUpdateOperationsInput | number | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    cs?: NullableIntFieldUpdateOperationsInput | number | null
    csDiff?: NullableIntFieldUpdateOperationsInput | number | null
    monstersKilled?: NullableIntFieldUpdateOperationsInput | number | null
    monstersKilledDiff?: NullableIntFieldUpdateOperationsInput | number | null
    player?: PlayerUpdateManyWithoutSnapshotsInput
  }

  export type PlayerSnapshotUncheckedUpdateWithoutPositionInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: NullableFloatFieldUpdateOperationsInput | number | null
    currentGold?: NullableIntFieldUpdateOperationsInput | number | null
    totalGold?: NullableIntFieldUpdateOperationsInput | number | null
    totalGoldDiff?: NullableIntFieldUpdateOperationsInput | number | null
    xp?: NullableIntFieldUpdateOperationsInput | number | null
    xpDiff?: NullableIntFieldUpdateOperationsInput | number | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    cs?: NullableIntFieldUpdateOperationsInput | number | null
    csDiff?: NullableIntFieldUpdateOperationsInput | number | null
    monstersKilled?: NullableIntFieldUpdateOperationsInput | number | null
    monstersKilledDiff?: NullableIntFieldUpdateOperationsInput | number | null
    player?: PlayerUncheckedUpdateManyWithoutSnapshotsInput
  }

  export type PlayerSnapshotUncheckedUpdateManyWithoutPlayerSnapshotInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: NullableFloatFieldUpdateOperationsInput | number | null
    currentGold?: NullableIntFieldUpdateOperationsInput | number | null
    totalGold?: NullableIntFieldUpdateOperationsInput | number | null
    totalGoldDiff?: NullableIntFieldUpdateOperationsInput | number | null
    xp?: NullableIntFieldUpdateOperationsInput | number | null
    xpDiff?: NullableIntFieldUpdateOperationsInput | number | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    cs?: NullableIntFieldUpdateOperationsInput | number | null
    csDiff?: NullableIntFieldUpdateOperationsInput | number | null
    monstersKilled?: NullableIntFieldUpdateOperationsInput | number | null
    monstersKilledDiff?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ActivityCreateManyProfileInput = {
    id?: string
    month?: number | null
    year?: number | null
    day?: number | null
    gamesPlayed?: number | null
  }

  export type ChampionWinrateCreateManyProfileInput = {
    id?: string
    champion?: string
    wins?: number | null
    games?: number | null
    spell1Casts?: number | null
    spell2Casts?: number | null
    spell3Casts?: number | null
    spell4Casts?: number | null
  }

  export type DuoCreateManyProfileInput = {
    id?: string
    name?: string
    wins?: number | null
    losses?: number | null
    winrate?: string
  }

  export type ActivityUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: NullableIntFieldUpdateOperationsInput | number | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    day?: NullableIntFieldUpdateOperationsInput | number | null
    gamesPlayed?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ActivityUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: NullableIntFieldUpdateOperationsInput | number | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    day?: NullableIntFieldUpdateOperationsInput | number | null
    gamesPlayed?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ActivityUncheckedUpdateManyWithoutActivityInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: NullableIntFieldUpdateOperationsInput | number | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    day?: NullableIntFieldUpdateOperationsInput | number | null
    gamesPlayed?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ChampionWinrateUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    champion?: StringFieldUpdateOperationsInput | string
    wins?: NullableIntFieldUpdateOperationsInput | number | null
    games?: NullableIntFieldUpdateOperationsInput | number | null
    spell1Casts?: NullableIntFieldUpdateOperationsInput | number | null
    spell2Casts?: NullableIntFieldUpdateOperationsInput | number | null
    spell3Casts?: NullableIntFieldUpdateOperationsInput | number | null
    spell4Casts?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ChampionWinrateUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    champion?: StringFieldUpdateOperationsInput | string
    wins?: NullableIntFieldUpdateOperationsInput | number | null
    games?: NullableIntFieldUpdateOperationsInput | number | null
    spell1Casts?: NullableIntFieldUpdateOperationsInput | number | null
    spell2Casts?: NullableIntFieldUpdateOperationsInput | number | null
    spell3Casts?: NullableIntFieldUpdateOperationsInput | number | null
    spell4Casts?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ChampionWinrateUncheckedUpdateManyWithoutChampionWinrateInput = {
    id?: StringFieldUpdateOperationsInput | string
    champion?: StringFieldUpdateOperationsInput | string
    wins?: NullableIntFieldUpdateOperationsInput | number | null
    games?: NullableIntFieldUpdateOperationsInput | number | null
    spell1Casts?: NullableIntFieldUpdateOperationsInput | number | null
    spell2Casts?: NullableIntFieldUpdateOperationsInput | number | null
    spell3Casts?: NullableIntFieldUpdateOperationsInput | number | null
    spell4Casts?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type DuoUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    wins?: NullableIntFieldUpdateOperationsInput | number | null
    losses?: NullableIntFieldUpdateOperationsInput | number | null
    winrate?: StringFieldUpdateOperationsInput | string
  }

  export type DuoUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    wins?: NullableIntFieldUpdateOperationsInput | number | null
    losses?: NullableIntFieldUpdateOperationsInput | number | null
    winrate?: StringFieldUpdateOperationsInput | string
  }

  export type DuoUncheckedUpdateManyWithoutDuosInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    wins?: NullableIntFieldUpdateOperationsInput | number | null
    losses?: NullableIntFieldUpdateOperationsInput | number | null
    winrate?: StringFieldUpdateOperationsInput | string
  }

  export type GameUpdateWithoutSourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    matchId?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    gameCreation?: StringFieldUpdateOperationsInput | string
    gameStartTimestamp?: StringFieldUpdateOperationsInput | string
    gameEndTimestamp?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    start?: StringFieldUpdateOperationsInput | string
    gameVersion?: StringFieldUpdateOperationsInput | string
    blueTeam?: TeamUpdateOneWithoutFrom_Game_blueTeamInput
    redTeam?: TeamUpdateOneWithoutFrom_Game_redTeamInput
    tournament?: StringFieldUpdateOperationsInput | string
    gameInSeries?: NullableIntFieldUpdateOperationsInput | number | null
    vod?: StringFieldUpdateOperationsInput | string
    platformId?: StringFieldUpdateOperationsInput | string
    from_PlayerEndOfGameStat_game?: PlayerEndOfGameStatUpdateManyWithoutGameInput
    from_Team_game?: TeamUpdateManyWithoutGameInput
  }

  export type GameUncheckedUpdateWithoutSourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    matchId?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    gameCreation?: StringFieldUpdateOperationsInput | string
    gameStartTimestamp?: StringFieldUpdateOperationsInput | string
    gameEndTimestamp?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    start?: StringFieldUpdateOperationsInput | string
    gameVersion?: StringFieldUpdateOperationsInput | string
    blueTeamId?: NullableStringFieldUpdateOperationsInput | string | null
    redTeamId?: NullableStringFieldUpdateOperationsInput | string | null
    tournament?: StringFieldUpdateOperationsInput | string
    gameInSeries?: NullableIntFieldUpdateOperationsInput | number | null
    vod?: StringFieldUpdateOperationsInput | string
    platformId?: StringFieldUpdateOperationsInput | string
    from_PlayerEndOfGameStat_game?: PlayerEndOfGameStatUncheckedUpdateManyWithoutGameInput
    from_Team_game?: TeamUncheckedUpdateManyWithoutGameInput
  }

  export type GameUncheckedUpdateManyWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    matchId?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    gameCreation?: StringFieldUpdateOperationsInput | string
    gameStartTimestamp?: StringFieldUpdateOperationsInput | string
    gameEndTimestamp?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    start?: StringFieldUpdateOperationsInput | string
    gameVersion?: StringFieldUpdateOperationsInput | string
    blueTeamId?: NullableStringFieldUpdateOperationsInput | string | null
    redTeamId?: NullableStringFieldUpdateOperationsInput | string | null
    tournament?: StringFieldUpdateOperationsInput | string
    gameInSeries?: NullableIntFieldUpdateOperationsInput | number | null
    vod?: StringFieldUpdateOperationsInput | string
    platformId?: StringFieldUpdateOperationsInput | string
  }

  export type PickBanCreateManyTeamInput = {
    id?: string
    championId?: number | null
    pickTurn?: number | null
  }

  export type ObjectiveCreateManyTeamInput = {
    id?: string
    first?: boolean
    kills?: number | null
    type?: string
  }

  export type GameCreateManyBlueTeamInput = {
    id?: string
    matchId?: string
    gameId?: string
    gameCreation?: string
    gameStartTimestamp?: string
    gameEndTimestamp?: string
    duration?: number | null
    start?: string
    gameVersion?: string
    redTeamId?: string | null
    tournament?: string
    gameInSeries?: number | null
    vod?: string
    platformId?: string
  }

  export type GameCreateManyRedTeamInput = {
    id?: string
    matchId?: string
    gameId?: string
    gameCreation?: string
    gameStartTimestamp?: string
    gameEndTimestamp?: string
    duration?: number | null
    start?: string
    gameVersion?: string
    blueTeamId?: string | null
    tournament?: string
    gameInSeries?: number | null
    vod?: string
    platformId?: string
  }

  export type PickBanUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    championId?: NullableIntFieldUpdateOperationsInput | number | null
    pickTurn?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PickBanUncheckedUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    championId?: NullableIntFieldUpdateOperationsInput | number | null
    pickTurn?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PickBanUncheckedUpdateManyWithoutPickBanInput = {
    id?: StringFieldUpdateOperationsInput | string
    championId?: NullableIntFieldUpdateOperationsInput | number | null
    pickTurn?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PlayerUpdateWithoutTeamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    puuid?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    platformId?: StringFieldUpdateOperationsInput | string
    summonerId?: StringFieldUpdateOperationsInput | string
    summonerName?: StringFieldUpdateOperationsInput | string
    summonerLevel?: NullableIntFieldUpdateOperationsInput | number | null
    profileIconId?: NullableIntFieldUpdateOperationsInput | number | null
    revisionDate?: StringFieldUpdateOperationsInput | string
    kills?: PlayerKillUpdateManyWithoutKillerInput
    deaths?: PlayerKillUpdateManyWithoutVictimInput
    profile?: ProfileUpdateOneWithoutPlayerInput
    monsterKills?: TeamMonsterKillUpdateManyWithoutKillerInput
    buildingKills?: TeamBuildingKillUpdateManyWithoutKillerInput
    itemEvent?: PlayerItemEventUpdateManyWithoutPlayerInput
    endOfGameStats?: PlayerEndOfGameStatUpdateManyWithoutPlayerInput
    snapshots?: PlayerSnapshotUpdateManyWithoutPlayerInput
    wardEvents?: PlayerWardEventUpdateManyWithoutPlayerInput
    skillLevelUpEvents?: PlayerSkillLevelUpEventUpdateManyWithoutPlayerInput
  }

  export type PlayerUncheckedUpdateWithoutTeamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    puuid?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    platformId?: StringFieldUpdateOperationsInput | string
    summonerId?: StringFieldUpdateOperationsInput | string
    summonerName?: StringFieldUpdateOperationsInput | string
    summonerLevel?: NullableIntFieldUpdateOperationsInput | number | null
    profileIconId?: NullableIntFieldUpdateOperationsInput | number | null
    revisionDate?: StringFieldUpdateOperationsInput | string
    kills?: PlayerKillUncheckedUpdateManyWithoutKillerInput
    deaths?: PlayerKillUncheckedUpdateManyWithoutVictimInput
    profileId?: NullableStringFieldUpdateOperationsInput | string | null
    monsterKills?: TeamMonsterKillUncheckedUpdateManyWithoutKillerInput
    buildingKills?: TeamBuildingKillUncheckedUpdateManyWithoutKillerInput
    itemEvent?: PlayerItemEventUncheckedUpdateManyWithoutPlayerInput
    endOfGameStats?: PlayerEndOfGameStatUncheckedUpdateManyWithoutPlayerInput
    snapshots?: PlayerSnapshotUncheckedUpdateManyWithoutPlayerInput
    wardEvents?: PlayerWardEventUncheckedUpdateManyWithoutPlayerInput
    skillLevelUpEvents?: PlayerSkillLevelUpEventUncheckedUpdateManyWithoutPlayerInput
  }

  export type PlayerUncheckedUpdateManyWithoutPlayersInput = {
    id?: StringFieldUpdateOperationsInput | string
    puuid?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    platformId?: StringFieldUpdateOperationsInput | string
    summonerId?: StringFieldUpdateOperationsInput | string
    summonerName?: StringFieldUpdateOperationsInput | string
    summonerLevel?: NullableIntFieldUpdateOperationsInput | number | null
    profileIconId?: NullableIntFieldUpdateOperationsInput | number | null
    revisionDate?: StringFieldUpdateOperationsInput | string
    profileId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ObjectiveUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    first?: BoolFieldUpdateOperationsInput | boolean
    kills?: NullableIntFieldUpdateOperationsInput | number | null
    type?: StringFieldUpdateOperationsInput | string
  }

  export type ObjectiveUncheckedUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    first?: BoolFieldUpdateOperationsInput | boolean
    kills?: NullableIntFieldUpdateOperationsInput | number | null
    type?: StringFieldUpdateOperationsInput | string
  }

  export type ObjectiveUncheckedUpdateManyWithoutObjectivesInput = {
    id?: StringFieldUpdateOperationsInput | string
    first?: BoolFieldUpdateOperationsInput | boolean
    kills?: NullableIntFieldUpdateOperationsInput | number | null
    type?: StringFieldUpdateOperationsInput | string
  }

  export type GameUpdateWithoutBlueTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    matchId?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    gameCreation?: StringFieldUpdateOperationsInput | string
    gameStartTimestamp?: StringFieldUpdateOperationsInput | string
    gameEndTimestamp?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    start?: StringFieldUpdateOperationsInput | string
    gameVersion?: StringFieldUpdateOperationsInput | string
    redTeam?: TeamUpdateOneWithoutFrom_Game_redTeamInput
    source?: SourceUpdateManyWithoutGameInput
    tournament?: StringFieldUpdateOperationsInput | string
    gameInSeries?: NullableIntFieldUpdateOperationsInput | number | null
    vod?: StringFieldUpdateOperationsInput | string
    platformId?: StringFieldUpdateOperationsInput | string
    from_PlayerEndOfGameStat_game?: PlayerEndOfGameStatUpdateManyWithoutGameInput
    from_Team_game?: TeamUpdateManyWithoutGameInput
  }

  export type GameUncheckedUpdateWithoutBlueTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    matchId?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    gameCreation?: StringFieldUpdateOperationsInput | string
    gameStartTimestamp?: StringFieldUpdateOperationsInput | string
    gameEndTimestamp?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    start?: StringFieldUpdateOperationsInput | string
    gameVersion?: StringFieldUpdateOperationsInput | string
    redTeamId?: NullableStringFieldUpdateOperationsInput | string | null
    source?: SourceUncheckedUpdateManyWithoutGameInput
    tournament?: StringFieldUpdateOperationsInput | string
    gameInSeries?: NullableIntFieldUpdateOperationsInput | number | null
    vod?: StringFieldUpdateOperationsInput | string
    platformId?: StringFieldUpdateOperationsInput | string
    from_PlayerEndOfGameStat_game?: PlayerEndOfGameStatUncheckedUpdateManyWithoutGameInput
    from_Team_game?: TeamUncheckedUpdateManyWithoutGameInput
  }

  export type GameUncheckedUpdateManyWithoutFrom_Game_blueTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    matchId?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    gameCreation?: StringFieldUpdateOperationsInput | string
    gameStartTimestamp?: StringFieldUpdateOperationsInput | string
    gameEndTimestamp?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    start?: StringFieldUpdateOperationsInput | string
    gameVersion?: StringFieldUpdateOperationsInput | string
    redTeamId?: NullableStringFieldUpdateOperationsInput | string | null
    tournament?: StringFieldUpdateOperationsInput | string
    gameInSeries?: NullableIntFieldUpdateOperationsInput | number | null
    vod?: StringFieldUpdateOperationsInput | string
    platformId?: StringFieldUpdateOperationsInput | string
  }

  export type GameUpdateWithoutRedTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    matchId?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    gameCreation?: StringFieldUpdateOperationsInput | string
    gameStartTimestamp?: StringFieldUpdateOperationsInput | string
    gameEndTimestamp?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    start?: StringFieldUpdateOperationsInput | string
    gameVersion?: StringFieldUpdateOperationsInput | string
    blueTeam?: TeamUpdateOneWithoutFrom_Game_blueTeamInput
    source?: SourceUpdateManyWithoutGameInput
    tournament?: StringFieldUpdateOperationsInput | string
    gameInSeries?: NullableIntFieldUpdateOperationsInput | number | null
    vod?: StringFieldUpdateOperationsInput | string
    platformId?: StringFieldUpdateOperationsInput | string
    from_PlayerEndOfGameStat_game?: PlayerEndOfGameStatUpdateManyWithoutGameInput
    from_Team_game?: TeamUpdateManyWithoutGameInput
  }

  export type GameUncheckedUpdateWithoutRedTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    matchId?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    gameCreation?: StringFieldUpdateOperationsInput | string
    gameStartTimestamp?: StringFieldUpdateOperationsInput | string
    gameEndTimestamp?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    start?: StringFieldUpdateOperationsInput | string
    gameVersion?: StringFieldUpdateOperationsInput | string
    blueTeamId?: NullableStringFieldUpdateOperationsInput | string | null
    source?: SourceUncheckedUpdateManyWithoutGameInput
    tournament?: StringFieldUpdateOperationsInput | string
    gameInSeries?: NullableIntFieldUpdateOperationsInput | number | null
    vod?: StringFieldUpdateOperationsInput | string
    platformId?: StringFieldUpdateOperationsInput | string
    from_PlayerEndOfGameStat_game?: PlayerEndOfGameStatUncheckedUpdateManyWithoutGameInput
    from_Team_game?: TeamUncheckedUpdateManyWithoutGameInput
  }

  export type GameUncheckedUpdateManyWithoutFrom_Game_redTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    matchId?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    gameCreation?: StringFieldUpdateOperationsInput | string
    gameStartTimestamp?: StringFieldUpdateOperationsInput | string
    gameEndTimestamp?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    start?: StringFieldUpdateOperationsInput | string
    gameVersion?: StringFieldUpdateOperationsInput | string
    blueTeamId?: NullableStringFieldUpdateOperationsInput | string | null
    tournament?: StringFieldUpdateOperationsInput | string
    gameInSeries?: NullableIntFieldUpdateOperationsInput | number | null
    vod?: StringFieldUpdateOperationsInput | string
    platformId?: StringFieldUpdateOperationsInput | string
  }

  export type PlayerUpdateWithoutBuildingKillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    puuid?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    platformId?: StringFieldUpdateOperationsInput | string
    summonerId?: StringFieldUpdateOperationsInput | string
    summonerName?: StringFieldUpdateOperationsInput | string
    summonerLevel?: NullableIntFieldUpdateOperationsInput | number | null
    profileIconId?: NullableIntFieldUpdateOperationsInput | number | null
    revisionDate?: StringFieldUpdateOperationsInput | string
    kills?: PlayerKillUpdateManyWithoutKillerInput
    deaths?: PlayerKillUpdateManyWithoutVictimInput
    teams?: TeamUpdateManyWithoutPlayersInput
    profile?: ProfileUpdateOneWithoutPlayerInput
    monsterKills?: TeamMonsterKillUpdateManyWithoutKillerInput
    itemEvent?: PlayerItemEventUpdateManyWithoutPlayerInput
    endOfGameStats?: PlayerEndOfGameStatUpdateManyWithoutPlayerInput
    snapshots?: PlayerSnapshotUpdateManyWithoutPlayerInput
    wardEvents?: PlayerWardEventUpdateManyWithoutPlayerInput
    skillLevelUpEvents?: PlayerSkillLevelUpEventUpdateManyWithoutPlayerInput
  }

  export type PlayerUncheckedUpdateWithoutBuildingKillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    puuid?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    platformId?: StringFieldUpdateOperationsInput | string
    summonerId?: StringFieldUpdateOperationsInput | string
    summonerName?: StringFieldUpdateOperationsInput | string
    summonerLevel?: NullableIntFieldUpdateOperationsInput | number | null
    profileIconId?: NullableIntFieldUpdateOperationsInput | number | null
    revisionDate?: StringFieldUpdateOperationsInput | string
    kills?: PlayerKillUncheckedUpdateManyWithoutKillerInput
    deaths?: PlayerKillUncheckedUpdateManyWithoutVictimInput
    teams?: TeamUncheckedUpdateManyWithoutPlayersInput
    profileId?: NullableStringFieldUpdateOperationsInput | string | null
    monsterKills?: TeamMonsterKillUncheckedUpdateManyWithoutKillerInput
    itemEvent?: PlayerItemEventUncheckedUpdateManyWithoutPlayerInput
    endOfGameStats?: PlayerEndOfGameStatUncheckedUpdateManyWithoutPlayerInput
    snapshots?: PlayerSnapshotUncheckedUpdateManyWithoutPlayerInput
    wardEvents?: PlayerWardEventUncheckedUpdateManyWithoutPlayerInput
    skillLevelUpEvents?: PlayerSkillLevelUpEventUncheckedUpdateManyWithoutPlayerInput
  }

  export type PlayerUpdateWithoutMonsterKillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    puuid?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    platformId?: StringFieldUpdateOperationsInput | string
    summonerId?: StringFieldUpdateOperationsInput | string
    summonerName?: StringFieldUpdateOperationsInput | string
    summonerLevel?: NullableIntFieldUpdateOperationsInput | number | null
    profileIconId?: NullableIntFieldUpdateOperationsInput | number | null
    revisionDate?: StringFieldUpdateOperationsInput | string
    kills?: PlayerKillUpdateManyWithoutKillerInput
    deaths?: PlayerKillUpdateManyWithoutVictimInput
    teams?: TeamUpdateManyWithoutPlayersInput
    profile?: ProfileUpdateOneWithoutPlayerInput
    buildingKills?: TeamBuildingKillUpdateManyWithoutKillerInput
    itemEvent?: PlayerItemEventUpdateManyWithoutPlayerInput
    endOfGameStats?: PlayerEndOfGameStatUpdateManyWithoutPlayerInput
    snapshots?: PlayerSnapshotUpdateManyWithoutPlayerInput
    wardEvents?: PlayerWardEventUpdateManyWithoutPlayerInput
    skillLevelUpEvents?: PlayerSkillLevelUpEventUpdateManyWithoutPlayerInput
  }

  export type PlayerUncheckedUpdateWithoutMonsterKillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    puuid?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    platformId?: StringFieldUpdateOperationsInput | string
    summonerId?: StringFieldUpdateOperationsInput | string
    summonerName?: StringFieldUpdateOperationsInput | string
    summonerLevel?: NullableIntFieldUpdateOperationsInput | number | null
    profileIconId?: NullableIntFieldUpdateOperationsInput | number | null
    revisionDate?: StringFieldUpdateOperationsInput | string
    kills?: PlayerKillUncheckedUpdateManyWithoutKillerInput
    deaths?: PlayerKillUncheckedUpdateManyWithoutVictimInput
    teams?: TeamUncheckedUpdateManyWithoutPlayersInput
    profileId?: NullableStringFieldUpdateOperationsInput | string | null
    buildingKills?: TeamBuildingKillUncheckedUpdateManyWithoutKillerInput
    itemEvent?: PlayerItemEventUncheckedUpdateManyWithoutPlayerInput
    endOfGameStats?: PlayerEndOfGameStatUncheckedUpdateManyWithoutPlayerInput
    snapshots?: PlayerSnapshotUncheckedUpdateManyWithoutPlayerInput
    wardEvents?: PlayerWardEventUncheckedUpdateManyWithoutPlayerInput
    skillLevelUpEvents?: PlayerSkillLevelUpEventUncheckedUpdateManyWithoutPlayerInput
  }

  export type RuneSelectionCreateManyRuneStyleInput = {
    id?: string
    perk?: number | null
    var1?: number | null
    var2?: number | null
    var3?: number | null
  }

  export type RuneSelectionUpdateWithoutRuneStyleInput = {
    id?: StringFieldUpdateOperationsInput | string
    perk?: NullableIntFieldUpdateOperationsInput | number | null
    var1?: NullableIntFieldUpdateOperationsInput | number | null
    var2?: NullableIntFieldUpdateOperationsInput | number | null
    var3?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RuneSelectionUncheckedUpdateWithoutRuneStyleInput = {
    id?: StringFieldUpdateOperationsInput | string
    perk?: NullableIntFieldUpdateOperationsInput | number | null
    var1?: NullableIntFieldUpdateOperationsInput | number | null
    var2?: NullableIntFieldUpdateOperationsInput | number | null
    var3?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RuneSelectionUncheckedUpdateManyWithoutSelectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    perk?: NullableIntFieldUpdateOperationsInput | number | null
    var1?: NullableIntFieldUpdateOperationsInput | number | null
    var2?: NullableIntFieldUpdateOperationsInput | number | null
    var3?: NullableIntFieldUpdateOperationsInput | number | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.DMMF.Document;
}